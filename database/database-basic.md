# 데이터베이스의 구조와 설계

## 목차
1. 데이터베이스
2. Primary key 란?
3. 관계형 데이터베이스의 N:M
4. Join 연산
5. NoSQL
6. NoSQL vs RDB

# 1. 데이터베이스

## 데이터 베이스를 사용하는 이유
- 데이터 베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리 (현재도 부분적으로 사용중)
- 데이터를 각각의 파일 단위로 저장하며 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동이 되어야 함
- 이때 문제점은 데이터 종속성 문제와 중복성, 데이터 무결성이다.

## 데이터베이스의 특징
### 1. 데이터의 독립성
  - 물리적 독립성: 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요 X
  - 논리적 독립성: 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있음
    
### 2. 데이터의 무결성
  - 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능
  - 데이터 유효성 검사를 통해 무결성을 구현
    
### 3. 데이터의 보안성
  - 인가된 사용자들만 데이터베이스나 내부 자원에 접근 가능하도록 계정 관리 또는 접근 권한을 설정
    
### 4. 데이터의 일관성
  - 연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제 가능
  - 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제 가능
    
### 5. 데이터 중복 최소화
  - 데이터베이스는 데이터를 통합해서 관리
  - 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결 가능

## 데이터베이스의 성능?
- 데이터 베이스의 성능 이슈는 디스크 I/O를 어떻게 줄이느냐에서 시작
- 디스크 I/O란 디스크 드라이브의 플래터(원판)을 돌려 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 후 읽는것을 의미
- 데이터를 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단게에서 결정
- 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하냐에 따라 결정된다고 볼 수 있음

- 그렇기 때문에 순차 I/O가 랜덤 I/O보다 빠를 수 밖에 없다
- 하지만 현실에서는 대부분 랜덤 I/O
- 랜덤 I/O를 순차 I/O로 바꿔서 실행할 수 없을까에 대한 생각부터 시작되는 DB쿼리튜닝은 랜덤 I/O 자체를 줄여주는 것이 목적이라고 할 수 있음

# 2. Primary Key
- candidate key 중 선택한 main key
- 각 row를 유니크하게 구분하는 column(또는 column의 집합)을 의미
- 기본키는 NULL값을 가질 수 없고, 중복된 값을 가질 수 없음
- 기본키는 테이블 당 1개

> ### Relation
> 
> - 테이블 중 데이터베이스에서 사용되기 위한 조건을 갖춘 것이 relation
> - Relation의 제약 조건 중 가장 자주 등장하는 조건은 다음과 같음
>   1. table의 cell은 단일 값을 갖는다
>   2. 어떤 두 개의 row도 동일하지 않다
> - 통상적으로 relation과 table이란 용어를 구분하지 않고 사용하기도 함
>
> ![image](https://github.com/user-attachments/assets/d748df49-ca4d-4e7f-99a0-ed7628990e89)

### Super Key(슈퍼키)
- 각 row를 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합
- 슈퍼키는 유일성만 만족하면 슈퍼키가 될 수 있음
  - 유일성 : 하나의 key값으로 특정 row만을 유일하게 찾아낼 수 있어야 함
  - 예시: (학번), (학번, 이름) 등

### Candidate key(후보키)
- 슈퍼키 중에서 더이상 쪼개질 수 없는 슈퍼키를 Candidate Key라고 함
-  row를 유일하게 식별할 수 있는 최소한의 속성들의 집합
  - 최소성 : 모든 row를 유일하게 식별되는데 꼭 필요한 속성만으로 구성되어야 함
  - 예시: (학번), (주민번호)

## Primary Key(기본키)
- 후보키 중 선택한 메인 키로써, 각 row를 구분하는 유일한 열을 말함
- 기본키는 널값을 가질 수 없고, 중복될 수 없음
- 기본키는 테이블당 1개만 지정해야 함

### Alternative Key(대체키)
후보키가 두 개 이상일 경우, 기본키로 지정 되지 못하고 남은 후보키들
![image](https://github.com/user-attachments/assets/b4d957e1-1d25-406f-a8be-2e57b490ec2d)

### Composite Key(복합키)
- table에서 각 row를 식별할 수 있는 두 개 이상의 column으로 구성된 candidate key
![image](https://github.com/user-attachments/assets/b6d0cc94-ca8e-47d4-95d0-e450d588f4d6)


# 3. 관계형 데이터베이스의 N:M 관계
- 관계형 데이터베이스에서 양쪽 엔티티 모두가 서로에게 1:N 관계를 갖는 구조

## 1:N 관계
- 관계형 데이터베이스에서 하나의 entity(table)가 관계를 맺은 entity의 여러 객체를 가질 수 있는 구조
- 두 table간의 관계를 mapping cardinality로 표현하고, 종류는 크게 아래와 같음
  - 1:1, 1:N, N:M
- 1:N 구조에서는 보통  primary key - foreign key를 사용하여 관계를 맺음

### Foreign key(외래키)
- 다른 table의 primary key column과 연결되는(참조되는) table의 column을 의미
- 두 테이블을 연결할 때 한 테이블의 외래키가 다른 하나의 테이블의 기본키가 됨

## N:M
- 관계형 데이터베이스에서 양쪽 entity 모두가 서로에게 1:N 관계를 갖는 구조
- N:M 구조에서는 보통 새로운 테이블`(매핑 테이블)`을 통해서 관계를 맺음

![image](https://github.com/user-attachments/assets/a54ecd73-d072-4005-a1e2-e5ff4fedd512)

![image](https://github.com/user-attachments/assets/207f3bf1-f447-49e3-bdb1-8ab07be46a32)


# 4. Join 연산
- Join이란 두 개 이상의 테이블을 서로 연결하여 하나의 결과를 만들어 보여주는 것
- 관계형 데이터베이스에서 데이터는 정규화되어 여러 테이블로 나뉘어져 있음
- 조인을 통해 테이블 간의 관계(주로 PK-FK)를 바탕으로 원하는 정보를 하나로 합쳐서 조회 가능함
- SQL의 핵심 연산 중 하나로, 잘못 설계하면 성능 병목이 될 수 있음

## Inner join (내부 조인)
- 두 테이블을 연결할 때 가장 많이 사용되는 것이 inner join
- inner join은 줄여서 join으로 부르기도 함
- 두 테이블 모두에 공통으로 존재하는 키 값(교집합)을 기준으로 데이터 조합
- 두 테이블을 join하려면 두 테이블이 1:N 관계로 연결되어야 함
- 1:N 관계는 주로 PK와 FK 관계로 맺어져 있음 (상호 조인의 경우는 PK-FK 관계가 아니여도 됨)

## Outer join (외부 조인)
- 한쪽 테이블에만 존재하는 데이터도 결과로 포함시키는 방식
- 줄여서 left, right join이라고 부르기도 함

### FULL OUTER JOIN
- 양쪽 테이블의 모든 데이터를 포함 (MySQL은 직접 지원하지 않음. UNION으로 구현)

![image](https://github.com/user-attachments/assets/86fd585f-9f34-419a-88c2-6a5cb7f92f45)


## Join의 성능 고려사항
- 조인은 데이터 양이 많아질수록 느려짐
- 인덱스가 없으면 Nested Loop Join → 매우 느림
- ON절에 사용하는 컬럼에는 반드시 인덱스가 존재해야 함 (보통 PK, FK는 자동으로 인덱싱 됨)

### 성능 향상을 위한 팁
- 필요한 컬럼만 SELECT (SELECT *)
- JOIN 전에 WHERE 조건 먼저 걸어 필터링
- 중복된 Join 피하기, 다대다 조인 주의

|Join 종류|	설명	|결과 포함 범위|
| --- | --- | --- |
|Inner Join	|양쪽 테이블 모두에 존재하는 데이터만	|교집합
|Left Join|	왼쪽 테이블 전부 + 오른쪽 일치	|왼쪽 기준|
|Right Join|	오른쪽 테이블 전부 + 왼쪽 일치|	오른쪽 기준|
|Full Join	|양쪽 모두 포함 (MySQL은 직접 지원 X)	|전체 합집합|
|Cross Join|	모든 조합 (조건 없음)|	A*B|
|Self Join	|자기 자신과 조인	|계층 구조 등|

# 5. NoSQL
- 관계형 데이터 모델을 지양하며 대량의 분산된 데이터를 저장하고 조회하는데 특화
- 스키마 없이 사용 가능하거나 느슨한 스키마를 제공하는 저장소
- 종류마다 쓰기/읽기 성능 특화, 2차 인덱스 지원, 오토 샤딩 지원 같은 고유 특징을 가짐
- 대량의 데이터를 빠르게 처리하기 위해 메모리에 임시 저장하고 응답하는 등의 방법을 사용
- 동적인 스케일 아웃을 지원하기도 하며, 가용성을 위해 데이터 복제 등의 방법으로 RDB가 제공하지 못하는 성능과 특징 제공

## CAP 이론
### 1. 일관성(Consistency)
- 일관성은 동시성 또는 동일성이라고 하며 다중 클라이언트에서 같은 시간에 조회하는 데이터는 항상 동일한 데이터임을 보증하는 것을 의미
- 관계형 DB가 제공하는 가장 기본적이 기능
- 일관성을 지원하지 않는 NoSQL을 사용한다면 데이터의 일관성이 느슨하게 처리되어 동일한 데이터가 나타나지 않을 수 있음
- 느슨하게 처리된다는 것은 데이터의 변경을 시간의 흐름에 따라 여러 노드에 전파하는 것
- 이러한 방법을 최종적으로 일관성이 유지된다고 하여 최종 일관성 또는 궁극적 일관성을 지원한다고 함

- 각 NoSQL 들은 분산 노드 간의 데이터 동기화를 위해서 두 가지 방법 사용
  - 데이터의 저장 결과를 클라이언트로 응답하기 전에 모든 노드에 데이터를 저장하는 동기식 방법
    - 그만큼 느린 응답시간
    - 데이터의 정합성 보장
  - 메모리나 임시 파일에 기록하고 클라이언트에 먼저 응답한 후, 특정 이벤트나 프로세스를 사용하여 노드로 데이터를 동기화 하는 비동기식 방법
    - 빠른 응답시간을 보임
    - 쓰기 노드에 장애가 발생했을 경우 데이터가 손실될 수 있음

### 2. 가용성 (Availabillity)
- 가용성이란 모든 클라이언트의 읽기와 쓰기 요청에 대해 항상 응답이 가능해야함을 보증하는 것이며 내고장성이라고도 함
- 내고장성을 가진 NoSQL은 클러스터 내에서 몇 개의 노드가 망가지더라도 정상적인 서비스가 가능
- 몇몇 NoSQL은 가용성을 보장하기 위해 데이터 복제(Replication)을 사용
- 동일한 데이터를 다중 노드에 중복 저장하여 그 중 몇대의 노드가 고장나도 데이턱가 유실되지 않도록 하는 방법
- 데이터 중복 저장 방법
  - 동일한 데이터를 가진 저장소를 하나 더 생성하는 Master-Salve 복제 방법
  - 데이터 단위로 중복 저장하는 Peer-to-Peer 복제 방법
 
### 네트워크 분할 허용성 (Partition tolerance)
분할 허용성이란 지역적으로 분할된 네트워크 환경에서 동작하는 시스템에서 두 지역 간의 네트워크가 단절되거나 네트워크 데이터의 유실이 일어나더라도 각 지역 내의 시스템을 정상적으로 동작해야함을 의미

## 저장 방식에 따른 NoSQL 분류
- Key-Value Model
- Document Model
- Column Model
- Graph Model

### Key-Value Model
- 가장 기본적인 형태의 NoSQL
- 키 하나로 데이터 하나를 저장하고 조회할 수 있는 단일 키-값 구조
- 단순한 저장구조로 인해 복잡한 조회연산 지원 x
- 고속 읽기/쓰기에 최적화
- 프로필 정보, 웹 서버 클러스터를 위한 세션 정보, 장바구니 정보, URL 단축 정보 저장 등에 사용
- 하나의 서비스 요청에 다수의 데이터 조회 및 수정 연산이 발생하면 트랜잭션 처리가 불가능하여 정합성 보장 X
  - ex) Redis

### Document Model
- 키-값 모델을 개념적으로 확장한 구조
- 하나의 키에 하나의 구조화된 문서를 저장하고 조회
- 논리적인 데이터 저장과 조회 방법이 RDB와 유사
- 키는 문서에 대한 ID로 표현
- 저장된 문서를 컬렉션으로 관리하며 문서 저장과 동시에 문서 ID에 대한 인덱스를 생성
- 인덱스를 사용하여 O(1) 시간 안에 문서를 조회할 수 있다

- 대부분 문서 모델 NoSQL은 B트리 인덱스를 사용해 2차 인덱스를 생성
- B트리는 크기가 커지면 커질수록 새로운 데이터를 입력하거나 삭제시 성능이 떨어짐
- 읽기와 쓰기의 비율이 7:3 정도일 때 가장 좋은 성능을 보임
- 중앙 집중식 로그 저장, 타임라인 저장, 통계 정보 저장 등에 사용
  - ex) MongoDB

##### 몽고 DB 예시
```sql
db.createCollection("student")

db.student.insert({"id": 2022394, "name": "Nossi", "class": ["Math", "Eng"]})
db.student.insert({"id": 2021921, "name": "Bob", "class": ["Eng"]})

db.student.find() // Fetch all students in JSON format
db.student.findOne({"id": 2022394}) // Find one matching student

db.student.remove({"name": "Nossi"}) // Delete matching students
db.student.drop() // Drops the entire collection
```

### Column Model
- 하나의 키에 여러개의 컬럼 이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회
- 모든 컬럼은 항상 타임 스탬프 값과 함께 저장
- 구글의 빅테이블이 대표적인 예
  - 차후의 컬럼형 Nosql은 빅테이블의 영향을 받음
  - 이러한 이유로 Row key, Column Key, Column Family와 같은 빅테이블 개념이 공통적으로 사용
- 저장의 기본 단위는 컬럼
  - 컬럼은 컬럼 이름, 값, 타임스탬프로 구성
- 이러한 컬럼들의 집합이 로우(Row)
  - Row key는 각 로우를 유일하게 식별하는 값
  - 이러한 로우들의 집합은 키 스페이스(key space)가 됨

- 대부분의 컬럼 모델 NoSQL은 쓰기와 읽기 중에 쓰기가 더 특화되어 있음
- 데이터를 먼저 커밋로그와 메모리에 저장한 후 응답하기 때문에 빠른 응답속도를 제공
- 읽기 연산 대비 쓰기 연산이 많은 서비스나 빠른 시간 안에 대량의 데이터를 입력하고 조회하는 서비스를 구현할 때 가장 좋은 성능을 보임
- 채팅 내용 저장, 실시간 분석을 위한 데이터 저장소 등의 서비스 구현에 적절

# 6. NoSQL vs RDB
- 관계형 데이터베이스는 사전에 엄격하게 정의된 DB 스키마를 요구하는 table 기반의 데이터 구조
- NoSQL은 테이블 형식이 아닌 비정형 데이터를 저장할 수 있도록 지원
- RDB는 엄격한 스키마로 인해 데이터 중복이 없어 데이터 update가 많을 때 유리
- NoSQL의 경우 데이터 중복으로 인해 데이터 업데이트시 모든 컬렉션에서 수정이 필요하기 때문에 Update가 적고 조회가 많을 때 유리

|  | RDB (SQL) | NoSQL |
| --- | --- | --- |
| 데이터 저장 모델 | table | json document / key-value / 그래프 등 |
| 개발 목적 | 데이터 중복 감소 | 애자일 / 확장가능성 / 유연성 |
| 예시 | Oracle, MySQL, PostgreSQL 등 | MongoDB, DynamoDB 등 |
| Schema | 엄격한 데이터 구조 | 유연한 데이터 구조 |
| **장점** | - 명확한 데이터구조 보장 <br> - 데이터 중복 없이 한 번만 저장 (무결성) <br> - 데이터 중복이 없어서 **데이터 update 용이** | - 유연하고 자유로운 데이터 구조 <br> - 새로운 필드 추가 자유로움 <br> - 수평적 확장(scale out) 용이 |
| **단점** | - 시스템이 커지면 Join문이 많은 복잡한 query가 필요 <br> - 수평적 확장이 까다로워 비용이 큰 수직적 확장(Scale up)이 주로 사용됨.  <br> - 데이터 구조가 유연하지 못함 | - 데이터 중복 발생 가능<br> - **중복 데이터가 많기 때문에 데이터 변경 시 모든 컬렉션에서 수정이 필요함**<br> - 명확한 데이터구조 보장 X |
| **사용** | - **데이터 구조가 변경될 여지가 없이 명확**한 경우<br>- **데이터 update가 잦은** 시스템 (중복 데이터가 없으므로 변경에 유리) | - 정확한 데이터 구조가 정해지지 않은 경우<br>- Update가 자주 이루어지지 않는 경우 (조회가 많은 경우)<br>- 데이터 양이 매우 많은 경우 (scale out 가능) |

## 수직적 확장 Scale-up vs 수평적 확장 Scale-Out
- DB와 비교하여 NoSQL의 특징은 ACID, Transaction을 지원하지 않음
- RDB는 ACID와 트랜잭션을 지원하기 위해 수평적 확장이 쉽지 않음
- RDB 같은 경우에는 multiple server로 수평적 확장을 하게 되면 join을 하기 위해 굉장히 복잡한 과정이 필요

- RDB도 수평적 확장이 가능하지만 NoSQL에 비해 훨씬 복잡
- RDB를 수평적 확장하려면 샤딩(sharding)이 필요
  - 샤딩: 데이터가 수평적으로 분할되고 기기의 모음 전반에 걸쳐 분산되는 경우)
- ACID 준수를 유지하면서 RDB를 샤딩하는 것은 매우 어려운 일
