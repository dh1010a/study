# Memory

## 메인 메모리 (Main Memory)
> 메인 메모리는 CPU가 직접 접근할 수 있는 기억 장치
> 
> 프로세스가 실행되려면 프로그램이 메모리에 올라와야 함
- 메모리는 주소가 할당된 일련의 바이트들로 구성됨
- CPU는 레지스터가 지시하는 대로 메모리에 접근하여 다음 수행할 명령어를 가져옴
- 명령어 수행 시 메모리에 필요한 데이터가 없으면 메모리로 해당 데이터를 우선 가져와야 함
- 이 역할을 수행하는것이 MMU

## MMU (Memory Management Unit, 메모리 관리 장치)
> 논리 주소를 물리 주소로 변환해준다. 메모리 보호나 캐시 관리 등 CPU가 메모리에 접근하는 것을 총관리 해주는 하드웨어
- 메모리의 공간이 한정적이기 때문에, 사용자에게 더 많은 메모리를 제공하기 위해 '가상 주소'라는 개념이 등장
- 가상 주소는 프로그램 상에서 사용자가 보는 주소 공간이라고 이해
- 이 가상 주소에서 실제 데이터가 담겨있는 곳에 접근하기 위해 빠른 주소 변환이 필요한데, 이를 MMU가 도와줌
- 즉 MMU의 역할은 아래와 같다고 말할 수 있음
  - MMU가 지원되지 않으면, 물리 주소에 직접 접근해야 하기 때문에 부담 존재
  - MMU는 사용자가 기억 장소를 일일히 할당해야 하는 불편을 없애줌
  - 프로세스의 크기가 실제 메모리의 용량을 초과해도 실행될 수 있게 해줌
 - 또한 메인 메모리 직접 접근은 비효율적이므로, CPU와 메인 메모리 속도를 맞추기 위해 캐시가 존재

### MMU의 메모리 보호
- 프로세스는 독립적인 메모리 공간을 가져야 하고, 자신의 공간에만 접근해야함
- 따라서 한 프로세스의 합법적인 주소 영역을 설정하고, 잘못된 접근이 오면 trap을 발생시키며 보호함
- <img width="601" height="599" alt="image" src="https://github.com/user-attachments/assets/f580e4df-9154-4367-8b55-6a84ae97ebd8" />

#### base와 limit 레지스터를 활용한 메모리 보호 기법
- base 레지스터: 메모리상의 프로세스 시작 주소를 물리 주소로 저장
- limit 레지스터: 프로세스의 사이즈를 저장

이로서 프로세스의 접근 가능한 합법적인 메모리 영역(x)는 아래와 같음
```
base <= x < base+limit
```
- 이 영역 밖에서 접근을 요구하면 trap을 발생시킴
- 안정성을 위해 base와 limit 레지스터는 커널 모드에서만 수정 가능하도록 설계
  - 사용자 모드에서는 직접 변경 X

## 메모리 과할당 (Over Allocating)
> 실제 메모리의 사이즈보다 더 큰 사이즈의 메모리를 프로세스에 할당한 상황
- 페이지 기법과 같은 메모리 관리 기법은 사용자가 눈치채지 못하도록 눈속임을 통해 (가상 메모리를 이용해) 메모리를 할당해줌
- 다음과 같은 상황에서 사용자를 속이고 과할당 한 것을 들킬 수 있음
  1. 프로세스 실행 도중 페이지 폴트 발생
  2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
  3. 메모리의 빈 프레임에 페이지를 올려야 하는데, 모든 메모리가 사용중이라 빈 프레임이 없음
- 과할당을 해결하기 위해서는, 빈 프레임을 확보할 수 있어야 함
  1. 메모리에 올라와 있는 한 프로세스를 종료시켜 빈 프레임을 얻음
  2. 프로세스 하나를 swap out하고, 이 공간을 빈 프레임으로 활용

- swapping 기법을 통해 공간을 바꿔치기 하는 2번과 달리 1번 방법은 사용자에게 페이징 시스템을 들킬 가능성이 높음
- 페이징 기법은 시스템 능률을 높이기 위해 OS 스스로 선택한 일이므로 사용자에게 들키지 않고 처리해야 함
- 따라서 2번 해결법을 통해 페이지 교체가 이루어져야 함

## 페이지 교체
> 메모리 과할당이 발생했을 때, 프로세스 하나를 swap out 해서 빈 프레임을 확보하는 것

1. 프로세스 실행 도중 페이지 부재 발생
2. 페이지 폴트를 발생시킨 페이지 위치를 디스크에서 찾음
3. 메모리에 빈 프레임이 있는지 확인
   - 빈 프레임이 있으면, 해당 프레임을 사용
   - 빈 프레임이 없으면, victim 프레임을 선정해 디스크에 기록하고 페이지 테이블 업데이트
4. 빈 프레임에 페이지 폴트가 발생한 페이지를 올리고 페이지 테이블 업데이트

페이지 교체가 이루어지면 아무 일 없던 것 처럼 프로세스를 계속 수행시켜 주며 사용자가 알지 못하도록 해야함.

이 때 아무일도 일어나지 않은 것 처럼 하려면, 페이지 교체 당시 오버헤드를 최대한 줄여야 함

### 오버헤드를 감소시키는 해결법
- 이처럼 빈 프레임이 없는 상황에서 victim 프레임을 비울 때와 원하는 페이지를 프레임으로 올릴 때 두 번의 디스크 접근이 이루어짐
- 페이지 교체가 많이 이루어지면, 이처럼 입출력 연산이 많이 발생하게 되어 오버헤드 문제가 발생하게 됨

