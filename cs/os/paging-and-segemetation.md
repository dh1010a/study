# Paging & Segmentation

## 목차
1. 메모리 관리 기법을 사용하는 이유
2. Paging이란?
3. Segmetation이란?
4. Memory Pool이란?

# 1. 메모리 관리 기법을 사용하는 이유
- 다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 작업이 필요하기 때문
- 메모리 관리 기법엔 아래 두가지가 있음
  - 연속 메모리 관리, 불연속 메모리 관리
 
### 연속 메모리 관리
- 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당되어야 함
  - 고정 분할 기법: 주 기억장치가 고정된 파티션으로 분할 (내부 단편화 발생)
  - 동적 분할 기법: 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재 (외부 단편화 발생)

### 불연속 메모리 관리
- 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법
- 페이지: 고정 사이즈의 작은 프로세스 조각
- 프레임: 페이지 크기와 같은 주기억장치 메모리 조각
- 단편화: 기억장치의 빈 공간 or 자료가 여러 조각으로 나뉘는 현상
- 세그먼트: 서로 다른 크기를 가진 논리적 블록이 연속적 공간에 배치되는 것

 > 고정 크기 : 페이징, 가변 크기 : 세그멘테이션



# 2. Paging이란?
- 프로세스가 할당받은 메모리 공간을 일정한 **page 단위** 로 나누어, 물리 메모리에서 연속되지 않는 서로 다른 위치에 저장하는 메모리 관리 기법
- 물리적 메모리를 page와 같은 크기의 frame으로 미리 나누어둠
- 주소 바인딩(address binding)을 위해 모든 프로세스가 각각의 주소 변환을 위한 page table을 가짐


<img width="800" height="1138" alt="image" src="https://github.com/user-attachments/assets/845b0ff7-f33f-402b-960d-ac200b059e0e" />

<img width="800" height="1128" alt="image" src="https://github.com/user-attachments/assets/d60b762f-4436-4870-887c-8f27e3bb2ed8" />

## 메모리 단편화 (Memory fragmentation)
- 물리적 메모리 공간이 작은 공간으로 나눠져서 메모리가 충분히 존재함에도 할당이 불가능한 상태
- paging 기법에서는 프로세스의 논리적 주소 공간과 물리적 메모리가 같은 크기의 페이지 단위로 나누어지기 때문에 외부 단편화 문제가 발생하지 않음
- 하지만 프로세스의 주소 공간의 크기가 페이지 크기의 배수라는 보장이 없기 때문에 프로세스의 주소 공간 중 가장 마지막에 위치한 page 에서는 내부 단편화 문제가 발생할 가능성이 있음
- 페이지 단위를 작게 하면 내부 단편화 문제도 해결할 수 있겠지만, 대신 Page Mapping 과정이 많아지기 때문에 오히려 효율이 떨어질 수 있음

#### 내부 단편화
- **메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당** 되어 프로세스에서 사용하는 메모리 공간이 낭비되는 상황
- ex) 1kb가 필요한데 4kb가 할당되었을 경우

#### 외부 단편화
- 메모리가 할당되고 해제되는 작업이 반복될 때 작은 메모리가 중간중간 존재하게 됨
- 이 때 **중간중간 생긴 사용하지 않는 메모리가 많이 존재** 해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황
- ex) 메모리 처음 주소에 8mb짜리 프로세스가 할당 되었고 바로 이어서 16이라고 했을 경우, 8짜리를 종료시키면 메모리 처음 주소부터 8 만큼 공간이 생김.
  - 이게 계속 쌓여서 남은 가장 긴 메모리 공간이 8mb이지만 전체적으로 여유가 있는 경우 외부 단편화가 생겼다고 함



  
> ### 관련 용어
> 1. 논리적 주소 (Logical Address)
>       - 프로세스가 메모리에 적재되기 위한 독자적인 주소 공간인 논리적 주소가 생성됨
>       - 논리적 주소는 각 프로세스마다 독립적으로 할당, 0번지 부터 시작됨
>
>2. 물리적 주소 (Physical Address)
>       - 물리적 주소는 프로세스가 실제로 메모리에 적재되는 위치를 말함
>3. 주소 바인딩 (Address Binding)
>       - CPU가 기계어 명령을 수행하기 위해 process의 논리적 주소가 실제 메모리의 어느 위치에 매핑되는지 확인하는 과정을 주소 바인딩이라고 함

#### 단순 페이징
- 각 프로세스는 프레임들과 같은 길이를 가진 균등 페이지로 나뉨
- 외부 단편화 X
- 소량의 내부 단편화 존재
    
#### 가상 메모리 페이징
- 단순 페이징과 비고해 프로세스 페이지 전부를 로드시킬 필요 X
- 필요한 페이지가 있으면 나중에 자동으로 불러들여짐
- 외부 단편화 X
- 복잡한 메모리 관리로 오버헤드 발생  



# 3. Segmetation이란?
- segmentation이란 프로세스가 할당받은 메모리 공간을 `논리적 의미 단위(segment)`로 나누어, 연속되지 않는 물리 메모리 공간에 할당될 수 있도록 하는 메모리 관리 기법
- 일정한 크기의 단위로 나누어 할당했던 page와는 다르게, segmetation은 의미 단위로 물리 메모리에 할당하는 기법
- 일반적으로 process의 메모리 영역 중 code, stack, heap, data등의 기능(의미) 단위로 segment를 정의하는 경우가 많음
- 주소 바인딩(address binding)을 위해 모든 프로세스가 각각의 주소 변환을 위한 segment table을 가짐

<img width="900" height="1148" alt="image" src="https://github.com/user-attachments/assets/db004148-50ae-4463-beab-815f684b8fd2" />

- segment는 그 크기가 균일하지 않아 논리적 주소가 <segment 번호, offset>으로 표현
- 이 때 offset의 값이 table의 limit 값보다 크면 해당 segment를 넘어가므로 segmentation fault 오류가 발생

### 메모리 단편화(Memory fragmentation) 문제
- segmentation 기법에서 segment의 크기 만큼 메모리를 할당하므로 내부 단편화 문제가 발생하지 않음
- 하지만 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되면, 외부 단편화 문제가 발생할 가능성이 있음

> Paging은 내부 단편화 문제가 발생할 수 있는데에 반해, Segmentation은 외부 단편화 문제가 발생할 수 있음

## Paged Segmentation 기법
- Segmentation을 기본으로 하되 이를 다시 동일한 크기의 page로 나누어 물리 메모리에 할당하는 기법
- 즉, 프로그램을 의미 단위의 Segment로 나누고 개별 Segment의 크기를 page의 배수가 되도록 하는 기법
- segmentation 기법에서 발생하는 외부 단편화 문제를 해결하고, 동시에 segment 단위로 process 간의 공유나 process 내의 접근 권한 보호가 이루어지도록 해서 paging 기법의 단점을 해결

#### 단순 세그먼테이션
- 각 프로세스는 여러 세그먼트들로 나뉨
- 내부 단편화 X, 메모리 사용 효율 개선, 동적 분할을 통한 오버헤드 감소
- 외부 단편화 존재


#### 가상 메모리 세그먼테이션
- 필요하지 않은 세그먼트들은 로드 X
- 필요한 세그먼트가 있을 때 나중에 자동으로 불러들어짐
- 내부 단편화 X
- 복잡한 메모리 관리로 오버헤드 발생

# 4. Memory Pool이란?
- 동적 할당과 비슷한 개념이지만, 필요한 메모리 공간을 필요한 크기, 개수만큼 사용자가 직접 지정하여 미리 할당받아놓고 필요할 때마다 사용하고 반납하는 기법
- 메모리 풀 없이 동적할당과 해제를 반복하면 메모리의 랜덤한(실제로는 알고리즘에 의한) 위치에 할당과 해제가 반복되면서 단편화를 일으킬 수 있지만, 미리 공간을 할당해놓고 가져다 쓰고 반납하기 때문에 할당과 해제로 인한 외부 단편화가 발생하지 않음
- 또한 필요한 크기 만큼 할당해 놓기 때문에 내부 단편화 문제가 발생하지 않음
- 메모리 단편화로 인한 메모리 낭비량보다, 메모리 풀을 만들었지만 쓰지 않았을 때 그 할당된 메모리의 낭비량이 더 커질 경우는 오히려 비효율적
- 즉, 메모리 풀은 메모리의 할당과 해제가 잦은 경우 사용하면 효율적이지만 미리 할당해놓고 사용하지 않는 순간에도 계속 할당되어 있기 때문에 메모리 누수가 있을 수 있음

## 구현 방법
- 큰 메모리 블록(페이지)을 힙으로 부터 할당
- 할당 받은 페이지를 각 객체의 크기의 블록으로 나눔
- 각 객체를 위한 블록을 순차적으로 링크
- 이 때 현 시점에서 할당할 블록을 특정 포인터가 가리키게 함
- 메모리 요청이 생기면 현재 헤더 포인터가 가리키는 블록을 돌려준다
- 할당이 일어난 후 헤더 포인터는 할당 직전에 가리키던 블록이 가리키던 블록을 가리킨다
- 사용되던 메모리가 해제되어 메모리 풀로 돌아올 경우 헤더 포인터는 그 블록을 가리키고 방금 전까지 헤더 포인터가 가리키던 블록을 돌아온 블록의 다음 포인터가 가리키게 한다.

## Ref
- [기출로 대비하는 개발자 전공면접](https://www.inflearn.com/course/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%A0%84%EA%B3%B5%EB%A9%B4%EC%A0%91-cs-%EC%99%84%EC%A0%84%EC%A0%95%EB%B3%B5/dashboard)

