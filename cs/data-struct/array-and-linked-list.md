## Array And Linked List

### Array
- Array는 연관된 data를 **메모리상에 연속적이며 순차적으로 미리 할당된 크기**만큼 저장하는 자료구조
- 논리적 저장 순서와 물리적 저장 순서가 일치

#### Array의 특징
- 고정된 저장 공간 (fixed-size)
- 순차적인 데이터 저장 (Order)

#### 장점
Array의 장점은 lookup과 append가 빠르다는것이다. 따라서 조회를 자주 해야되는 작업에서는 Array 자료구조를 많이 사용한다.

또한 논리적 저장순서와 물리적 저장 순서가 일치하기에, `인덱스(index)` 기반으로 해당 원소에 접근할 수 있다. 그러기 때문에 찾고자 하는 원소의 인덱스 값을 안다면 O(1)의 시간복잡도로 접근할 수 있다.

#### 단점
Array의 단점은 fixed-size 특성상 선언시에 Array의 크기를 미리 정해야 된다는 것이다. 이는 메모리 낭비나 추가적인 Overhead를 발생시킬 수 있다. 또한 삭제 또는 삽입의 과정에서는 해당 원소에 접근하여 작업을 완료한뒤 (O(1)), 또 한가지의 작업을 추가적으로 해줘야함.

만약 배열의 원소 중 어느 원소를 삭제했다고 했을 때, 배열의 연속적인 특징이 깨지게 된다. 즉 빈공간이 생긴다. 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들을 `shift`해줘야하는 비용이 발생하고, 이 경우 시간복잡도는 O(n)이 된다. 삽입도 동일하다.



#### 시간복잡도
|  | Array |
| --- | --- |
| access | $O(1)$ |
| append | $O(1)$ |
| 마지막 원소 delete | $O(1)$ |
| insertion | $O(n)$ |
| deletion | $O(n)$ |
| search | $O(n)$ |

> Q. 미리 예상한 것보다 더 많은 수의 데이터를 저장하느라 배열의 크기를 넘어서게 됐다면 어떻게 해결할 수 있을까?
>
> A. 기존의 크기보다 더 큰 배열을 선언하여 데이터를 옮겨 할당. 모든 데이터를 옮겼다면 기존 배열은 메모리에서 삭제한다. 이런식으로 동적으로 배열의 크기를 조절하는 자료구조를 Dynamic Array라고 함
>
> A. 또 다른 방법으론, 사이즈를 예측하기 쉽지 않다면 배열 대신 Linked List를 사용함으로써 데이터가 추가될 때마다 메모리 공간을 할당받는 방식을 사용

## Linked List
- Linked List는 Node라는 구조체로 이루어져 있는데, Node는 데이터 값과 다음 노드의 주소를 저장함
- 연결 리스트는 물리적인 메모리상에서는 비연속적으로 저장
- 그러나 연결 리스트를 구성하는 각 노드가 다음 노드의 주소를 가리킴으로서 논리적인 연속성을 가진 자료구조

### 장점
- 주소를 가리키고 있기 때문에 그것만 다른 값으로 바꿔주면 삭제와 삽입을 O(1)으로 해결할 수 있음

## 단점
- 
