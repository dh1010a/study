## Array And Linked List

### Array
- Array는 연관된 data를 **메모리상에 연속적이며 순차적으로 미리 할당된 크기**만큼 저장하는 자료구조
- 논리적 저장 순서와 물리적 저장 순서가 일치

#### Array의 특징
- 고정된 저장 공간 (fixed-size)
- 순차적인 데이터 저장 (Order)

#### 장점
Array의 장점은 lookup과 append가 빠르다는것이다. 따라서 조회를 자주 해야되는 작업에서는 Array 자료구조를 많이 사용한다.

또한 논리적 저장순서와 물리적 저장 순서가 일치하기에, `인덱스(index)` 기반으로 해당 원소에 접근할 수 있다. 그러기 때문에 찾고자 하는 원소의 인덱스 값을 안다면 O(1)의 시간복잡도로 접근할 수 있다.

#### 단점
Array의 단점은 fixed-size 특성상 선언시에 Array의 크기를 미리 정해야 된다는 것이다. 이는 메모리 낭비나 추가적인 Overhead를 발생시킬 수 있다. 또한 삭제 또는 삽입의 과정에서는 해당 원소에 접근하여 작업을 완료한뒤 (O(1)), 또 한가지의 작업을 추가적으로 해줘야함.

만약 배열의 원소 중 어느 원소를 삭제했다고 했을 때, 배열의 연속적인 특징이 깨지게 된다. 즉 빈공간이 생긴다. 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들을 `shift`해줘야하는 비용이 발생하고, 이 경우 시간복잡도는 O(n)이 된다. 삽입도 동일하다.



#### 시간복잡도
|  | Array |
| --- | --- |
| access | $O(1)$ |
| append | $O(1)$ |
| 마지막 원소 delete | $O(1)$ |
| insertion | $O(n)$ |
| deletion | $O(n)$ |
| search | $O(n)$ |

> Q. 미리 예상한 것보다 더 많은 수의 데이터를 저장하느라 배열의 크기를 넘어서게 됐다면 어떻게 해결할 수 있을까?
>
> A. 기존의 크기보다 더 큰 배열을 선언하여 데이터를 옮겨 할당. 모든 데이터를 옮겼다면 기존 배열은 메모리에서 삭제한다. 이런식으로 동적으로 배열의 크기를 조절하는 자료구조를 Dynamic Array라고 함
>
> A. 또 다른 방법으론, 사이즈를 예측하기 쉽지 않다면 배열 대신 Linked List를 사용함으로써 데이터가 추가될 때마다 메모리 공간을 할당받는 방식을 사용

## Linked List
- Linked List는 Node라는 구조체로 이루어져 있는데, Node는 데이터 값과 다음 노드의 주소를 저장함
- 연결 리스트는 물리적인 메모리상에서는 비연속적으로 저장
- 그러나 연결 리스트를 구성하는 각 노드가 다음 노드의 주소를 가리킴으로서 논리적인 연속성을 가진 자료구조
- 트리의 근간이 되는 자료 구조

### 장점
- 주소를 가리키고 있기 때문에 그것만 다른 값으로 바꿔주면 삭제와 삽입을 O(1)으로 해결할 수 있음
- 메모리 사용이 자유로움 (고정되지 않음)

### 단점
- 원하는 위치에 삽입 하고자 하면 원하는 위치를 search하는 과정에 있어서 처음부터 전부 스캔해봐야 함. 물리적 연속성이 없기 때문
- 그래서 어떤 원소를 삽입하거나 삭제할때 그 위치나 원소를 찾기 위해 O(n)의 시간이 추가적으로 소요됨
- 다음 주소를 추가로 저장해야 하기 때문에 데이터 하나당 차지하는 메모리가 더 커짐


### 시간복잡도

|  | Linked list |
| --- | --- |
| access | $O(n)$ |
| search | $O(n)$ |
| insertion | $O(1)$ |
| deletion | $O(1)$ |


## Array와 Linked list의 비교
Array는 메모리 상에서 연속적으로 데이터를 저장하는 자료구조이다. Linked List는 메모리상에서는 연속적이지 않지만, 각각의 원소가 다음 원소의 메모리 주소값을 저장해 놓음으로써 논리적 연속성을 유지한다.

그래서 각 operation의 시간 복잡도가 다르다. 
- 데이터 조회
  - 배열: O(1), 연결리스트 O(n)
- 삽입/삭제
  - 배열: O(n), 연결리스트 O(1)
 
### memory
배열의 주된 장점은 데이터 접근과 append가 빠르다는 것. 하지만 메모리 낭비라는 단점이 있다. 배열은 선언시에 fixed size를 설정하여 메모리 할당을 한다. 즉, 데이터가 저장되어 있지 않더라도 메모리를 차지하고 있기 때문에 메모리 낭비가 발생.

반면 연결 리스트는 runtime 중에도 사이즈를 늘리고 줄일 수 있음. 그래서 initial size를 고민할 필요 없고, 필요한 만큼 메모리 할당을 하며 메모리 낭비가 없다.

### memory allocation 시점과 할당받는 영역
- 배열은 컴파일 단계에서 메모리 할당이 일어난다. 이를 Static Memory Allocation이라고 함. 이 경우 Stack Memory 영역에 할당됨
- 연결 리스트의 경우 런타임 단계에서 새로운 노드가 추가될 때 마다 메모리 할당이 일어난다. 이를 Dynamic Memory Allocation이라고 부른다. Heap 메모리 영역에 할당됨.

<img width="1920" height="1080" alt="image" src="https://github.com/user-attachments/assets/eb75fd3c-7ba9-47f3-a607-27e0b2dd0661" />


> Q. 어느 상황에 연결 리스트를 쓰는게 배열 보다 나은가?
>
> - O(1)으로 삽입/삭제를 자주 해야할 때
> - 얼마만큼의 데이터가 들어올지 예측할 수 없을때
> - 조회 작업이 별로 없을 때
>
> Q. 어느 상황에 Array를 쓰는게 연결 리스트 보다 나은가?
>
> - 조회 작업을 자주 해야될 떄
> - 배열 선언 당시 데이터의 갯수를 미리 알 때
> - 데이터를 반복문을 통해 빠르게 순회할 때
> - 메모리를 적게 쓰는게 중요한 상황일떄. 연결 리스트보다는 배열이 메모리를 적게 차지하기 때문에 미리 들어올 데이터의 양을 알고 있다면 배열이 더 메모리를 효율적으로 사용함.

## Ref
- [기출로 대비하는 개발자 전공면접](https://www.inflearn.com/course/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%A0%84%EA%B3%B5%EB%A9%B4%EC%A0%91-cs-%EC%99%84%EC%A0%84%EC%A0%95%EB%B3%B5/dashboard)
- [Interview_Question_for_Beginner](https://github.com/jbee37142/Interview_Question_for_Beginner/blob/main/DataStructure/README.md#array-vs-linked-list)
