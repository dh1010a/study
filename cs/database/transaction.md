# Transaction

## 목차
1. 트랜잭션
2. 트랜잭션의 특성
3. 트랜잭션의 상태
4. 트랜잭션 관리를 위한 DBMS의 전략
5. REDO와 UNDO

# 1. 트랜잭션
- 트랜잭션이란 작업의 완전성을 보장해주는 것
- 논리적인 작업 셋을 모두 완벽하게 처리하거나 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어 주는 기능
- 사용자 입장에서는 작업의 논리적 단위로 이해할 수 있음
- 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위
- 데이터베이스에서 트랜잭션이 필요한 이유는 데이터를 다룰 때 장애가 일어는 경우, 트랜잭션은 데이터를 복구하는 작업의 단위가 되기 때문
- 데이터베이스는 여러 작업이 동시에 같은 데이터를 다룰 떄가 있는데, 이 작업을 통해 서로 분리하고 이를 통해 오류가 발생하지 않게 함
- DBMS는 트랝개션이 이러한 규칙을 유지하도록 지원

```sql
START TRANSACTION

// (1) A 계좌 잔액 가져옴 A = 1000
// (2) B 계좌 잔액 가져옴 B = 1000

// (3) A 출금  A = A - 100
// (4) B 입금  B = B + 100
UPDATE Customer SET balance = balance - 100 WHERE name='A';
UPDATE Customer SET balance = balance + 100 WHERE name='B';

//COMMIT

// (5) A 계좌 잔액 저장 A = 900
// (6) B 계좌 잔액 저장 B = 1100

COMMIT
```

## 트랜잭션과 락
- 잠금(Lock)과 트랜잭션은 서로 비슷한 개념 같지만 잠금은 동시성을 위한 기능이고 트랜잭션은 데이터의 정합성을 보장하기 위한 기능
- 잠금은 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할 수 있게 해주는 역할
  - 여기서 자원이란 레코드나 테이블을 말함
- 이와는 조금 다르게 트랜잭션은 꼭 여러개의 변경 작업을 수행하는 쿼리가 조합되었을때만 의미 있는 개념은 아님
- 트랜잭션은 하나의 논리적인 작업 셋 중 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장하는 것
  - 예를 들어 HW 에러 또는 SW에러와 같은 문제로 인해 작업 실패시, 특별한 대책이 필요한데 이러한 문제를 해결하는 것

## 트랜잭션의 특성
- 트랜잭션은 데이터베이스의 무결성을 유지하기 위해 원자성, 일관성, 고립성, 지속성의 성질을 가짐

### Atomic(원자성)
- 트랜잭션에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 않아야 함 (All or Nothing)

### Consistency(일관성)
- 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미
  - 예를 들면 송금 전후 모두 잔액의 데이터 타입은 Integer이여야 한다는 것 등이 있음

### Isolation(고립성)
- 여러 트랜잭션은 동시에 수행
- 이때 각 트랜잭션은 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하여 독립적으로 작업을 수행
- 동시에 수행되는 트랜잭션이 동일한 데이터를 가지고 충돌하지 않도록 제어해주어야 함
  - 이를 동시성 제어(Concurrency Control)라고 함

 ### Durability(지속성)
 - 성공적으로 수행된 트랜잭션은 데이터베이스에 영원히 반영되어야 함
 - 트랜잭션이 완료되어 저장이 된 데이터베이스는 저장 후에 생기는 정전, 장애, 오류 등에 영향을 받지 않아야 함

![image](https://github.com/user-attachments/assets/938c0072-fcb5-4d89-ab5e-78b3785ba671)

# 3. 트랜잭션의 상태
![image](https://github.com/user-attachments/assets/b96a7f4c-39a9-44d7-9820-fbfd944a8d1b)

#### Active
- 트랜잭션의 활동 상태. 트랜잭션이 실행중이며 동작중인 상태를 말한다

#### Failed
- 트랜잭션의 실패 상태. 트랜잭션이 더이상 정상적으로 진행 할 수 없느 상태를 말한다

#### Partially Committed
- 트랜잭션의 Commit 명령이 

#### Committed
- 트랜잭션이 정상적으로 완료된 완료 상태

#### Aborted
- 트랜잭션이 취소 상태
- 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태를 말한다.

#### Partially Committed 와 Committed의 차이점
- Commit요청이 들어오면 상태는 Partially Commited 상태가 된다. 이후 커밋을 문제없이 수행할 수 있으면 Commited 상태로 전이
- 만약 오류가 발생하면 Failed 상태가 됨
- 즉, Partially Committed는 커밋 요청이 들어왔을 때를 말하며, Committed는 Commit을 정상적으로 완료한 상태를 말함

### Commit과 Rollback
- 데이터베이스는 커밋과 롤백 명령어를 통해 데이터 무결성을 보장
- 커밋이란 트랜잭션 작업을 완료했다고 확정하는 명렁어
  - 트랜잭션 작업 내용을 실제 디비에 저장하고, 디비가 변경
- 롤백은 작업 중 문제 발생시 트랜잭션 처리 과정에서 발생한 변경사항을 취소하고 이전 커밋의 상태로 되돌림

## 트랜잭션 사용시 주의점
- 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋다. 즉, 트랜잭션의 범위를 최소화 하라는 의미
- 일반적으로 데이터베이스 커넥션은 갯수가 제한적
- 근데 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 사용 가능한 여유 커넥션의 갯수는 줄어들게 됨
- 그러다 어느 순간 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야하는 상황이 발생할 수 있음

## 동시성 제어 (Concurrency Control)
- 여러개의 트랜잭션이 한 개의 데이터를 동시에 갱신(Update) 할 때 어느 한 트랜잭션의 갱신이 무효화 될 수 있음
  - 이를 갱신 손실이라고 함
- 동시성 제어를 통해 갱신손실을 미리 막을 수 있음
- 즉, 트랜잭션이 동시에 수행될 때 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능을 동시성 제어라고 함
- 갱신손실 문제를 해결하기 위한 방법 중 하나로 데이터를 수정중에 있는 트랜잭션은 해당 데이터를 Lock으로 잠금장치 하여 다른 트랜잭션의 접근을 막을 수 있음
- 락이 걸린 데이터는 Unlock이 될 때 까지 다른 트랜잭션들은 접근하지 못하고 기다려야 함

 ![image](https://github.com/user-attachments/assets/12c7e332-2b4f-4d13-9194-7280905d4d24)
 
 ![image](https://github.com/user-attachments/assets/fe0c400e-c753-4caa-ae45-620b3128300c)

# 4. 트랜잭션 관리를 위한 DBMS의 전략
- 이해를 위해 알아야 할 선행 개념
  - DBMS의 구조
  - Buffer 관리 정책

### DBMS의 구조
- 크게 2가지
  - Query Processor (질의 처리기)
  - Storage System (저장 시스템)
- 데이터 저장 단위: 디스크에 데이터를 고정 길이의 Page 단위로 읽고 씀
- 저장 공간: 저장 위치: 대부분의 데이터는 **비휘발성 저장장치(disk)**에 저장되며, 필요한 일부 페이지는 **메인 메모리(Buffer Pool)**에 적재됩니다.
![image](https://github.com/user-attachments/assets/c571dc8f-4ff8-4e30-9832-5b7399364119)
 
### Buffer Manager
- DBMS의 저장 시스템에 속하는 모듈 중 하나
- **메인 메모리(Buffer Pool)**에서 관리 중인 페이지들을 관리
- 언제 어떤 Page를 디스크로 쓰기(Flush) 할지, 또는 버퍼에서 제거(Eviction) 할지 결정하는 버퍼 교체 정책을 수행함
- 이 Buffer Manager의 정책에 따라 **트랜잭션 복구 방식(UNDO / REDO)**이 달라지며, 트랜잭션 무결성에 중대한 영향을 미침
- 트랜잭션 관리에 매우 중요한 결정을 가져옴
- Storage System 내부의 핵심 모듈 중 하나


# 5. REDO와 UNDO
<img width="650" alt="image" src="https://github.com/user-attachments/assets/ae666ffb-1c78-4d87-ad00-9af8c0382088" />

- REDO는 디스크에 반영되지 않은 커밋된 데이터를 다시 적용 (-> 최신 상태로 복구)
- 디스크에 반영된 커밋되지 않은 데이터를 되돌림 (-> 이전 상태로 롤백)
- 읽기 일관성 보장을 위해 UNDO 필요
- 장애/종료 시점에 따라 REDO 또는 UNDO 수행

## UNDO
- 트랜잭션 실행 도중 변경된 Page들은 메모리 상의 Buffer Pool에 존재
- 이 Page들은 Buffer 교체 알고리즘에 의해 트랜잭션과 무관하게 디스크에 기록될 수 있음
- 커밋되지 않은 트랜잭션의 변경 사항이 디스크에 기록될 수 있으므로, 이를 원상 복구할 수 있어야 함 -> 이 작업이 UNDO
- 처리 방식
  - 트랜잭션 수행 시 변경 전의 값을 UNDO 로그에 기록
  - 장애 발생 시, 로그를 참조하여 변경 전 상태로 되돌림

### UNDO 관련 버퍼 관리 정책
- 수정된 페이지를 디스크에 쓰는 시점으로 분류

|정책	|설명	|UNDO 필요 여부|
| --- | --- | --- |
|Steal	|- 수정된 페이지를 트랜잭션 종료 전에도 디스크에 기록할 수 있음 |	필요함|
|No-Steal (¬steal)|	수정된 페이지를 트랜잭션 종료(EOT) 전까지는 디스크에 기록하지 않음|	 필요 없음|

- steal: 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책
  - 대부분 DBMS가 채택하는 버퍼 관리 정책
  - UNDO logging과 복구를 필요로 함

- no-steal : 수정된 페이지들을 EOT(End Of Transaction)까지는 버퍼에 유지하는 정책
  - UNDO작업이 필요하지 않지만, 매우 큰 메모리 버퍼가 필요

## REDO
- 커밋은 되었지만, 디스크에 반영되지 않은 트랜잭션의 변경 내용을 다시 적용하는 작업
- 시스템 장애로 인해 커밋된 변경 사항이 손실될 수 있으므로 이를 복구하여 지속성(Durability) 보장

### REDO 관련 버퍼 관리 정책
- 트랜잭션이 종료되는 시점에 해당 트랜잭션이 수정한 페이지를 디스크에 쓸 것인가 아닌가로 기준

|정책	|설명	|REDO 필요 여부|
| --- | --- | --- |
|Force	|트랜잭션 커밋 시, 수정된 모든 페이지를 디스크에 즉시 반영|	 필요 없음|
|No-Force (¬force)	|커밋 시에도 디스크에 반영하지 않고, 나중에 기록| 필요함|

- FORCE: 수정했던 모든 페이지를 트랜잭션 커밋 시점에 디스크 반영
  - 트랜잭션이 커밋 되었을 때 수정된 페이지들이 디스크 상에 반영되므로 REDO 필요 없음
- No-FORCE: 커밋 시점에 반영하지 않는 정책
  - 트랜잭션이 디스크 상의 DB에 반영되지 않을 수 있기에 REDO 복구 필요
  - 대부분의 DBMS가 채택하는 정책
