# Operation System

## 목차
1. 프로세스와 스레드 개념
2. 멀티 프로세스
3. 멀티 스레드
4. 프로세스와 스레드의 비교
5. 멀티 프로세스와 멀티 스레드의 비교
6. 교착 상태 (Deadlock)


# 1. 프로세스와 스레드 개념
- 프로그램 : 컴퓨터가 실행할 수 있는 명령어들의 집합
- 프로세스 : 컴퓨터에서 실제로 실행중인 프로그램을 의미
  - 각각의 프로세스는 독립된 메모리 공간을 할당받음
  - 명령어들과 데이터를 가짐
- CPU : 명렁어를 실행하는 연산 장치
- 메인 메모리 : 프로세스가 CPU에 실행되기 위해 대기하는 곳
  - 프로세스의 명령어들이나 실행중인 데이터들이 있기도 함
- I/O : 파일을 읽고 쓰거나 네트워크의 어딘가와 데이터를 주고 받는것, 입출력 장치와 데이터를 주거나 받는 것

## 프로세스
- 실행파일(program)이 memory에 적재되어 CPU를 할당받아 실행되는 것을 process라고 함
- 프로세스(process)란 실행중인 프로그램(program in execution)을 뜻함
- 즉, 실행파일 형태로 존재하던 program이 memory에 적재되어 CPU에 의해 실행(연산)되는 것을 process라고 함

![image](https://github.com/user-attachments/assets/bb60c1b0-e52c-48de-b215-26b1f80621eb)

### 단일 프로세스 시스템
- 초창기의 시스템은 한번에 하나의 프로그램만 실행 됨
- CPU 사용률이 좋지 않음
  - p1이라는 시스템이 실행 -> I/O 작업을 만나 처리 중이면 CPU는 놀고 있음 -> 사용률이 좋지 않음

#### 해결책
- 여러개의 프로그램을 메모리에 올려놓고, 동시에 실행
- 실행중인 프로세스에 I/O 작업을 하게 되면 다른 프로세스가 CPU에서 실행

### 멀티 프로그래밍
- 이런 종류의 시스템을 멀티 프로그래밍이라고 함
- 멀티 프로그래밍은 CPU의 사용률을 극대화 시키는데 목적이 있음
- 하지만 CPU 사용시간이 길어지면 다른 프로세스는 대기를 해야한다는 단점이 존재

#### 해결책
- 프로세스는 한번 CPU를 사용할 때, 아주 짧은 시간(quantum)만 CPU에서 실행되도록 하자

### 멀티 태스킹
- p1과 p2를 밀리 세컨드 단위의 아주 짧은 타임 슬랏 안에서 번갈아 가며 수행할 수 있도록 하는 것
- 프로세스의 응답시간을 최소화 시키는데 목적
- 어떤 프로그램이 실행 됐을때 즉각 반응을 받을 수 있도록 함으로서 동시에 여러 프로그램이 실행될 수 있는것 같은 느낌을 받음

#### 아쉬운 점
- 하나의 프로세스가 동시에 여러 작업을 수행하지는 못함
- 프로세스의 컨텍스트 스위칭은 무거운 작업
  - cpu에서 실행되기 위해 한 프로세스에서 다른 프로세스로 교체되는 것을 컨텍스트 스위칭이라고 함
- 프로세스 끼리는 데이터 공유가 까다로움
- 듀얼 코어가 등장했는데 잘 쓰고 싶음

 ## 스레드 (운영 체제 레벨의 스레드, 유저 레벨의 스레드 X)
 - 그렇게 등장한 것이 스레드
 - 프로세스는 한 개 이상의 스레드를 가질 수 있음
 - 한 프로세스를 동시에 실행하려면 여러개의 스레드가 필요
 - CPU에서 실행되는 단위 (기존에는 프로세스 였음) (unit of execution)
 - 같은 프로세스의 스레드들끼리 컨텍스트 스위칭은 가볍다
 - 스레드들은 자신들이 속한 프로세스의 메모리 영역을 공유

<img width="1430" alt="image" src="https://github.com/user-attachments/assets/8ef38d84-7dd5-4753-929c-9313941c9b5c" />

- 힙 영역을 공유
- 스택과 코드 영역의 프로그램 카운터는 스레드가 고유하게 사용
  - 프로그램 카운터는 다음번에 실행되야할 명령어가 있는 주소를 가리킴
  - 엄밀히 말하면, 코드 영역의 Program Counter는 고유하지만 나머지는 공유!

#### Memory에 적재
- memory는 CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억 장치
- 프로그램이 실행되려면 해당 내용이 메모리에 적재된 상태여만 함
- 프로세스에 할당되는 메모리 공간은 Code/Data/Stack,Heap 4개의 영역으로 이루어져 있으며, 각 프로세스마다 독립적으로 할당 받음

![image](https://github.com/user-attachments/assets/0fc3e56c-dc77-4c0c-b2cb-da6993ce3db6)

| 영역 | 설명 |
| --- | --- |
| Code 영역 | 실행한 프로그램의 코드가 저장되는 메모리 영역 |
| Data 영역 | 프로그램의 전역 변수와 static 변수가 저장되는 메모리 영역 |
| Heap 영역 | 프로그래머가 직접 공간을 할당(malloc)/해제(free) 하는 메모리 영역 |
| Stack 영역 | 함수 호출 시 생성되는 지역 변수와 매개 변수가 저장되는 임시 메모리 영역 |

### CPU의 연산과 PC 레지스터
- 프로그램의 코드를 토대로 CPU가 실제로 연산을 해야만 프로그램이 실행된 것
- 어떤 코드를 읽어야 하는지는 CPU 내부의 PC(Program Counter) register에 저장
- PC register에는 다음에 실행될 코드(명령어, instruction)의 주소값이 저장
- memeory에 적재된 프로세스 코드 영역의 명령어 중 다음번 연산에서 읽어야할 명령어의 주소값을 PC 레지스터가 순차적으로 가리킴
- 해당 명령어를 읽어와서 CPU가 연산을 하게 되면 프로세스가 실행 됨
- multi process 시스템에서는 process1이 진행되고 있을 때는 process1의 code 영역을 PC register가 가리키다가, process2가 진행되면 process2의 code 영역을 가리킴
- register가 가리키는 곳에 따라 process를 변경해 가면서 명령어를 읽어들이고 연산
 
### 멀티 스레딩
- 하나의 프로세스가 동시에 여러 작업(스레드를 통해)을 실행하는데에 목적이 있음
- 멀티 태스킹의 개념도 확장
  - 여러 프로세스와 여러 스레드가 아주 짧게 쪼개진 CPU 시간을 나눠 갖는것

 ### 멀티 프로세싱
 - 두개 이상의 프로세서나 코어를 활용하는 시스템

## 예제 
- 싱글 코어 CPU에 싱글 스레드 프로세스 두개
  - 멀티 태스킹 O, 멀티 스레딩 X, 멀티 프로세싱 X
- 싱클 코어 CPU에 듀얼 스레드 프로세스 한개
  - 멀티 태스킹 O, 멀티 스레딩 O, 멀티 프로세싱 X  
- 듀얼 코어 CPU에 싱글 스레드 프로세스 두개
  - 멀티 태스킹 X, 멀티 스레딩 X, 멀티 프로세싱 O (각 프로세스는 코어 한개에서 독립 실행)
- 듀얼 코어 CPU에 듀얼 스레드 프로세스 한개
  - 멀티 태스킹 X, 멀티 스레딩 O, 멀티 프로세싱 O (각 스레드는 코어 한개에서 독립 실행, 경합 X)
- 듀얼 코어 CPU에 듀얼 스레드 프로세스 두개
  - 멀티 태스킹 O, 멀티 스레딩 O, 멀티 프로세싱 O

# 2. 멀티 프로세스
- 멀티 프로세스는 2개 이상의 프로세스가 동시에 실행되는 것, 이 때 process들은 CPU와 메모리를 공유
- 동시에라는 말은 동시성(Concurrency), 병렬성(parallelism) 두 가지를 의미
- memory의 경우에는 여러 process들이 각자의 memory영역을 차지하여 동시에 적재
- 하나의 CPU는 매 순간 하나의 process만 연산할 수 있다
- 하지만 CPU의 처리 속도가 워낙 빨라서 수 ms 이내의 짧은 시간동안 여러 process들이 CPU에서 번갈아 실행
- 사용자 입장에서는 여러 프로그램이 동시에 실행되는 것처럼 보임
- 이처럼 CPU의 작업시간을 여러 process들이 조금씩 나누어 쓰는 시스템을 시분할 시스템(time sharing system)이라고 함

## 동시성(Concurrency) vs 병렬성(Parallelism)
- 동시성은 CPU 코어가 한개일때, 여러 프로세스를 짧은 시간동안 번갈아 가며 연산을 하게 되는 시분할 시스템(time sharing system)으로 실행 되는 것
- 병렬성은 CPU 코어가 여러개일때, 각각의 코어가 각각의 프로세스를 연산함으로써 프로세스가 동시에 실행되는 것
  
| 동시성 | 병렬성 |
| --- | --- |
| Single core | Multi core |
| 동시에 실행되는 것 같아 보인다. | 실제로 동시에 여러 작업이 처리 된다. |

<img width="603" alt="image" src="https://github.com/user-attachments/assets/ac71644d-9e69-44a2-b85b-a1af8c80ef0f" />

### 메모리 관리
- 여러 process가 동시에 memory에 적재된 경우, 서로 다른 process의 영역을 침범하지 않도록 각 process가 자신의 memory영역에만 접근하도록 운영체제가 관리
- base register, limit register를 통해 각 process를 처리할 때에는 정해진 메모리 구간 외에는 접근할 수 없도록 막는다.
![image](https://github.com/user-attachments/assets/6c2d394f-94b1-40d2-b9e8-15f1e6ac1173)


## Context
- 시분할 시스템에서는 한 프로세스가 매우 짧은 시간동안 CPU를 점유하여 일정 부분의 명령을 수행하고, 다른 프로세스에 넘김
- 그 후 차례가 되면 다시 CPU를 점유하여 명령을 수행. 따라서 이전에 어디까지 명령을 수행했고, register에는 어떤 값이 저장되어 있었는지에 대한 정보가 필요
- 프로세스가 현재 어떤 상태로 수행되고 있는지에 대한 총체적인 정보가 바로 Context
- context 정보들은 PCB(Process Control Block)에 저장

### PCB(Process Control Block)
- PCB는 운영 체제가 프로세스를 표현한 자료구조
- PCB에는 프로세스의 중요한 정보가 포함되어 있어 일반 사용자가 접근하지 못하도록 보호된 메모리 영역 안에 저장
- 일부 운영 체제에서 PCB는 커널 스택에 위치. 이 메모리 영역은 보호를 받으면서도 비교적 접근 용이

| PCB |  |
| --- | --- |
| Process State | new, running, waiting, halted 등의 state가 있다. |
| Process Number | 해당 process의 number |
| Program counter(PC) | 해당 process가 다음에 실행할 명령어의 주소를 가리킨다 |
| Registers | 컴퓨터 구조에 따라 다양한 수와 유형을 가진 register 값들 |
| Memory limits | base register, limit register, page table 또는 segment table 등 |
| ... |  |

![image](https://github.com/user-attachments/assets/a345e93c-e101-4635-a322-6c4d9c901e38)

#### 프로세스 상태

프로세스는 **실행**(running), **준비**(ready), **봉쇄**(wait, sleep, blocked) 세 가지 상태로 구분

| 상태 | 설명 |
| --- | --- |
| 실행 | 프로세스가 CPU를 점유하고 명령을 수행중인 상태 |
| 준비 | CPU만 할당받으면 즉시 명령을 수행할 수 있도록 준비된 상태 |
| 봉쇄 | CPU를 할당받아도 명령을 실행할 수 없는 상태 - ex. I/O 작업을 기다리는 경우 등 |


> #### 레지스터란?
>
> - 레지스터(register) 는 CPU 내부에 있는 초고속 임시 기억장소. RAM보다 훨씬 빠르고, CPU가 직접 연산할 수 있는 유일한 공간
>   - IR (Instruction Register) :	지금 실행 중인 명령어 저장
>   - ACC (Accumulator) :	계산 결과를 저장
>   - SP (Stack Pointer) :	현재 스택의 top 위치 가리킴
>   - GP, AX, BX, CX, DX 등 :	범용 레지스터 (일반 값 저장)
>   - FLAGS :	조건 플래그 (예: 결과가 0인지 등)


### Context Switch
- 한 프로세스에서 다른 프로세스로 CPU 제어권을 넘겨주는 것
- 이때 이전의 프로세스의 상태를 PCB에 저장하여 보관
- 새로운 프로세스의 PCB를 읽어서 보관된 상태를 복구하는 작업이 이루어짐

![image](https://github.com/user-attachments/assets/a4f1c4f3-4d41-45fb-9d61-fbcd29a1543b)


#### 프로세스와 스레드 컨텍스트 스위치
- 프로세스/스레드 컨텍스트 스위치 모두 커널 모드로 실행, CPU의 레지스터 상태를 바꿈
- 프로세스 컨텍스트 스위칭은 가상(virtual) 메모리 주소 관련 처리를 추가적으로 수행
  - MMV p2 메모리 보도록 바꿔주고, TLB 캐시를 비워줌
- 메모리 주소 관련 처리를 안해서 스레드 컨텍스트 스위칭이 더 빠름

#### 컨텍스트 스위칭이 미치는 간접적인 영향
- 캐시 오염(pollution)

## 멀티 프로세스 환경에서 프로세스간의 데이터 통신
- 멀티 스레드와 다르게 프로세스 끼리는 데이터 공유를 하고 있지 않음
- 데이터를 주고받기 위해 IPC기법을 사용
- IPC는 크게 공유메모리 방식과 메시지 전달 방식으로 나뉜다

### IPC (Inter-Process Communication)
- process는 각자 자신만의 독립적인 주소 공간을 가지는데, 다른 프로세스가 이 주소 공간을 참조하는 것은 허용하지 않음
- 다른 프로세스와 데이터를 주고 받을 수 없음
- 이를 해결하기 위해 운영체제는 IPC기법을 통해 프로세스간의 통신이 가능하도록 해줌
- 공유 메모리와 메시지 전달 두가지 모델이 있음

#### 공유 메모리 (Shared Memory)
- 프로세스들이 주소 공간의 일부를 공유
- 공유한 메모리 영역에 읽기/쓰기를 통해서 통신을 수행
- 공유 메모리 영역이 구축된 이후에는 모든 접근이 일반적인 메모리 접근으로 취급되어, 커널 도움 없이도 각 프로세스들이 해당 메모리 영역에 접근 가능
- 커널 관여 없이 데이터를 통신할 수 있기 때문에 IPC속도가 빠르다는 장점이 있음
- 프로세스간의 통신은 수원하지만 동시에 같은 메모리 위치에 접근하게 되면 일관성 문제가 발생할 수 있음
- 커널은 관여하지 않기 때문에 프로세스들 끼리 직접 공유 메모리 접근에 대한 동기화 문제를 책임져야함

![image](https://github.com/user-attachments/assets/ce2ee654-c244-44c7-909f-16f36657dcf9)

#### 메시지 전달 (Message Passing)
- 메시지 전달 방법은 통상 System call을 사용하여 구현됨
- 커널을 통해 send(message)와 receive(message)라는 두 가지 연산을 제공받음
- p1이 커널로 메시지를 보내면 커널이 p2에게 메시지를 보내주는 방식
- 메모리 공유에 비해 속도는 느리지만, 충돌을 회피할 필요가 없기 때문에 적은 양의 데이터를 교환하기에 유리
- 구현하기 쉬운 장점이 있음
- 대표적인 예로 pipe, socket, message queue 등이 있음

![image](https://github.com/user-attachments/assets/f7918702-57ec-448d-a120-1035c01b4933)


# 3. 멀티 스레드
- 쓰레드는 한 프로세스 내에서 실행되는 동작(기능 function)의 단위
- Multi thread란 하나의 process가 동시에 여러개의 일을 수행할수 있도록 해주는 것
- 즉, 하나의 프로세스에서 (실행이 된 하나의 프로그램에서) 여러 작업을 병렬로 처리하기 위해 멀티 스레드를 사용
- 멀티 스레드에서는 한 프로세스 안에 여러개의 스레드가 있고, 각 스레드는 스택 메모리를 제외한 나머지 영역 (Code, Data, Heap) 영역을 공유하게 됨
- 스레드는 프로세스 내에서 독립적인 기능을 수행. 즉, 독립적으로 함수를 호출함을 의미하고 이를 위해 스택 메모리가 필요

### Thread와 Multi Thread
- 스레드는 프로세스 내에서 독립적인 기능 수행
- 독립적으로 함수를 호출함

## Stack memory & PC register
- 스레드가 함수를 호출하기 위해서는 인자 전달, Return Address 저장, 함수 내 지역 변수 저장 등을 위한 독립적인 스택 메모리 공간이 필요
- 결과적으로 스레드는 프로세스로 부터 스택 메모리 영역은 독립적, 나머지는 공유하는 형태
- 멀티 스레드에서는 각각의 스레드마다 PC Register를 가지고 있어야 함.
- 한 프로세스 내에서도 스레드끼리 Context 스위치가 일어나게 되는데, PC register에 코드 주소가 저장되어 있어야 다음걸 실행할 수 있기 때문

- ![image](https://github.com/user-attachments/assets/622d25e7-4b85-4d97-9dd3-60557e5f44b7)

## 멀티 스레드 환경에서 동기화 문제
- 동기화 문제를 해결하기 위해서는 크게 Mutex, semaphore 기법 등을 사용할 수 있음

### 동기화 문제
- 동기화 문제란 서로 다른 thread가 메모리 영역을 공유하기 때문에 여러 thread가 동일한 자원에 동시에 접근하여 엉뚱한 값을 읽거나 수정하는 문제
- 예를 들어, count++를 CPU입장에서 보면 크게 atomic operations로 나뉨
  1. count 변수의 값을 가져옴
  2. count 변수의 값을 1 증가시킨다
  3. 변경된 count 값을 저장한다
- CPU는 atomic operation을 연산하게됨, 그래서 총 3번의 연산을 함
- 시분할 시스템으로 작동하는 멀티 프로세스/스레드 시스템에서 두개의 스레드가 동일한 데이터인 Count에 접근해 조작을 하는 상황이라면?
  - 스레드 1번과 2번 모두 count++을 한다면 그 실행결과가 접근 순선에 따라 달라질 수 있음.
  - 이것을 바로 **경쟁상황(race condition)**이라고 함

![image](https://github.com/user-attachments/assets/86a04ced-9ffe-4f8f-b731-eee9d96e3f23)

- 즉, 둘 이상의 스레드가 동일한 자원에 접근하여 조작하고, 그 실행 결과가 접근이 발생한 순서에 따라 달라지는 경쟁상황에 의해 동기화 문제가 발생할 수 있음
- 경쟁 상황으로 부터 보호하기 위해, 우리는 한 순간에 하나의 프로세스/스레드만 해당 자원에 접근하고 조작할 수 있도록 보장해야 함
- 프로세스/스레드들이 동기화 되도록 할 필요가 있음

### 임계영역 (critical section)
- 둘 이상의 프로세스/스레드가 동시에 동일한 자원에 접근하도록 하는 프로그램 코드 부분을 의미
- 한 프로세스나 스레드가 자신의 임계구역에서 수행하는 동안에는 다른 프로세스나 스레드가 그들의 임계구역에 들어갈 수 없어야 한다
- 즉, 임계 영역 내의 코드는 원자적으로 실행이 되어야 함.
- 원자적으로 실행되기 위해 각각의 스레드와 프로세스는 자신의 임계구역으로 진입하려면 진입 허가를 요청해야 함
- 이 부분을 entry section이라고 하고, 진입이 허가되면 임계영역을 실행할 수 있음
- 임계 영역을 끝나고 나면 exit section으로 퇴출을 하게 됨
- 임계 영역의 원자성을 보장하여 프로세스와 스레드들이 동기화되도록 할 수 있음
- 동기화 방법은 대표적으로 Mutex와 Semaphore가 있음

![image](https://github.com/user-attachments/assets/d14c4e53-0491-420f-9ba4-51fe4d8f6bbc)

### Mutex
- 동기화 방법 중 하나로 mutual exclusion의 축약어
- 공유자원에 접근할 수 있는 프로세스와 스레드의 수를 1개로 제한]
- 임계영역을 보호하고, 경쟁상황을 방지하기 위해 mutex lock을 사용
- 즉, 프로세스와 스레드는 임계영역에 들어가기 전에 반드시 locK을 획득해야하고, 나올때 반납
- acquire() 함수가 lock을 획득하고 release()함수가 lock을 반환

```c
acquire() // entry section (lock 얻음)

// critical section

release() // exit section (lock 반환)

-------
acquire() {
    while(!available); // busy wait
    available = false;
}
# available이 false면 while문에서 계속 돌고있음
# true가 되는 순간 critical section으로 넘어감

release() {
    available = true;
}
```

- busy waiting은 다른 프로세스나 스레드가 생산적으로 사용할 수 있는 CPU를 낭비한다는 단점이 있음

![image](https://github.com/user-attachments/assets/279fbe13-4128-413c-8615-30b74e7119e8)

### Semaphore
- 동기화 방법 중 하나로, mutex와 가장 큰 차이점은 공유 자원에 접근할 수 있는 프로세스/스레드의 개수가 2개 이상이 될 수 있다는 점
- semaphore 변수 S(세마포)에 동시에 접근 가능한 프로세스와 스레드의 갯수를 저장
- S가 0보다 크면 임계영역으로 들어갈 수 있고, 임계 영역에 들어가면 s의 값을 1 감소시킴
- s값이 0이 되면 다른 프로세스와 스레드는 임계영역으로 접근 불가
- 임계영역에서 작업이 끝나고 임계 영역에서 exit 하면서 s값을 1 증가 시킴

```c
wait(S) // entry section

// critical section

signal(S) // exit section
----------
wait(S) {
    while (S ≤ 0); // busy wait
    S--;
}

signal(S) {
    S++;
}
```
- semaphore값이 0,1만 가질 수 있는 경우 binary semaphore라고 하는데, 이는 mutex랑 거의 유사하게 작동
- mutex는 binary semaphore라고 할 수 있음

![image](https://github.com/user-attachments/assets/46fe7d0f-941d-4f70-a96f-716ab2583d3d)


# 4. 프로세스와 스레드의 비교
- 프로세스는 운영체제로 부터 자원을 할당받는 작업의 단위
- 스레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위
- 즉, 프로세스는 실행 파일(프로그램)이 메모리에 적재되어 `CPU를 할당받아 실행`
- 스레드는 한 프로세스 내에서 실행되는 `동작`의 단위
- 프로세스는 메모리 공간에 Code, data, heap,stack 영역이 있는데, 스레드는 프로세스 내에서 Stack영역을 제외한 code, data, heap 영역을 공유

# 5. 멀티 프로세스와 멀티 스레드의 비교
- 멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고, **Context Switching**이 빠름
  - 멀티 프로세스와 다르게 Context switching 시 캐시 메모리를 초기화할 필요가 없기 때문
- 멀티 프로세스는 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지
- 멀티 스레드는 동기화 문제와 **하나의 스레드 장애로 전체 스레드가 종료될 위험**이 있음
- 멀티 프로세스는 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 **안정성**이 높음

### 상황별 비교
- 메모리 구분이 필요할때는 multi process가 유리
- 반면에 컨텍스트 스위칭이 자주 일어나고 데이터 공유가 빈번한 경우, 그리고 자원을 효율적으로 사용해야 되는 경우에는 multi thread를 사용하는 것이 유리

- |  | 메모리 사용 / CPU 시간 | Context switching | 안정성 |
| --- | --- | --- | --- |
| multi process | 많은 **메모리 공간 / CPU 시간** 차지 | 느림 | 높음 |
| multi thread | 적은 **메모리 공간 / CPU 시간** 차지 | 빠름 | 낮음 |

![image](https://github.com/user-attachments/assets/c4c188b0-707a-41aa-a4c2-9c6619ce9b03)

### 멀티 스레드가 좋은점
- 멀티 프로세스 대신 멀티 스레드로 구현할 경우, 메모리 공간과 시스템 자원 소모가 줄어들게 됨
- 하지만 멀티 스레드를 사용할 때는 스레드 간 자원을 공유하기 때문에 동기화 문제가 발생할 수 있음
  - 여기서 동기화 문제란 서로 다른 thread가 메모리 영역을 공유하기 때문에 여러 thread가 동일한 자원에 동시에 접근하여 엉뚱한 값을 읽거나 수정하는 문제
- process간의 통신(IPC)보다 thread간의 통신 비용이 적기 때문에 통신으로 인한 오버헤드가 적음
  - 통신시 별도의 자원을 이용하지 않고, process에 할당된 Heap 영역등을 이용하여 데이터를 주고 받기 때문
 
### 멀티 스레드가 안좋은 점
- 스레드 간의 자원 공유 시 동기화 문제가 발생할 수 있어 프로그램 설계시 주의 필요
- 하나의 스레드에 문제가 생기면 프로세스 내의 다른 스레드에도 문제가 생길 수 있음

# 6. 교착 상태 (Deadlock)
- 둘 이상의 스레드가 각기 다른 스레드가 점유하고 있는 자원을 서로 기다릴 때, 무한 대기에 빠지는 상황
- deadlock 문제를 해결하는 방법에는 무시, 예방, 회피, 탐지-회복 4가지가 있음

### Deadlock 예시

![image](https://github.com/user-attachments/assets/357e17ec-9b8c-4fa5-8c6d-8e083cfe8a21)

## Deadlock 발생 조건
- 데드락이 발생하는 조건
  1. 상호 배제(mutual exclusion)
  2. 점유 대기(hold-and-wait)
  3. 비선점(no preemption)
  4. 순환 대기(circular wait)
- 위 4가지 조건이 동시에 성립할 때 발생할 수 있음

### 상호 배제(mutual exclusion)
- 동시에 한 스레드만 자원을 점유할 수 있는 상황
- 다른 스레드가 자원을 사용하려면 자원이 방출될 때 까지 기다려야 함

### 점유 대기(hold-and-wait)
- 스레드가 자원을 보유한 상태에서 다른 스레드가 보유한 자원을 추가로 기다리는 상황

### 비선점(no preemption)
- 다른 스레드가 사용 중인 자원을 강제로 선점할 수 없는 상황
- 자원을 점유하고 있는 스레드에 의해서만 자원이 방출됨

### 순환 대기(circular wait)
- 대기중인 스레드들이 순환 형태로 자원을 대기하고 있는 상황

## Deadlock 해결법

| 기법 | 설명 | 비고 |
| --- | --- | --- |
| 무시 | deadlock 발생 확률이 낮은 시스템에서 아무런 조치도 취하지 않고 deadlock을 무시하는 방법 | - 무시 기법은 **시스템 성능 저하가 없다**는 큰 장점이 있음 <br> - 현대 시스템에서는 deadlock이 **잘 발생하지 않고**, **해결 비용이 크기 때문에** 무시 방법이 많이 사용 |
| 예방 | 교착 상태의 4가지 발생 조건중 하나가 성립하지 않게 하는 방법 | - 순환 대기 조건이 성립하지 않도록 하는 것이 현실적으로 가능한 예방 기법 <br> - 자원 사용의 **효율성이 떨어지고 비용이 큼** |
| 회피 | thread가 앞으로 자원을 어떻게 요청할지에 대한 정보를 통해 순환 대기 상태가 발생하지 않도록 자원을 할당하는 방법 | - 자원 할당 그래프 알고리즘, 은행원 알고리즘 등을 사용하여 자원을 할당하여 deadlock을 회피 |
| 탐지-회복 | 시스템 검사를 통해 deadlock 발생을 탐지하고, 이를 회복시키는 방법 | - 자원 사용의 **효율성이 떨어지고 비용이 큼** |
 


## Ref
- [BJ.5 프로세스, 스레드, 멀티태스킹, 멀티스레딩, 멀티프로세싱, 멀티프로그래밍까지 한 방에 깔끔하게 설명](https://www.youtube.com/watch?v=QmtYKZC0lMU)
- [기출로 대비하는 개발자 전공면접](https://www.inflearn.com/course/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%A0%84%EA%B3%B5%EB%A9%B4%EC%A0%91-cs-%EC%99%84%EC%A0%84%EC%A0%95%EB%B3%B5/dashboard)
