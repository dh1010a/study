# JPA N + 1

## 목차
1. JPA N + 1 문제란?


# 1. JPA N + 1 문제란?
- 연관 관계가 설정된 엔티티를 조회할 경우에, 조회된 데이터 개수(N)만큼 연관관계의 조회 쿼리가 추가로 발생하는 현상
- ex) 블로그 게시글과 댓글이 있는 경우, 게시글을 조회한 후 각 게시글마다 댓글을 조회하기 위한 추가 쿼리가 발생할 수 있음. 이를 N + 1 문제라고 함

### findAll() 메서드의 글로벌 패치 전략 별 N + 1 문제 상황
- 글로벌 패치 전략을 즉시 로딩(EAGER)로 설정하고 `findAll()`을 실행하면 N + 1 문제가 발생
- `findAll()`은 `select u from User u`라는 JPQL 구문을 생성해 실행하기 때문임
- JPQL은 글로벌 패치 전략을 고려하지 않고 쿼리를 실행
- 모든 유저를 조회하는 쿼리 실행 후, 즉시 로딩 설정을 보고 연관관계에 있는 모든 엔티티를 조회하는 쿼리를 실행
  - **팀에 속한 모든 유저 조회하는 쿼리 1번 + 각 유저의 정보를 조회하는 쿼리 N번**

- 글로벌 패치 전략을 지연 로딩(LAZY)로 설정하고 `findAll()`을 실행하면 N + 1 문제가 발생하지 않음
- 연관관계에 있는 엔티리를 실제 객체 대신 프록시 객체로 생성하여 주입하기 때문
  - 하지만 프록시 객체를 사용할 경우에 실제 데이터가 필요해 조회하는 쿼리가 발생하고 N + 1 문제가 발생할 수 있음

# 2. N + 1 문제 해결방법
- Hibernate에서는 아래와 같은 해결법 세가지를 제시함
  

>Hibernate provides several strategies for efficiently fetching associations and avoiding N+1 selects:
>1. outer join fetching—where an association is fetched using a left outer join
>2. batch fetching—where an association is fetched using a subsequent select with a batch of primary keys
>3. subselect fetching—where an association is fetched using a subsequent select with keys re-queried in a subselect.



## Outer Fetch Join
- `fetch join`, `@EntityGraph`를 사용해볼 수 있음
- `fetch join`은 연관 관계에 있는 엔티티를 한번에 즉시 로딩하는 구문
- `@EntityGraph`도 비슷한 효과를 만들어내며, 쿼리 메서드에 해당 어노테이션을 추가해 사용할 수 있음


### Fetch Join
```sql
select distinct u
from User u
left join fetch u.posts
```

### @Entity Graph
```java
@EntityGraph(attributePaths = {"posts"}, type = EntityGraphType.FETCH)
List<User> findAll();
```

## batch & subselect fetching
- batch fetching과 subselect fetching은 모두 N+1 문제에서 발생하는 추가 조회 쿼리를 없애는 방향이 아니라 추가 조회 쿼리를 1개의 쿼리로 줄이는 방향으로 문제를 해결
- 따라서 추가 조회 쿼리를 없애는 것은 아니기 때문에 N+1 문제를 완벽하게 해결한다고 볼 수는 없음
- 단, 페치 조인 시에 거대한 카사디안 곱과 거대한 집합이 생성되는 경우에 최상의 솔루션이 될 수 있음

### batch fetching (@BatchSize)
- batch fetching은 설정을 통해 배치 사이즈를 조절하여 추가 조회 쿼리를 줄이는 해결 방법
- BatchSize를 설정함으로써 IN절로 하나의 쿼리로 날아감

```java
@Entity
public class Team {

    ...

    @OneToMany(mappedBy = "team", fetch = FetchType.EAGER)
    @BatchSize(size = 3)
    private List<Member> members = new ArrayList<>();
	
    ...
}
```

### subselect fetching (@BatchSize)
- subselect fetching은 설정을 통해 추가 조회 쿼리를 서브 쿼리로 줄이는 해결 방법

```java

Copy
@Entity
public class Team {

    ...

    @OneToMany(mappedBy = "team", fetch = FetchType.EAGER)
    @Fetch(value = FetchMode.SUBSELECT)
    private List<Member> members = new ArrayList<>();

    ...
}
```
- Member 엔티티가 조회될 때 IN절과 서브 쿼리를 사용하여 한번에 조회

## batch & subselect fetching의 중요한 공통점
- LAZY하게 동작한다는 점
- join fetching(페치 조인)을 사용하게 되면 LAZY하게 동작하지 않기 때문에 즉시 Join하여 데이터를 가져옴. 따라서 무조건적으로 사용하면 안되고, 상황에 따라 적용해야하는 유연성이 필요
- batch & subselect fetching는 LAZY하게 동작하기 때문에 LAZY 로딩에서 선언하기만 하면 상황을 고려할 필요가 없어서 편리
- 그러나 Hibernate에선 이러한 편리함은 우리가 포기하라고 권장함
  - batch & subselect fetching이 편리하더라도 join fetching(페치 조인)을 권장

## Ref
- [[JPA] JPA N+1 문제 및 근본적인 원인에 대한 개인적인 고찰](https://ksh-coding.tistory.com/146#3-1.%20outer%20join%20fetching%C2%A0-1)
- [maeil-mail](https://www.maeil-mail.kr/question/49)
