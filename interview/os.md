# CS 면접을 위한 OS 질문리스트

<details>
  <summary>운영체제란 무엇인가요?</summary>
  <ul>
    <li> 하드웨어를 관리하고, 컴퓨터 시스템의 자원들을 효율적으로 관리하며 , 응용 프로그램과 하드웨어 간의 인터페이스로서 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공해줍니다. 즉, 운영체제는 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 시스템 소프트웨어라고 할 수 있습니다.</li>
  </ul>
</details>

## System Call

<details>
  <summary>시스템 콜이 무엇인가요?</summary>
  <ul>
    <li> 시스템 콜은 운영체제(OS)가 제공하는 서비스에 접근하기 위한 유일하고 공식적인 통로(인터페이스)입니다.</li>
    <li> 사용자 프로그램(애플리케이션)이 운영체제의 핵심 기능이나 자원을 사용하고 싶을 때, OS 커널에게 요청을 전달하는 메커니즘</li>
  </ul>
</details>

<details>
  <summary>시스템 콜이 왜 필요한가요?</summary>
  <ul>
    <li> CPU는 일반적으로 커널모드와 유저 모드 두가지로 동작합니다.</li>
    <li> 파일을 읽거나 네트워크에 접속하는 등의 중요한 작업은 하드웨어(자원)에 직접 접근해야 하므로 커널 모드에서만 수행될 수 있습니다. 사용자 모드의 프로그램이 직접 하드웨어에 접근하는 것을 허용하면 시스템 충돌이나 보안 문제가 발생할 수 있습니다. 따라서, 사용자 프로그램은 직접 커널의 자원에 접근하는 대신, 
      시스템 콜이라는 공식적인 절차를 통해 커널에게 대리 실행을 요청하는 것입니다.</li>
  </ul>
</details>

<details>
  <summary>우리가 사용하는 시스템 콜의 예시에는 무엇이 있을까요?</summary>
  <ul>
    <li> 파일 관리에서 open, read, write, close등의 작업이 있고, 프로세스 fork, exec 실행, exit 등이 있습니다. </li>
    <li> 이 외에도 입출력 장치에서의 read, write, 통신할 때의 socket, connect, accept 등이 있습니다. </li>
  </ul>
</details>

<details>
  <summary>시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해주세요.</summary>
  <ul>
    <li> 시스템 콜은 사용자 모드에서 커널 모드로 전환하여 서비스를 요청하는 과정입니다. </li>
    <li> 애플리케이션은 먼저 필요한 인수를 레지스터나 스택에 준비합니다. 이후 프로그램이 시스템 콜 함수를 호출하면, 소프트웨어의 인터럽트인 트랩을 발생시킵니다.
    트랩은 CPU를 사용자 모드에서 커널 모드로 강제 전환 시키고, 커널은 해당 서비스의 로직을 수행하며 필요한 작업을 수행합니다. 이후 작업이 완료되었다면
    커널은 CPU를 다시 사용자 모드로 전환하고, 결과를 사용자 프로그램에 반환하며 원래 실행지점으로 복귀합니다.</li>
  </ul>
</details>

<details>
  <summary>시스템 콜의 유형에 대해 설명해주세요</summary>
  <ul>
    <li> 프로그램의 실행 환경을 관리하고 제어하는 데 사용하는 프로세스 제어  </li>
    <li> 컴퓨터의 영구 저장소에 있는 파일들을 생성, 접근, 수정하는 데 사용되는 파일 관리</li>
    <li> CPU와 메모리를 제외한 모든 입출력 장치(I/O Device)를 제어하고 접근하는 데 사용되는 장치 관리</li>
    <li> OS 자체나 실행 환경에 대한 정보를 얻거나 설정하는 데 사용되는 정보 관리 (time() 등)</li>
    <li> 서로 독립적인 프로세스들이 정보를 교환할 수 있도록 통신 경로를 설정하고 관리하는 통신 (메시지 전달, 네트워크 통신, 공유 메모리 등)</li>
  </ul>
</details>

<details>
  <summary>운영체제의 Dual Mode 에 대해 설명해주세요.</summary>
  <ul>
    <li> 듀얼 모드(Dual Mode)는 운영체제(OS)가 시스템의 안전성과 신뢰성을 보장하기 위해 CPU의 실행 권한을 두 가지 레벨로 나누어 관리하는 핵심적인 보호 메커니즘입니다. </li>
    <li> 커널모드는 모든 특권 명령어와 하드웨어 자원에 직접 접근 가능한 최고 권한을 가진 모드입니다.</li>
    <li> 유저 모드는 특권 명령 실행이 금지되며, 자원에 접근하려면 OS에게 시스템 콜을 요청해야 합니다.</li>
  </ul>
</details>

<details>
  <summary>왜 유저모드와 커널모드를 구분해야 하나요?</summary>
  <ul>
    <li> 듀얼 모드는 시스템의 보호(Protection)를 위해 필수적입니다. 시스템 안정성과 자원 관리의 일관성 측면에서, </li>
    <li> 사용자 모드 프로그램에서 발생한 오류나 무한 루프가 시스템의 핵심 자원이나 다른 프로그램에 영향을 미치는 것을 원천적으로 차단하고,
    디스크 I/O나 메모리 관리 같은 중요한 작업은 커널 모드에서만 수행되도록 강제하여, 모든 자원 할당 및 회수 과정을 OS가 통제하고 일관성을 유지하게 합니다.</li>
  </ul>
</details>

<details>
  <summary>서로 다른 시스템 콜을 어떻게 구분할 수 있을까요? </summary>
  <ul>
    <li> 운영체제(OS)가 수많은 시스템 콜(System Call)을 서로 구분하고 어떤 서비스를 요청받았는지 정확히 식별하는 방식은 주로 시스템 콜 번호(System Call Number) 또는 인덱스를 이용하는 것입니다. </li>
    <li> 시스템 콜 번호는 OS가 각 시스템콜 함수에 고유한 ID를 미리 할당하고, 요청시 이 번호와 필요한 정보를 같이 요청하도록 하는 방식입니다. </li>
    <li> 이렇게 받은 번호를 시스템 콜 테이블에서 해당 함수의 주소를 조회하여 매칭하고, 실행합니다.  </li>
  </ul>
</details>


## 인터럽트
<details>
  <summary>인터럽트에 대해 설명해주세요 </summary>
  <ul>
    <li> 인터럽트란 CPU(중앙처리장치)가 현재 실행하고 있는 프로그램의 정상적인 흐름을 중단시키고, 시스템 내부에 발생한 사건(이벤트)을 처리할 수 있도록 운영체제(OS) 커널에게 제어권을 넘겨주는 메커니즘을 말합니다. </li>
    <li> 이는 CPU가 외부 장치(키보드, 디스크 등)나 프로그램 자체로부터 발생하는 비동기적 또는 동기적 요청에 대해 즉각적으로 반응하여 시스템을 효율적이고 안정적으로 관리하게 해줍니다. </li>
  </ul>
</details>

<details>
  <summary>인터럽트는 어떻게 처리하나요? </summary>
  <ul>
    <li> I/O 작업이나 시스템 콜, 예외 등에 의해서 인터럽트가 발생하면, 인터럽트 컨트롤러가 이 신호를 CPU에 전달합니다.CPU는 현재 실행되던 명령을 수행한 직후 커널모드로 전환하고 처리를 시작합니다. </li>
    <li> CPU는 현재 실행 중이던 프로세스의 문맥(Context), 즉 현재 상태를 안전하게 보존해야 합니다. 프로그램 카운터(PC)와 CPU 레지스터의 값들을 PCB에 저장합니다. 이후 인터럽트를 식별하고 서비스 루틴을 호출하는 과정을 거칩니다. </li>
    <li> ISR(Interrupt Service Routine)이 인터럽트 유형에 따라 작업을 완료하고, 인터럽트를 해제합니다. 이후 저장해놓았던 context를 복구하며, CPU를 사용자 모드로 전환시켜 실행을 재개합니다.</li>
  </ul>
</details>

<details>
  <summary> polling에 대해 설명해주세요 </summary>
  <ul>
    <li> 폴링(Polling) 방식은 CPU가 입출력(I/O) 장치의 상태를 주기적으로 직접 확인하여 장치의 작업 완료 여부를 파악하는 방식입니다. </li>
    <li> CPU가 반복적인 루프를 돌면서 I/O 장치의 상태 레지스터(Status Register) 값을 읽어와, 완료되었으면 데이터를 처리하고 아니면 계속 폴링을 지속하거나 다른 작업을 수행합니다. </li>
    <li> 장점으로는 구현이 간단하고, 하드웨어적인 복잡성이 낮습니다. 인터럽트 컨트롤러가 없는 매우 단순한 시스템에서 사용될 수 있습니다.</li>
    <li> 단점으로는 CPU 이용 효율이 낮습니다. CPU가 I/O 장치의 상태를 확인하는 데 대부분의 시간을 소비하게 되어, 실제 유용한 작업을 수행할 시간이 줄어듭니다. 이는 CPU 사이클 낭비로 이어집니다.</li>
    <li> 또한 중요한 이벤트가 발생하더라도, CPU가 해당 장치를 폴링하는 주기까지 기다려야 하므로 응답 시간이 지연될 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary> 인터럽트와 polling의 차이점은? </summary>
  <ul>
    <li> 인터럽트는 주도권이 I/O 장치에 있습니다. 장치에서 작업이 완료될 때 까지 CPU는 기다리지 않고 다른 작업을 수행하고 있다가, 완료 신호를 받으면 그때 해당 작업을 처리할 수 있습니다. 따라서 CPU의 사용 효율성이 높고 응답시간이 빠르다는 장점이 있습니다. </li>
    <li> 폴링은 주도권이 CPU에 있습니다. 장치에서 작업이 완료 되었는지 여부를 CPU에서 지속적으로 장치에 신호를 보내 확인합니다. 구현이 간단하지만 CPU의 효율성이 떨어지고 응답 시간이 지연될 수 있는 문제가 있습니다. </li>
  </ul>
</details>

<details>
  <summary> HW/SW 인터럽트에 대해 설명해주세요 </summary>
  <ul>
    <li> 하드웨어 인터럽트는 CPU 외부의 장치나 하드웨어적인 사건으로 인해 발생하며, 주로 비동기적으로 발생합니다. 키보드, 마우스, 디스크 드라이브, 타이머, 네트워크 카드 등 I/O 장치이 주체이며, 자신의 작업 완료 여부를 알리기 위해 발생시킵니다.</li>
    <li> 소프트웨어 인터럽트는 실행 중인 프로그램 내부의 명령어나 논리적 문제 때문에 발생하며, 주로 동기적으로 발생합니다. 실행 중인 CPU 명령어 자체나 프로그램의 논리적 오류입니다. 주로 시스템 콜 예외에 의해 발생합니다. </li>
  </ul>
</details>


## Process

<details>
  <summary>프로세스에 대해 설명해주세요</summary>
  <ul>
    <li> 실행파일 형태로 존재하던 프로그램이, 메모리에 적재되어 CPU를 할당받아 실행되는 것을 프로세스 라고 합니다.</li>
    <li> 사전적 의미: 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램</li>
  </ul>
</details>

<details>
  <summary>process의 memory영역에 대해서 설명해 주세요.</summary>
  <ul>
    <li> 프로세스가 운영체제에서 할당받는 메모리 공간은 code, data, stack, heap 영역으로 구분됩니다.</li>
    <li> code 영역은 실행한 프로그램의 코드가 저장되는 메모리 영역입니다.</li>
    <li> data 영역은 프로그램의 전역 변수와 static 변수가 저장되는 메모리 영역입니다.</li>
    <li> heap 영역은 프로그래머가 직접 공간을 할당(malloc)/해제(free) 하는 메모리 영역입니다.</li>
    <li> stack 영역은 함수 호출 시 생성되는 지역 변수와 매개 변수가 저장되는 임시 메모리 영역입니다.</li>
  </ul>
</details>

<details>
  <summary>PC Register에 대해 설명해주세요</summary>
  <ul>
    <li> CPU가 실제로 코드를 읽어 수행해야 프로세스가 실행된다고 할 수 있습니다. 이 때 어떤 코드를 읽어 실행해야 할지에 대한 정보가 필요한데, 이 정보가 있는곳은 CPU 내부의 PC Register입니다. 이곳에는 CPU가 다음에 실행해야할 명령어의 주소값이 저장되어 있습니다. </li>
  </ul>
</details>

<details>
  <summary>멀티 프로세스에 대해 설명해주세요</summary>
  <ul>
    <li> 멀티 프로세스는 두개 이상의 프로세스가 동시에 실행되는 것을 말합니다. 동시에 라는 말은 동시성과 병렬성 두가지를 의미합니다. 먼저 동시성은 하나의 코어에서 두개 이상의 프로세스들을 밀리세컨드 단위의 짧은 타임슬랏 안에서 번갈아가며 연산하는 시분할 시스템으로 실행되는 것입니다. 병렬성은 CPU 코어가 여러개일때 각각의 코어가 각각의 프로세스를 연산함으로서 프로세스가 동시에 실행되는것입니다. </li>
  </ul>
</details>

<details>
  <summary>프로세스들 간에 할당받는 메모리 공간이 다른데, 이러한 메모리는 어떻게 관리되나요?</summary>
  <ul>
    <li> 여러 process가 동시에 memory에 적재된 경우, 서로 다른 process의 영역을 침범하지 않도록 각 process가 자신의 memory영역에만 접근하도록 운영체제가 base register, limit register와 같은것들로 관리해줍니다. </li>
  </ul>
</details>

<details>
  <summary>Context에 대해 설명해주세요</summary>
  <ul>
    <li> 시분할 시스템에서는 한 프로세스가 매우 짧은 시간동안 CPU를 점유하여 작업을 진행하다가 다른 프로세스에 점유권을 넘기고, 나중에 다시 넘겨받아 실행하게 됩니다. 이때 이전에 어디까지 명령을 수행했고 register들에는 어떤 값이 있었는지에 대한 정보가 필요합니다. 프로세스가 어떤 상태로 실행되고 있었는지에 대한 총체적인 정보를 Context라고 합니다. 이 context들은 pcb에 저장되게 됩니다. </li>
  </ul>
</details>

<details>
  <summary>PCB에 대해 설명해주세요</summary>
  <ul>
    <li> PCB는 운영체제가 프로세스를 표현한 자료구조입니다. PCB는 프로세스의 중요한 정보를 포함하기 때문에 보호된 메모리 영역에 저장됩니다. PCB에는 일반적으로 프로세스의 상태, 번호, Program Counter,register, 메모리정보(해당 프로세스의 주소공간 등) 들이 포함되어 있습니다. </li>
  </ul>
</details>

<details>
  <summary>Context Switching에 대해 설명해주세요</summary>
  <ul>
    <li> 프로세스는 실행(running), 준비(ready), 봉쇄(wait, sleep, blocked) 세 가지 상태로 구분됩니다. </li>
    <li> 실행은 프로세스가 CPU를 점유하여 명령을 수행중인 상태를 의미합니다. </li>
    <li> 준비는 CPU만 할당 받으면 즉시 명령을 수행할 수 있도록 준비된 상태를 의미합니다. </li>
    <li> 봉쇄는 I/O 작업을 기다리는 등 CPU를 할당 받아도 즉시 수행할 수 없는 상태를 의미합니다. </li>
  </ul>
</details>

<details>
  <summary>Process의 State에는 어떤게 있나요?</summary>
  <ul>
    <li> Context Switching이란 한 프로세스에서 다른 프로세스로 제어권을 넘겨주는 것을 말합니다. 이때 이전 프로세스의 상태를 PCB에 저장하고, 새로운 프로세스의 정보를 읽어 보관된 상태를 복구하는 작업이 이루어집니다. </li>
  </ul>
</details>

<details>
  <summary>멀티 프로세스간의 데이터는 어떻게 주고받을까요?</summary>
  <ul>
    <li> 원칙적으로 프로세스는 독립적인 주소 공간을 가지기 때문에 다른 프로세스의 주소 공간을 참조할 수 없습니다. 하지만 경우에 따라 운영체제는 프로세스간의 자원 접근을 위한 매커니즘인 프로세스간 통신 (IPC) 프로토콜을 제공합니다. IPC에는 소켓, 파이프, 파일, 공유메모리등을 이용한 방법이 있습니다.</li>
  </ul>
</details>

<details>
  <summary>IPC의 예시를 설명해주세요.</summary>
  <ul>
    <li> IPC는 크게 공유 메모리 모델과 메시지 전달 모델로 나눌 수 있습니다. 공유 메모리 모델은 주소 공간의 일부를 공유하며 공유한 메모리 공간에 read/write를 통해 통신하게 되는데, 예시로는 공유메모리와 POSIX가 있습니다. 메시지 전송 모델의 경우 커널을 통해 send/receive 연산을 통해 데이터를 전송합니다. 예시로는 파이프, 소켓, 메시지 큐 등이 있습니다.</li>
  </ul>
</details>

<details>
  <summary>공유메모리와 메시지 전달 모델의 장단점을 설명해주세요.</summary>
  <ul>
    <li> 공유 메모리 모델은 초기에 공유 메모리 할당을 제외하면 커널의 관여 없이 통신할 수 있기 때문에 통신 속도가 빠른 장점이 있습니다. 하지만 여러 프로세스가 동시에 메모리에 접근하는 문제가 발생할 수 있어서 별도의 동기화 과정이 필요하다는 단점이 있습니다.</li>
    <li> 메시지 전달 모델은 커널을 통해서 데이터를 주고받기 때문에 통신 속도가 느리다는 단점이 있습니다. 하지만 커널에서 제어를 해주기 때문에 안정성이 높으며 커널이 동기화를 제공해준다는 장점이 있습니다.</li>
  </ul>
</details>


## Thread

<details>
  <summary>스레드에 대해 설명해주세요</summary>
  <ul>
    <li> thread는 한 process 내에서 실행되는 동작(기능 function)의 단위입니다. 각 thread는 속해있는 process의 Stack 메모리를 제외한 나머지 memory 영역을 공유할 수 있습니다.</li>
    <li> 사전적 의미: 프로세스 내에서 실행되는 여러 흐름의 단위. 프로세스가 할당받은 자원을 이용하는 실행의 단위</li>
  </ul>
</details>

<details>
  <summary>멀티 스레드에 대해 설명해주세요</summary>
  <ul>
    <li> 멀티 스레드란 하나의 프로세스에서 동시에 여러개의 일을 수행할 수 있도록 해주는 것입니다.즉, 하나의 프로세스에서 여러 작업을 병렬로 처리하기 위해 멀티 스레드를 사용합니다. 한 프로세스 안에는 여러개의 스레드가 있고, 각 스레드들은 스택 메모리 영역을 제외한 코드,힙,데이터 영역을 공유하게 됩니다. </li>
  </ul>
</details>

<details>
  <summary>스레드는 왜 독립적인 스택 메모리 영역이 필요한가요?</summary>
  <ul>
    <li> 스택 영역은 함수 호출시 전달되는 인자, 함수의 리턴 어드레스, 함수 내 지역변수 등을 저장하기 위한 영역입니다. 스레드가 프로세스 내에서 독립적인 기능을 수행한다는 것은 곧 독립적으로 함수를 호출한다는것을 의미합니다. 따라서 각 스레드가 독립적인 동작을 수행하기 위해서는 각 스레드의 스택 메모리 영역이 독립적이여야 합니다.</li>
  </ul>
</details>

<details>
  <summary>프로세스와 스레드를 비교설명 해주세요.</summary>
  <ul>
    <li> process는 운영체제로부터 자원을 할당받는 작업의 단위이고 thread는 process가 할당받은 자원을 이용하는 실행의 단위입니다. 즉, process는 실행파일(program)이 memory에 적재되어 CPU를 할당받아 실행되는 것입니다. thread는 한 process 내에서 실행되는 동작의 단위입니다. 프로세스는 메모리 공간에 stack,code,heap,data 영역이 있는데 스레드는 이중 stack을 제외한 영역을 공유합니다. </li>
  </ul>
</details>

<details>
  <summary>멀티 프로세스와 멀티 스레드를 비교설명 해주세요.</summary>
  <ul>
    <li> 멀티 스레드는 멀티 프로세스보다 적은 공간을 차지하고 컨텍스트 스위칭이 빠릅니다.</li>
    <li> 멀티 스레드는 동기화 문제와 하나의 스레드의 장애로 전체 스레드가 종료될 위험이 있습니다.</li>
    <li> 멀티 프로세스는 멀티 스레드보다 더 많은 메모리공간과 CPU시간을 차지하게됩니다.</li>
    <li> 멀티 프로세스는 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높습니다.</li>
  </ul>
</details>

<details>
  <summary>멀티 프로세스와 멀티 스레드는 각각 어떨때 사용하면 좋나요?</summary>
  <ul>
    <li> 멀티 프로세스는 메모리 구분이 확실하게 필요할 때 사용하면 좋습니다. 멀티 스레드는 컨텍스트 스위칭이 자주 일어나고 데이터 공유가 빈번한 경우, 자원을 효율적으로 사용해야 하는 경우에는 멀티 스레드를 사용하는것이 좋습니다.</li>
  </ul>
</details>

<details>
  <summary>멀티 스레드가 멀티 프로세스보다 더 좋은점은 뭔가요?</summary>
  <ul>
    <li> 멀티 프로세스를 이용하던 작업을 멀티 스레드로 구현하게 된다면, 메모리 공간과 시스템 자원 사용량이 줄어들게 됩니다. 또한 자원을 생성하고 할당하는 등의 시스템 콜 사용을 생략할 수 있기 때문에 자원을 효율적으로 관리할 수 있습니다. 뿐만 아니라 컨텍스트 스위칭 시 메모리 주소 체계와 관련한 캐시 메모리를 초기화할 필요가 없어 더 빠르게 동작합니다.</li>
    <li> 데이터를 주고받을때를 비교해보면, 프로세스간의 통신인 IPC(Inter Process Communication) 보다 멀티 스레드간의 통신 비용이 적기 때문에 오버헤드가 적습니다. 통신시 별도의 자원을 이용하지 않고 프로세스에 할당된 heap 영역 등을 통해 데이터를 주고받기 때문입니다.</li>
  </ul>
</details>

<details>
  <summary>멀티 스레드가 멀티 프로세스보다 안좋은점은 뭔가요?</summary>
  <ul>
    <li> 스레드 간의 자원 공유시 동기화 문제가 발생할 수 있어 설계시 주의가 필요하며, 하나의 스레드에 문제가 발생할 경우 다른 스레드에도 문제가 발생할 수 있습니다.</li>
  </ul>
</details>

## 동기화
<details>
  <summary>멀티 프로세스와 스레드 환경에서 동기화 문제를 어떻게 해결하나요?</summary>
  <ul>
    <li> 동기화 문제를 해결하기 위해서는 뮤텍스, 세마포어 기법 등을 사용할 수 있습니다.</li>
    <li> 뮤텍스는 한개의 스레드만이 공유 자원에 접근할 수 있도록 하여, 경쟁 상황(race condition)를 방지하는 기법입니다. 공유 자원을 점유하는 스레드가 락을 걸면, 다른 스레드는 unlock이 될때 까지 해당 자원에 접근할 수 없습니다.</li>
    <li> 세마포어란 S개의 스레드만이 공유 자원에 접근할 수 있도록 제어하는 동기화 기법입니다. 세마포어 기법에서는 정수형 변수 S값을 가용한 자원의 수로 초기화 하고, 자원에 접근할 때는 S의 수를 줄이고 방출할때는 값을 더해 세마포값을 증가시킵니다. 이때 세마포 값이 0이되면 모두 사용중임을 의미하고, 이후 자원을 사용하려는 프로세스는 세마포값이 0보다 커질때까지 block됩니다.</li>
  </ul>
</details>

<details>
  <summary> mutex와 semaphore를 비교해서 설명해주세요</summary>
  <ul>
    <li> 뮤텍스는 오직 한개의 스레드나 프로세스만 공유자원에 접근할 수 있지만 세마포어는 세마포 변수의 값 만큼의 프로세스나 스레드들이 동시에 자원에 접근할 수 있습니다. 뮤텍스는 바이너리 세마포어라고 할 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary> deadlock에 대해 설명해주세요</summary>
  <ul>
    <li> 둘 이상의 스레드가 각기 다른 스레드가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황을 말합니다.</li>
    <li> 데드락이 발생하는 조건은 상호 배제(mutual exclusion), 점유 대기 (hold-and-wait), 비선점(preemption), 순환대기(circular wait) 입니다. 이 4가지 조건이 동시에 성립할 때 발생할 수 있습니다.</li>
    <li> 상호 배제는 동시에 한 스레드만 자원을 점유할 수 있는 상황이고, 점유 대기는 스레드가 자원을 보유한 상태에서 다른 스레드가 보유한 자원을 추가적으로 기다리는 상황입니다. 비선점은 다른 스레드가 사용중인 자원을 강제로 선점할 수 없는 상황을 뜻하고, 순환 대기는 대기중인 스레드들이 순환 형태로 자원을 대기하는 상황을 말합니다.</li>
  </ul>
</details>

<details>
  <summary> deadlock은 어떻게 해결할 수 있나요?</summary>
  <ul>
    <li> 데드락 문제를 해결하는 방법에는 무시, 예방, 회피, 탐지-회복 네가지가 있습니다.</li>
    <li> 무시는 데드락 발생 확률이 낮은 시스템에서 아무런 조치도 취하지 않고 무시하는 방법이며 현대 시스템에서는 잘 발생하지 않고 해결 비용이 커 무시 방법이 많이 사용됩니다. 예방은 교착 상태 4가지 발생 조건 중 하나가 성립되지 않도록 하는 방법입니다. 순환 대기 조건이 발생하지 않도록 하는게 현실적이며 자원 사용의 효율성이 떨어지고 비용이 큽니다. 회피는 스레드가 앞으로 자원을 어떻게 요청할지에 대한 정보를 미리 받아 순환 대기가 발생하지 않도록 회피하는 방법입니다. 자원할당 그래프, 은행원 알고리즘 등을 통해 데드락을 회피합니다. 마지막으로 탐지-회복은 시스템 검사를 통해 데드락을 탐지하고 이를 회복시키는 방법입니다. 자원 사용의 효율성이 떨어지고 비용이 큽니다.</li>
  </ul>
</details>

<details>
  <summary> (커널 모드에서의) Race Condition이 뭔가요?</summary>
  <ul>
    <li> 공유 자원에 대해 여러 프로세스가 동시에 접근할 때, 결과값에 영향을 줄 수 있는 상태를 말합니다. 동시 접근 시 자료의 일관성을 해칠 수 있습니다.</li>
    <li> 먼저 커널 작업을 수행하는 중 인터럽트가 발생할 수 있습니다. 커널 모드에서 데이터를 로드하여 작업을 수행하다가 인터럽트가 발생하여 같은 데이터를 조작하는 경우 생기며, 커널 모드에서 작업을 수행하는 동안 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하도록 해결할 수 있습니다.</li>
    <li> 프로세스가 시스템콜을 하여 커널 모드로 진입하여 작업을 수행하는 도중 문맥 교환이 발생할 때 생길 수 있습니다. 프로세스 1이 커널모드에서 데이터를 조작하는 도중 시간이 초과되어 CPU 제어권이 프로세스 2로 넘어가 같은 데이터를 조작하는 경우 발생할 수 있습니다. 프로세스가 커널모드에서 작업을 하는 경우 시간이 초과되어도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 해 해결할 수 있습니다.</li>
    <li> 멀티프로세서 환경에서 공유 메모리 내의 커널 데이터에 접근할 때 생길 수 있습니다. 멀티 프로세서 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우 생기며, 커널 내부에 있는 각 공유 데이터에 접근할 때마다, 그 데이터에 대한 lock/unlock을 함으로서 해결할 수 있습니다. </li>
  </ul>
</details>

## Memory

<details>
  <summary> Paging이란 뭔가요? </summary>
  <ul>
    <li> 페이징이란 프로세스가 할당받은 메모리 공간을 일정한 Page 단위로 나누어, 물리 메모리에서 연속되지 않는 서로 다른 위치에 저장하는 메모리 관리 기법입니다. </li>
    <li> 페이징 기법에서는 물리적 메모리를 페이지와 같은 크기의 프레임으로 미리 나누어둡니다. 페이지 단위로 메모리 적재가 이루어지기 때문에 미리 분할해두면 빠르게 메모리 할당이 이루어질 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary> 논리적 주소, 물리적 주소, 주소 바인딩에 대해 설명해주세요 </summary>
  <ul>
    <li> 논리적 주소란 프로세스가 메모리에 적재되기 위한 독자적인 주소 공간인 논리적 주소가 생성됩니다. 논리적 주소는 각 프로세스마다 독립적으로 할당되며 0번지 부터 시작합니다. </li>
    <li> 물리적 주소는 프로세스가 실제로 메모리에 적재되는 위치를 말합니다. </li>
    <li> 주소 바인딩이란 CPU가 기계어 명령을 수행하기 위해 프로세스의 논리적 주소가 실제 물리적 메모리의 어느 위치에 매핑되는지 확인하는 과정을 주소 바인딩이라고 합니다. </li>
  </ul>
</details>

<details>
  <summary> 페이지 테이블에 대해서 설명해주세요 </summary>
  <ul>
    <li> 페이지 기법에서는 하나의 프로세스 내에서도 페이지 단위로 다른 물리적 메모리에 저장되기 때문에 주소 바인딩을 위해 논리적 주소와 물리적 주소를 매핑하는 작업이 필요합니다. 이때 그 정보를 기록해두는 곳이 페이지 테이블입니다. </li>
  </ul>
</details>

<details>
  <summary> 페이징 기법 사용시 발생할 수 있는 메모리 단편화(Memory fragmentation)에 대해 설명하시오 </summary>
  <ul>
    <li> 물리적 메모리 공간이 작은 조각으로 나눠져서 메모리가 충분히 존재함에도 할당이 불가능한 상태를 보고 메모리 단편화가 발생했다고 합니다. 페이징 기법에서는 프로세스의 논리적 주소 공간과 물리적 메모리가 같은 크기의 페이지로 나눠지기 때문에 외부 단편화 문제가 발생하지 않습니다. 하지만 프로세스의 주소 공간 크기가 페이지의 배수라는 보장이 없기 때문에 프로세스의 주소 공간 중 가장 마지막에 위치한 페이지에서는 내부 단편화 문제가 발생할 가능성이 높습니다. </li>
  </ul>
</details>

<details>
  <summary> 세그멘테이션에 대해서 설명해주세요</summary>
  <ul>
    <li> 세그멘테이션이란 프로세스가 할당받은 메모리 공간을 논리적 의미 단위인 세그먼트로 나누어, 연속되지 않은 물리 메모리 공간에 할당될 수 있도록 하는 메모리 관리 기법입니다. 일반적으로 코드, 데이터, 힙, 스택 등의 기능 단위로 나누며, 주소 바인딩을 위한 세그먼트 테이블을 가집니다.</li>
    <li> 세그먼트 테이블은 그 크기가 균일하지 않아 [번호, offset]으로 표현되는데, 이때 오프셋 값이 테이블의 리밋 값보다 크면 segmentation fault가 발생하게됨</li>
  </ul>
</details>

<details>
  <summary> 세그멘테이션 사용시 발생할 수 있는 메모리 단편화(Memory fragmentation)에 대해 설명하시오</summary>
  <ul>
    <li> 세그멘테이션 기법에서 세그먼트의 크기만큼 메모리를 할당함으로 내부 단편화 문제가 발생하지 않습니다. 하지만 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되면, 외부 단편화 문제가 발생할 가능성이 있습니다. </li>
  </ul>
</details>

<details>
  <summary> 페이징과 세그멘테이션의 차이는 뭔가요?</summary>
  <ul>
    <li> 페이징 기법은 일정한 크기의 단위인 페이지로 나누어 할당을 하는데, 이에 반해 세그멘테이션은 코드, 데이터, 힙, 스택 등 기능 단위로 물리 메모리에 할당을 하는 기법입니다. 페이징의 경우 내부단편화 문제, 세그멘테이션의 경우 외부단편화 문제가 발생할 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary> paged segmentation 기법에 대해 설명하시오</summary>
  <ul>
    <li> paged segmentation이란 세그멘테이션을 기본으로 하되 이를 다시 동일한 크기의 페이지로 나누어 물리 메모리에 할당하는 기법입니다. 즉, 프로그램을 의미 단위의 세그먼트로 나누고 개별 세그먼트의 크기를 페이지의 배수가 되도록 하는 방법입니다. 이를 통해 세그멘테이션에서 발생하는 외부 단편화 문제를 해결하고, 동시에 세그먼트 단위로 프로세스간의 공유나 프로세스 내의 접근 권한 보호가 이루어지도록 해서 페이징 기법의 단점을 해결합니다.</li>
  </ul>
</details>

<details>
  <summary> 가상 메모리에 대해 설명하시오</summary>
  <ul>
    <li> 가상 메모리란 프로세스 전체가 메모리에 올라오지 않더라도 실행이 가능하도록 하는 개념입니다. 가상 메모리 기법을 통해 사용자 프로그램이 물리적 메모리 보다 커져도 실행이 가능하다는 장점이 있습니다. 직접적으로 필요하지 않은 메모리 공간은 디스크의 swap 영역에 저장하게 됩니다.</li>
  </ul>
</details>

<details>
  <summary> 요구 페이징에 대해 설명하시오</summary>
  <ul>
    <li> 요구 페이징 기법은 특정 페이지에 대해 cpu 요청이 들어왔을 때 해당 페이지를 메모리에 적재합니다. 당장 실행에 필요한 페이지만을 메모리에 적재하기 때문에 메모리 사용량이 감소하고, 프로세스 전체를 메모리에 적재하는 입출력 오버헤드도 감소하는 장점이 있습니다. 요구 페이징 기법에서는 유효/무효 비트를 두어 각 페이지가 메모리에 존재하는지 표시하게 됩니다.</li>
  </ul>
</details>

<details>
  <summary> page fault가 일어났을때 어떤 일이 생기나요?</summary>
  <ul>
    <li> CPU가 무효 비트로 표시된 페이지에 엑세스하는 상황을 페이지 폴트라고 합니다. 접근하게 되면 주소 변환을 담당하는 하드웨어인 MMU(Memory Management Unit)가 page fault trap을 발생시키게 됩니다. 이후 커널에서 트랩을 받아 디스크에서 페이지 N을 빈 프레임에 적재하고 페이지 테이블을 업데이트하는 과정을 거칩니다.</li>
  </ul>
</details>

<details>
  <summary> 메모리가 꽉찼는데, page fault가 발생하면 어떻게 되나요?</summary>
  <ul>
    <li> 메모리에 올라와있는 페이지를 디스크로 옮겨 메모리 공간을 확보해야합니다. 이것을 페이지 교체라고 하고, 어떤 페이지를 교체할 것이냐를 결정하는 알고리즘이 페이지 교체 알고리즘입니다. </li>
  </ul>
</details>

<details>
  <summary> 페이지 교체 알고리즘에 대해 아는대로 설명해주세요</summary>
  <ul>
    <li> FIFO, 최적 페이지 교체, LRU, LFU, MFU, NUR 등이 있습니다. </li>
  </ul>
</details>

<details>
  <summary> LFU, LRU 알고리즘을 비교해서 설명해주세요</summary>
  <ul>
    <li> LRU는 Least Recently Used의 약자로, 가장 오래전에 참조가 이루어진 페이지를 교체합니다. </li>
    <li> LFU는 Least Frequently Used의 약자로, 물리 메모리 내에 존재하는 페이지 중에서 지금까지의 참조횟수가 가장 적은 페이지를 교체합니다. </li>
  </ul>
</details>

<details>
  <summary> Trashing이 뭐야? </summary>
  <ul>
    <li> 프로세스가 실제 작업을 거의 수행하지 못하고 대부분의 시간을 페이지 교체에 소비하는 상태를 의미합니다. 시스템의 물리 메모리가 부족하거나 동시에 실행되는 프로세스 수가 지나치게 많아서 각 프로세스에 할당되는 프레임 수가 working set보다 작아지는 상황이 발생하면 page fault가 급격하게 증가합니다. 이때 운영체제는 끈임없이 디스크에서 페이지를 가져오고 기존 페이지를 내보내는 작업을 반복하게 되는데, cpu가 실제 연산보다 I/O 대기와 페이지 교체 작업에 대부분의 시간을 사용하게 되는 현상입니다.</li>
    <li> 이를 방지하기 위해서는 프로세스를 줄여 멀티 프로그래밍 정도를 낮추거나 working set model을 적용해 필요한 페이지 집합을 메모리에 유지하거나, 물리메모리를 증설하는등으로 해결할 수 있습니다. 또한 운영체제는 이 현상을 방지하기 위해 working set 기반의 메모리 관리 정책과 page fault 빈도 제어 기법을 사용합니다.</li>
  </ul>
</details>


