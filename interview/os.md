# CS 면접을 위한 OS 질문리스트

## System Call

<details>
  <summary>시스템 콜이 무엇인가요?</summary>
  <ul>
    <li> 시스템 콜은 운영체제(OS)가 제공하는 서비스에 접근하기 위한 유일하고 공식적인 통로(인터페이스)입니다.</li>
    <li> 사용자 프로그램(애플리케이션)이 운영체제의 핵심 기능이나 자원을 사용하고 싶을 때, OS 커널에게 요청을 전달하는 메커니즘</li>
  </ul>
</details>

<details>
  <summary>시스템 콜이 왜 필요한가요?</summary>
  <ul>
    <li> CPU는 일반적으로 커널모드와 유저 모드 두가지로 동작합니다.</li>
    <li> 파일을 읽거나 네트워크에 접속하는 등의 중요한 작업은 하드웨어(자원)에 직접 접근해야 하므로 커널 모드에서만 수행될 수 있습니다. 사용자 모드의 프로그램이 직접 하드웨어에 접근하는 것을 허용하면 시스템 충돌이나 보안 문제가 발생할 수 있습니다. 따라서, 사용자 프로그램은 직접 커널의 자원에 접근하는 대신, 
      시스템 콜이라는 공식적인 절차를 통해 커널에게 대리 실행을 요청하는 것입니다.</li>
  </ul>
</details>

<details>
  <summary>우리가 사용하는 시스템 콜의 예시에는 무엇이 있을까요?</summary>
  <ul>
    <li> 파일 관리에서 open, read, write, close등의 작업이 있고, 프로세스 fork, exec 실행, exit 등이 있습니다. </li>
    <li> 이 외에도 입출력 장치에서의 read, write, 통신할 때의 socket, connect, accept 등이 있습니다. </li>
  </ul>
</details>

<details>
  <summary>시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해주세요.</summary>
  <ul>
    <li> 시스템 콜은 사용자 모드에서 커널 모드로 전환하여 서비스를 요청하는 과정입니다. </li>
    <li> 애플리케이션은 먼저 필요한 인수를 레지스터나 스택에 준비합니다. 이후 프로그램이 시스템 콜 함수를 호출하면, 소프트웨어의 인터럽트인 트랩을 발생시킵니다.
    트랩은 CPU를 사용자 모드에서 커널 모드로 강제 전환 시키고, 커널은 해당 서비스의 로직을 수행하며 필요한 작업을 수행합니다. 이후 작업이 완료되었다면
    커널은 CPU를 다시 사용자 모드로 전환하고, 결과를 사용자 프로그램에 반환하며 원래 실행지점으로 복귀합니다.</li>
  </ul>
</details>

<details>
  <summary>시스템 콜의 유형에 대해 설명해주세요</summary>
  <ul>
    <li> 프로그램의 실행 환경을 관리하고 제어하는 데 사용하는 프로세스 제어  </li>
    <li> 컴퓨터의 영구 저장소에 있는 파일들을 생성, 접근, 수정하는 데 사용되는 파일 관리</li>
    <li> CPU와 메모리를 제외한 모든 입출력 장치(I/O Device)를 제어하고 접근하는 데 사용되는 장치 관리</li>
    <li> OS 자체나 실행 환경에 대한 정보를 얻거나 설정하는 데 사용되는 정보 관리 (time() 등)</li>
    <li> 서로 독립적인 프로세스들이 정보를 교환할 수 있도록 통신 경로를 설정하고 관리하는 통신 (메시지 전달, 네트워크 통신, 공유 메모리 등)</li>
  </ul>
</details>

<details>
  <summary>운영체제의 Dual Mode 에 대해 설명해주세요.</summary>
  <ul>
    <li> 듀얼 모드(Dual Mode)는 운영체제(OS)가 시스템의 안전성과 신뢰성을 보장하기 위해 CPU의 실행 권한을 두 가지 레벨로 나누어 관리하는 핵심적인 보호 메커니즘입니다. </li>
    <li> 커널모드는 모든 특권 명령어와 하드웨어 자원에 직접 접근 가능한 최고 권한을 가진 모드입니다.</li>
    <li> 유저 모드는 특권 명령 실행이 금지되며, 자원에 접근하려면 OS에게 시스템 콜을 요청해야 합니다.</li>
  </ul>
</details>

<details>
  <summary>왜 유저모드와 커널모드를 구분해야 하나요?</summary>
  <ul>
    <li> 듀얼 모드는 시스템의 보호(Protection)를 위해 필수적입니다. 시스템 안정성과 자원 관리의 일관성 측면에서, </li>
    <li> 사용자 모드 프로그램에서 발생한 오류나 무한 루프가 시스템의 핵심 자원이나 다른 프로그램에 영향을 미치는 것을 원천적으로 차단하고,
    디스크 I/O나 메모리 관리 같은 중요한 작업은 커널 모드에서만 수행되도록 강제하여, 모든 자원 할당 및 회수 과정을 OS가 통제하고 일관성을 유지하게 합니다.</li>
  </ul>
</details>

<details>
  <summary>서로 다른 시스템 콜을 어떻게 구분할 수 있을까요? </summary>
  <ul>
    <li> 운영체제(OS)가 수많은 시스템 콜(System Call)을 서로 구분하고 어떤 서비스를 요청받았는지 정확히 식별하는 방식은 주로 시스템 콜 번호(System Call Number) 또는 인덱스를 이용하는 것입니다. </li>
    <li> 시스템 콜 번호는 OS가 각 시스템콜 함수에 고유한 ID를 미리 할당하고, 요청시 이 번호와 필요한 정보를 같이 요청하도록 하는 방식입니다. </li>
    <li> 이렇게 받은 번호를 시스템 콜 테이블에서 해당 함수의 주소를 조회하여 매칭하고, 실행합니다.  </li>
  </ul>
</details>


## 인터럽트
<details>
  <summary>인터럽트에 대해 설명해주세요 </summary>
  <ul>
    <li> 인터럽트란 CPU(중앙처리장치)가 현재 실행하고 있는 프로그램의 정상적인 흐름을 중단시키고, 시스템 내부에 발생한 사건(이벤트)을 처리할 수 있도록 운영체제(OS) 커널에게 제어권을 넘겨주는 메커니즘을 말합니다. </li>
    <li> 이는 CPU가 외부 장치(키보드, 디스크 등)나 프로그램 자체로부터 발생하는 비동기적 또는 동기적 요청에 대해 즉각적으로 반응하여 시스템을 효율적이고 안정적으로 관리하게 해줍니다. </li>
  </ul>
</details>

<details>
  <summary>인터럽트는 어떻게 처리하나요? </summary>
  <ul>
    <li> I/O 작업이나 시스템 콜, 예외 등에 의해서 인터럽트가 발생하면, 인터럽트 컨트롤러가 이 신호를 CPU에 전달합니다.CPU는 현재 실행되던 명령을 수행한 직후 커널모드로 전환하고 처리를 시작합니다. </li>
    <li> CPU는 현재 실행 중이던 프로세스의 문맥(Context), 즉 현재 상태를 안전하게 보존해야 합니다. 프로그램 카운터(PC)와 CPU 레지스터의 값들을 PCB에 저장합니다. 이후 인터럽트를 식별하고 서비스 루틴을 호출하는 과정을 거칩니다. </li>
    <li> ISR(Interrupt Service Routine)이 인터럽트 유형에 따라 작업을 완료하고, 인터럽트를 해제합니다. 이후 저장해놓았던 context를 복구하며, CPU를 사용자 모드로 전환시켜 실행을 재개합니다.</li>
  </ul>
</details>

<details>
  <summary> polling에 대해 설명해주세요 </summary>
  <ul>
    <li> 폴링(Polling) 방식은 CPU가 입출력(I/O) 장치의 상태를 주기적으로 직접 확인하여 장치의 작업 완료 여부를 파악하는 방식입니다. </li>
    <li> CPU가 반복적인 루프를 돌면서 I/O 장치의 상태 레지스터(Status Register) 값을 읽어와, 완료되었으면 데이터를 처리하고 아니면 계속 폴링을 지속하거나 다른 작업을 수행합니다. </li>
    <li> 장점으로는 구현이 간단하고, 하드웨어적인 복잡성이 낮습니다. 인터럽트 컨트롤러가 없는 매우 단순한 시스템에서 사용될 수 있습니다.</li>
    <li> 단점으로는 CPU 이용 효율이 낮습니다. CPU가 I/O 장치의 상태를 확인하는 데 대부분의 시간을 소비하게 되어, 실제 유용한 작업을 수행할 시간이 줄어듭니다. 이는 CPU 사이클 낭비로 이어집니다.</li>
    <li> 또한 중요한 이벤트가 발생하더라도, CPU가 해당 장치를 폴링하는 주기까지 기다려야 하므로 응답 시간이 지연될 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary> 인터럽트와 polling의 차이점은? </summary>
  <ul>
    <li> 인터럽트는 주도권이 I/O 장치에 있습니다. 장치에서 작업이 완료될 때 까지 CPU는 기다리지 않고 다른 작업을 수행하고 있다가, 완료 신호를 받으면 그때 해당 작업을 처리할 수 있습니다. 따라서 CPU의 사용 효율성이 높고 응답시간이 빠르다는 장점이 있습니다. </li>
    <li> 폴링은 주도권이 CPU에 있습니다. 장치에서 작업이 완료 되었는지 여부를 CPU에서 지속적으로 장치에 신호를 보내 확인합니다. 구현이 간단하지만 CPU의 효율성이 떨어지고 응답 시간이 지연될 수 있는 문제가 있습니다. </li>
  </ul>
</details>

<details>
  <summary> HW/SW 인터럽트에 대해 설명해주세요 </summary>
  <ul>
    <li> 하드웨어 인터럽트는 CPU 외부의 장치나 하드웨어적인 사건으로 인해 발생하며, 주로 비동기적으로 발생합니다. 키보드, 마우스, 디스크 드라이브, 타이머, 네트워크 카드 등 I/O 장치이 주체이며, 자신의 작업 완료 여부를 알리기 위해 발생시킵니다.</li>
    <li> 소프트웨어 인터럽트는 실행 중인 프로그램 내부의 명령어나 논리적 문제 때문에 발생하며, 주로 동기적으로 발생합니다. 실행 중인 CPU 명령어 자체나 프로그램의 논리적 오류입니다. 주로 트랩이나 예외에 의해 발생합니다. </li>
  </ul>
</details>


## Process & Thread

<details>
  <summary>프로세스에 대해 설명해주세요</summary>
  <ul>
    <li> 실행파일 형태로 존재하던 프로그램이, 메모리에 적재되어 CPU를 할당받아 실행되는 것을 프로세스 라고 합니다.</li>
    <li> 사전적 의미: 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램</li>
  </ul>
</details>

<details>
  <summary>process의 memory영역에 대해서 설명해 주세요.</summary>
  <ul>
    <li> 실행파일 형태로 존재하던 프로그램이, 메모리에 적재되어 CPU를 할당받아 실행되는 것을 프로세스 라고 합니다.</li>
    <li> code 영역은 실행한 프로그램의 코드가 저장되는 메모리 영역입니다.</li>
    <li> data 영역은 프로그램의 전역 변수와 static 변수가 저장되는 메모리 영역입니다.</li>
    <li> heap 영역은 프로그래머가 직접 공간을 할당(malloc)/해제(free) 하는 메모리 영역입니다.</li>
    <li> stack 영역은 함수 호출 시 생성되는 지역 변수와 매개 변수가 저장되는 임시 메모리 영역입니다.</li>
  </ul>
</details>

<details>
  <summary>스레드에 대해 설명해주세요</summary>
  <ul>
    <li> thread는 한 process 내에서 실행되는 동작(기능 function)의 단위입니다. 각 thread는 속해있는 process의 Stack 메모리를 제외한 나머지 memory 영역을 공유할 수 있습니다.</li>
    <li> 사전적 의미: 프로세스 내에서 실행되는 여러 흐름의 단위. 프로세스가 할당받은 자원을 이용하는 실행의 단위</li>
  </ul>
</details>

