# CS 면접을 위한 Spring 질문 리스트

<details>
  <summary>스프링이란 무엇인가요?</summary>
  <ul>
    <li> 자바의 오픈소스 애플리케이션 프레임워크 중 하나로 스프링의 기본 철학은 특정 기술에 종속되지 않고 객체를 관리할 수 있는 프레임워크를 제공하는 것입니다. 그래서 컨테이너로 자바 객체를 관리하면서 의존성 주입과 제어의 역전을 통해 결합도를 낮추게 됩니다.</li>
  </ul>
</details>

<details>
  <summary>라이브러리와 프레임워크의 차이는 뭔가요?</summary>
  <ul>
    <li> IOC의 개념이 적용되엇는지가 핵심 차이점입니다. 라이브러리를 사용하는 코드는 흐름을 직접 제어하고 피룡한 기능이 있을때 능동적으로 사용합니다. 반면 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용됩니다. 프레임워크 위해 개발한 클래스를 등록해두고 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식입니다.</li>
  </ul>
</details>

<details>
  <summary>스프링과 스프링 mvc, 스프링 boot는 차이점이 뭔가요?</summary>
  <ul>
    <li> 스프링은 DI와 AOP 등을 제공하는 핵심 프레임워크로, 객체 관리와 트랜잭션 같은 기반 기능을 제공합니다. 스프링 MVC는 그 위에서 동작하는 웹 프레임워크로, HTTP 요청을 컨트롤러에 매핑하고 view 또는 rest api 응답을 만드는 역할을 담당합니다. 스프링 부트는 스프링과 스프링 mvc를 더 빠르고 쉽게 사용하기 위한 실행 플랫폼으로, 자동 설정, 내장 서버, 스타터 의존성, 내장 톰캣 등을 제공해 설정에 드는 비용을 줄여줍니다.</li>
  </ul>
</details>

<details>
  <summary>스프링 서버에 API 요청이 오면 어떻게 동작하나요?</summary>
  <ul>
    <li> 클라이언트가 HTTP 요청을 보내면 스프링의 DispatcherServlet이 이를 가장 먼저 수신합니다. 서블릿은 프론트 컨트롤러로서 요청 URL에 매핑된 컨트롤러 메서드를 HandlerMapping을 통해 찾습니다. 이후 핸들러 어댑터가 해당 메서드를 호출해 요청을 처리하고 생성된 응답을 다시 디스패처서블릿이 클라이언트로 반환합니다.</li>
  </ul>
</details>

<details>
  <summary>스프링 MVC의 라이프 사이클에 대해 알고있나요?</summary>
  <ul>
    <li> Filter -> DispatcherServlet -> HandlerMapping -> HandlerInterceptor -> controller -> Service -> Repository -> ViewResolver 순으로 진행되게 됩니다. </li>
  </ul>
</details>

<details>
  <summary>스프링 프레임 워크의 탄생 배경에 대해 설명해주세요</summary>
  <ul>
    <li> 초기 서버사이드 처리는 직접 스레드, 소켓 연결등 개발자들이 직접 처리하는게 많았고 개발자마다 구현하는 방법이 다 달라 협업에 불편함이 많았습니다. 이런 개발 표준을 잡기 위해 java EE였습니다. 하지만 너무 무겁고 설정이 복잡했고 이것도 구현방법이 여러 방법으로 나뉘었습니다. 그래서 프레임워크라는 개념이 등장하게 되었습니다. 자바 진영에서는 EJB라는것이 나왔지만 분산환경 처리에 특화된 EJB 또한 무겁고 불편한점이 많았고, EJB에 반기를 들고 탄생한 경량화된 자바 엔터프라이즈용 프레임워크가 스프링이였습니다. </li>
  </ul>
</details>

<details>
  <summary>스프링을 그럼 왜 사용하는건가요?</summary>
  <ul>
    <li> 스프링은 프레임워크이고, 프레임워크는 개발자들이 좀더 쉽고 편리하게 개발할 수 있도록 미리 갖춰진 구조를 말합니다. 프레임워크가 없다면 개발자가 처음부터 끝까지 모든 구조를 만들어야 하고 그렇게 만들어진 프로그램의 성능은 개발자의 역량에 많이 좌우되게 될것입니다. 스프링은 애플리케이션 개발에 필요한 하부 구조를 포괄적으로 제공해 개발자들이 핵심 비즈니스 로직에만 집중할수 있도록 하여 생산성이 향상이 될 수 있고 일정수준의 성능과 안정성을 보장하게 됩니다. </li>
  </ul>
</details>

<details>
  <summary>Dependency Injection은 무엇인가요?</summary>
  <ul>
    <li> 객체간의 의존관계를 미리 설정해두면 스프링 컨테이너가 의존관계를 연결해줍니다. 이렇게 되면 직접 의존하는 객체를 생성하거나 검색해서 가져올 필요가 없어 결합도가 낮아지는 장점이 있습니다.</li>
  </ul>
</details>

<details>
  <summary>IOC는 무엇인가요?</summary>
  <ul>
    <li> Inversion of Control의 약자로 제어의 역전을 의미합니다. 제어권이 사용자에게 있지 않고 프레임워크에 있어서 필요에 따라서 사용자의 코드를 호출하게 됩니다. 스프링에서는 인스턴스의 생성부터 소멸까지 개발자가 아닌 컨테이너에서 대신 관리하게 됩니다. </li>
  </ul>
</details>

<details>
  <summary>ORM은 무엇인가요?</summary>
  <ul>
    <li> Object Relational Mapping의 약자로 관계형 데이터베이스를 OOP(객체지향 프로그래밍)언어로 변환해주는 기술입니다. 그래서 비즈니스 코드가 DB 테이블에 바로 접근하게 도와줍니다. </li>
  </ul>
</details>

<details>
  <summary>JPA가 뭔가요?</summary>
  <ul>
    <li> JPA는 ORM을 위해서 자바에서 제공하는 API 입니다. 자바 객체와 DB 테이블을 매핑하는데 구현체에는 하이버네이트가 있습니다. </li>
  </ul>
</details>

<details>
  <summary>ORM, JPA, Hibernate의 장단점은 뭔가요?</summary>
  <ul>
    <li> 비즈니스 로직에 집중하고 객체 중심의 개발을 하게 도와줍니다. 메소드를 호출하는 것만으로 쿼리를 수행해서 생산성이 향상되고 유지보수 비용이 줄어들며, 특정 DB에 의존하지 않게됩니다. 단점으로는 직접 SQL을 호출하는것보다 오버헤드가 있으며 복잡한 쿼리같은것은 메소드로 처리가 힘들다는 단점이 있습니다.</li>
  </ul>
</details>

<details>
  <summary>필터와 인터셉터에 대해 설명해주세요</summary>
  <ul>
    <li> 필터는 디스패처 서블릿에 요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 대해 부가작업을 처리할 수 있는 기능을 제공합니다. 즉, 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너(서블릿 컨테이너)에 의해 관리가 되는것이고 디스패처 서블릿 전/후에 처리하는것입니다. </li>
    <li> 인터셉터는 필터와 다르게 스프링이 제공하는 기술로서, 디스패처 서블릿이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공합니다. 즉 웹 컨테이너에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작합니다. </li>
  </ul>
</details>

<details>
  <summary>필터와 인터셉터는 언제 사용하면 좋을까요?</summary>
  <ul>
    <li> 필터는 xss/방어 및 인증/인가 관련 작업, 모든 요청에 대한 로깅 또는 감사, 이미지/데이터 압축 및 문자열 인코딩, 스프링과 분리되어야 하는 기능 용도로 사용합니다. 또한 request/response 객체를 조작할 필요가 있을때 사용합니다. </li>
    <li>  인터셉터는 세부적인 보안 및 인증/인가 공통 작업, API 호출에 대한 로깅 또는 감사, Controller로 넘겨주는 정보의 가공 시 사용합니다. Request와 response를 조작할 수 없으며 스프링 예외처리도 불가능합니다.</li>
  </ul>
</details>

<details>
  <summary>AOP는 뭔가요?</summary>
  <ul>
    <li> 로깅, 트랜잭션 등 핵심 비즈니스 로직과 별개의 횡단 관심사를 모듈화 하는 프로그래밍 기법입니다. 스프링에서 AOP는 프록시를 기반으로 구현하며, 프록시가 메서드를 가로채 Advice를 실행하고 이후 실제 메서드를 호출합니다. Pointcut으로 어떤 메서드에 적용할지 정하고 Advice를 언제 실행할지 정합니다. Aspect, JoinPoint, Advice, PointCut 등의 개념을 통해 처리됩니다.</li>
    <li> Aspect는 부가 기능 모듈을 뜻합니다. 공통 관심사를 하나의 모듈로 만들어 두며, @Aspect 클래스나 어드바이스 + 포인트 컷을 모듈화 한것을 지칭합니다.</li>
    <li> Advice는 aspect 내부에서 언제, 어떤 공통 로직을 실행할지 정의한 코드입니다. Around(주변), Before(전), After(후)와 같은 다양한 종류의 어드바이스가 존재합니다. </li>
    <li>포인트 컷은 조인 포인트 중에서 어드바이스가 적용될 위치를 선별하는 기능입니다.</li>
    <li>Advisor는 하나의 어드바이스와 하나의 포인트컷으로 구성되며, 스프링 AOP에서만 사용되는 특별 용어입니다.</li>
    <li>조인 포인트는 어드바이스가 적용될 수 있는 지점, 즉 가로챌 수 있는 모든 지점을 뜻합니다. 스프링 AOP에서는 메서드 실행 지점만 조인 포인트가 됩니다. </li>
    <li>위빙은 Aspect를 타겟 코드에 적용하는 과정을 의미하며, 컴파일 타임, 로드 타임, 런타임 세종류로 나눌 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary>OOP로 할 수도 있는데 왜 AOP를 사용하나요? 차이점은 뭔가요?</summary>
  <ul>
    <li> OOP로도 공통 로직을 넣을 수 있지만 로깅,트랜잭션과 같이 여러 서비스를 가로지는 공통 관심사들은 OOP만으로 처리하면 코드 중복과 관심사가 분리되지 않는 현상이 발생하기 쉽다고 생각합니다. 예를들어 모든 서비스 마다 실행 시간 로깅과 같은 기능을 넣으면 비슷한 코드가 들어가게 되고 하나를 수정하려고 하면 전체가 다 수정되어야 합니다.</li>
    <li> AOP는 이런 공통 관심사를 별도의 Aspect로 분리해서 어떤 메서드 앞뒤에 이 로직을 끼워 넣을지 선언적으로 지정할 수 있기 때문에, 비즈니스 로직은 핵심 도메인 로직만 남기고, 공통 기능은 한군데서 관리할 수 있다는 장점이 있습니다.</li>
  </ul>
</details>

<details>
  <summary>AOP 적용 방식에 대해 설명해주세요</summary>
  <ul>
    <li> AOP 적용 방식은 크게 컴파일 시점, 클래스 로딩 시점, 런타임으로 나눌 수 있습니다. 컴파일 시점은 AspectJ 컴파일러가 .java → .class로 변환하는 과정에서 부가 기능을 직접 바이트코드에 삽입합니다. 매우 빠르고 강력하지만 개발 환경이 복잡해서 잘 사용하지 않습니다. 클래스 로딩 시점은 JVM이 클래스 파일을 로딩할 때 Instrumentation API나 AspectJ LTW를 통해 바이트코드를 조작하는 방식으로, 모니터링/프로파일링 툴들이 많이 사용합니다. Spring AOP는 런타임 방식으로, 컴파일 또는 로딩 시점을 건드리지 않고, 스프링이 bean을 생성할 때 프록시를 만들어 메서드 호출을 가로채고 Advice를 실행하는 방식으로 작동합니다. 스프링이 기본적으로 프록시 기반 런타임 AOP를 사용하는 이유는 설정이 단순하고 안정적이기 때문입니다.</li>
  </ul>
</details>

<details>
  <summary>AOP는 어떻게 동작하나요?</summary>
  <ul>
    <li> 스프링 AOP는 프록시 기반으로 동작합니다. 원본 객체를 수정하는 것이 아니라, 스프링이 빈을 생성할 때 원본 객체를 감싸는 프록시 객체를 대신 등록해서 그 프록시가 메서드 호출 전후로 공통 로직을 삽입하는 방식입니다. Transactional이나 Aspect와 같은 AOP 관련 어노테이션을 스캔하면 AbstractAutoProxyCreatro 계열의 BeanPostProcessor가 동작해서 원본 빈 대신 프록시 빈을 IoC컨테이너에 등록합니다. 클라이언트가 서비스 메서드를 호출하면 프록시가 먼저 호출을 인터셉트하고, 등록된 메서드 인터셉들을 어드바이스 순서에 따라 수행한 뒤 원본 메서드를 호출합니다. 인터페이스가 있다면 JDK Proxy, 없다면 CGLIB을 사용해 바이트 코드를 생성합니다. </li>
    <li> 즉 AOP는 Aspect라는 공통 관심사 묶음을 만들어 두고, Advice로 실제 실행될 코드를 정의한 뒤 Pointcut으로 어떤 메서드에 적용할지를 선택하는 구조입니다. Join Point는 Advice가 적용될 수 있는 지점이고, Proxy가 Target 객체를 감싸서 메서드 호출을 가로채 Advice를 실행합니다. 이 모든 적용 과정을 Weaving이라고 부릅니다.</li>
  </ul>
</details>

<details>
  <summary>Spring은 AOP 프록시 객체를 어떻게 만드나요?</summary>
  <ul>
    <li> 스프링은 AOP를 적용하기 위해 빈 생성 과정에서 AbstractAutoProxyCreator가 빈을 검사하여 AOP 대상인지 확인하고, 대상이라고 판단되면 ProxyFactory를 사용해 Dynamix Proxy Bean을 생성하고, 원본 빈 대신 이 프록시 빈을 IoC 컨테이너에 등록합니다. 인터페이스가 있으면 JDK 프록시, 없으면 CGLIB 프록시를 사용하며 클라이언트의 모든 호출은 프록시를 거쳐 어드바이스가 실행됩니다.</li>
  </ul>
</details>

<details>
  <summary>JDK Proxy vs CGLIB 차이</summary>
  <ul>
    <li> 인터페이스가 있으면 JDK Dynamic Proxy, 클래스만 있으면 CGLIB이 사용됩니다. JDK 프록시는 인터페이스 기반이고 자바 기능입니다. 인터페이스 메서드만 프록시만 가능하며 빠르고 가볍습니다. CGLIB은 클래스 상속 기반이고, 인터페이스 없이도 프록시 생성이 가능합니다. private나final 메서드는 오버라이드 못하고, 프록시 클래스 바이트 코드를 생성합니다. </li>
  </ul>
</details>

<details>
  <summary>Spring은 AOP에서 private 메서드, final 메소드 및 클래스, static 메소드, 내부 호출, 생성자에 aop가 적용되지 않는 이유가 뭔가요?</summary>
  <ul>
    <li> private 메서드는 외부에서 호출이 불가능한 메서드이기 때문입니다. 프록시는 외부에서 들어오는 메서드 호출을 가로채는 객체입니다. 그런데 private는 TargetBean 외부 객체인 프록시에서 호출할 수 없기 때문입니다. </li>
    <li> final 메서드나 클래스에 안되는 이유는, 프록시는 상속 후 오버라이드 방식으로 동작합니다. 그런데 final 메서드는 오버라이드가 안되고, final 클래스는 상속이 금지됩니다. 따라서 프록시 클래스를 만들 수 없습니다.</li>
    <li> static 메서드가 안되는 이유는, AOP는 인스턴스 메서드 호출을 가로채는 구조인데, static메서드는 클래스 단위로 호출을 하거나 인스턴스 없이 호출되기 때문입니다. 따라서 인스턴스 호출이 아니기 때문에 프록시가 개입할 구조가 없습니다.</li>
    <li> 내부 호출 (this.method())가 안되는 이유는, 스프링 IoC에 등록하는 빈은 프록시 빈입니다. 그런데 클래스 내부에서 호출을 하게 되면, 외부 호출은 프록시를 거치지만 내부 호출은 프록시를 안거치고 메서드를 직접 호출되게 되기 때문입니다.</li>
    <li> Spring AOP는 원본 Bean을 컨테이너에 등록하지 않고, 원본 Bean을 감싼 Proxy Bean을 IoC 컨테이너에 등록합니다. 프록시 내부에 실제 Target 객체가 필드로 저장되어 있고, 외부 모든 호출은 ProxyBean을 거쳐서 TargetBean을 실행합니다. 내부 호출(this.method)은 TargetBean 내부에서 이루어지기 때문에 프록시를 거치지 않아 AOP 적용이 안 됩니다.</li>
  </ul>
</details>


<details>
  <summary>@Autowired에 대해 설명해주세요 </summary>
  <ul>
    <li> Spring 프레임워크에서 의존성 주입을 자동으로 수행하는데 사용됩니다. 개발자가 별도로 객체를 생성하거나 초기화할 필요 없이 스프링이 자동으로 필요한 빈을 찾아 주입합니다. 생성자, 세터 메서드, 필드에 적용할 수 있으며 주로 다른 빈의 참조를 주입할 때 사용됩니다.</li>
  </ul>
</details>

<details>
  <summary>생성자를 주입해주는 다른 어노테이션이 있나요? </summary>
  <ul>
    <li> Autowired 외에도 Inject, Resource 어노테이션이 있습니다. 오토와이어드는 스프링에서 지원하며 타입에 맞춰 연결합니다. inject는 자바에서 지원하며 타입에 맞춰 연결해줍니다. resource도 자바에서 지원하며 이름 기반으로 연결해줍니다. 타입 기반이여도 @qualifier을 통해 타입 이외의 방법으로 연결할 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary>생성자 주입과 Autowired를 비교해서 설명해주세요 </summary>
  <ul>
    <li> 생성자 주입은 의존성을 명확하게 드러내고 필수 의존성을 누락없이 주입할 수 있으며, 불변성을 보장하고 테스트 용이성이 높습니다. 순환 의존성을 조기에 발견(컨테이너가 빈을 생성하는 시점에 객체 생성 사이클 감지)할 수 있기때문에 스프링에서 가장 권장하는 방식입니다. 하지만 Autowired를 필드에 쓰는 방식은 테스트가 어렵고 변경 가능성이 있어 지양합니다.</li>
  </ul>
</details>

<details>
  <summary> Autowired와 RequiredArgsConstruct를 사용하는것의 차이점은 무엇인가요? </summary>
  <ul>
    <li> Autowired를 생성자에 사용하면 스프링이 해당 생성에 필요한 의존성을 자동으로 주입해줍니다. 이와 유사하게 RequiredArgsConstruct는 lombok 라이브러리에서 제공하는 어노테이션으로, 클래스 내 모든 final 필드와 notnull이 적용된 필드에 대해 생성자를 자동으로 생성합니다.</li>
    <li> 주요한 차이점은 RequiredArgsConstruct는 lombok 라이브러리를 사용해 코드의 간결함을 유지하고, 불필요한 보일러플레이트 코드를 줄여준다는 장점이 있습니다. Autowired는 스프링에서 제공하며 lombok을 사용하지 않을때 의존성 주입을 위해 활용됩니다.  </li>
  </ul>
</details>

<details>
  <summary> 보일러플레이트 코드가 뭔가요? </summary>
  <ul>
    <li> 소프트웨어 개발에서 반복적으로 작성해야하는, 하지만 비즈니스 코드와 직접적으로 관련이 없는 코드를 의미합니다.  </li>
  </ul>
</details>

<details>
  <summary> 스프링 컨테이너는 뭔가요? </summary>
  <ul>
    <li> 스프링 컨테이너는 객체를 생성하고, 의존성을 주입하며 생명주기를 관리하는 핵심 엔진입니다. ApplicationContext가 대표적인 컨테이너로, 빈 스캔,DI, AOP 프록시 생성, 환경설정, 이벤트 처리 등 스프링 애플리케이션의 모든 기반 동작을 담당합니다. 개발자가 객체 생성과 관리에서 벗어나 비즈니스 로직에 집중할 수 있도록 도와주는 것이 컨테이너의 역할입니다.</li>
  </ul>
</details>

<details>
  <summary> 스프링 컨테이너의 구성에 대해 설명해주세요 </summary>
  <ul>
    <li> 스프링 애플리케이션은 ApplicationContext라는 컨테이너를 통해 빈을 생성하고 의존성을 관리합니다. Spring MVC 환경에서는 보통 컨테이너가 두 계층으로 구성됩니다. Root ApplicationContext는 Service, Repository 같은 전역 빈을 관리하고,DispatcherServlet WebApplicationContext는Controller, HandlerMapping 같은 웹 계층 빈을 관리하는 자식 컨텍스트입니다.</li>
    <li> 자식 컨텍스트는 부모 빈을 조회할 수 있어 컨트롤러에서 서비스를 주입받을 수 있지만, 반대로 서비스가 컨트롤러를 주입받는 것은 구조적으로 불가능합니다.</li>
  </ul>1
</details>

<details>
  <summary>스프링에서 빈은 무엇인가요? </summary>
  <ul>
    <li> Spring 프레임워크에서 관리되는 객체를 의미합니다. 스프링 컨테이너에 의해 생성되고 관리되며, 필요할 때마다 주입되는 자바 객체입니다. 빈은 스프링의 IOC 컨테이너에 의해 생명주기가 관리되며, 애플리에이션 내에서 다양한 기능을 수행합니다. 스프링 빈은 기본적으로 싱글톤 패턴으로 스프링 컨테이너 내에서 동일한 타입의 빈은 하나만 생성됩니다. 또한 빈은 다른 빈들간의 의존성을 관리하여 객체간의 결합도를 낮추고 모듈성을 높힐 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary>스프링 빈의 생명주기에 대해 설명해주세요 </summary>
  <ul>
    <li> 스프링 빈의 생명주기는 컨테이너가 생성된 후 빈 생성 -> 의존성 주입 -> 초기화 -> 사용 -> 소멸 순으로 진행됩니다. 빈의 초기화는 @postconstruct 어노테이션을 사용하거나 afterPropertiesSet() 메서드를 오버라이드하거나 커스텀 init() 메소드를 정의하는 방식으로 동작합니다. 빈의 소멸은 @predestroy 어노테이션을 사용하거나 DisposableBean을 오버라이드하거나 커스텀 destroy-method를 정의하여 소멸시킬 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary>스프링 빈의 스코프에 대해 설명해주세요</summary>
  <ul>
    <li> 스프링 빈 스코프랑 스프링이 빈을 어떤 범위로 생성하고 관리할지 결정하는 설정입니다. 빈이 언제 생성되고 언제까지 살아있는지를 정의하는 개념입니다. 기본적으로 스프링은 싱글톤 스코프를 사용해 컨테이너당 하나의 인스턴스를 관리합니다. 그 외에도 요청할 때마다 새로운 빈을 만드는 프로토타입 스코프, HTTP 요청마다 한개씩 생성되는 request 스코프, 세션 단위로 유지되는 세션 스코프, 애플리케이션 전체에서 공유되는 애플리케이션 스코프가 있습니다. 비즈니스 로직은 대부분 싱글톤을 사용하고, 요청/세션 같은 웹 컨텍스트가 필요한 경우 request/session 스코프를 사용합니다.</li>
  </ul>
</details>

<details>
  <summary>결합도를 낮추는게 왜 좋은가요?</summary>
  <ul>
    <li> 결합도를 낮추면 변경의 영향이 최소화되고 테스트와 확장에 유리하며, 재사용성이 높아지기 때문에 유지보수성과 품질이 크게 올라갑니다. 결합도가 높으면 한 부분의 수정이 전체 시스템을 고쳐야 하는 상황이 발생할 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary>@Transactional 어노테이션의 동작 방식과 트랜잭션 전파 옵션에 대해 설명해주세요</summary>
  <ul>
    <li> 스프링에서는 Transactional 어노테이션을 통해 메서드나 클래스에 트랜잭션 경계를 정의하여 트랜잭션을 관리합니다. 이 어노테이션이 적용된 메서드는 호출 시점에 트랜잭션이 시작되며, 메서드가 정상적으로 완료되면 트랜잭션을 커밋하고 예외가 발생하면 트랜잭션을 롤백합니다. Spring은 이 어노테이션이 붙은 메서드를 AOP 프록시로 감싸서 메서드 실행 전에 트랜잭션을 시작하고, 정상 종료되면 커밋을, 예외가 발생하면 롤백하는 구조로 동작합니다. </li>
    <li> 트랜잭션 전파 옵션은 트랜잭션을 어떻게 처리할지를 지정하는데, 메서드가 호출될때 이미 실행중인 트랜잭션이 있는경우 그 트랜잭션에 어떻게 대응할지를 결정합니다. 기본 전파 옵션은 required로 현재 실행중인 트랜잭션이 있으면 그 트랜잭션에 참여하고 없다면 새 트랜잭션을 생성합니다. 기타 옵션으로는 항상 새 트랜잭션을 생성하는 requireds_new, 트랜잭션이 이미 있으면 참여하고 없으면 비트랜잭션 방식으로 작동하는 supports, 현재 트랜잭션이 있어야만 참여하는 mandatory, 트랜잭션 없이 실행하는 not_supported, 트랜잭션이 있으면 예외를 발생시키는 never 등이 있습니다.</li>
  </ul>
</details>

<details>
  <summary>스프링 트랜잭션에서 롤백이 발생하면 어떤일이 일어나나요?</summary>
  <ul>
    <li> 트랜잭션에 내에서 발생한 모든 변경사항이 취소됩니다. 이를 통해 데이터베이스의 일관성과 무결성이 유지됩니다. 롤백은 스프링 AOP를 통해 구현되며 런타임 오류가 발생하면 자동으로 트랜잭션을 롤백합니다. 또한 트랜잭션 어노테이션의 rollback for 속성을 사용해 특정 예외 발생시 롤백을 명시적으로 사용할 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary>트랜잭션 처리시 자바의 메모리 구조에서 어떤 영역이 영향을 받나요?</summary>
  <ul>
    <li> heap과 스택 영역이 영향을 받습니다. 트랜잭션 중 객체의 상태 변화는 힙에 반영됩니다. 데이터베이스와의 상호작용에서 생성된 엔티티 객체나 서비스 로직에서 변경된 상태가 힙에 저장됩니다. 스택은 메서드 호출 시 사용되며 트랜잭션 처리 중에 메서드 호출의 흐름이나 지역변수가 이곳에 저장됩니다.</li>
  </ul>
</details>

<details>
  <summary>@Async 어노테이션에 대해 설명해주세요</summary>
  <ul>
    <li> @Async는 스프링에서 메서드를 별도의 스레드에서 비동기로 실행할 수 있도록 해주는 기능입니다. 스프링이 해당 메서드를 프록시로 감싸고, 호출 시 TaskExecutor 스레드풀에 작업을 넘겨 비동기적으로 실행합니다. 다만 프록시 기반이라 같은 클래스 내부 호출 시 동작하지 않고, public 메서드만 가능하며, 트랜잭션 범위도 별도 스레드라 주의 해야합니다.</li>
  </ul>
</details>

<details>
  <summary>Tomcat 비동기 MVC vs WebFlux 차이</summary>
  <ul>
    <li> Spring MVC의 비동기 Servlet은 Callable이나 DeferredResult를 사용해 Worker Thread를 빠르게 반환하고 실제 작업은 별도의 스레드에서 실행하는 방식입니다. 이는 스레드 사용 최적화에는 도움이 되지만
I/O 자체는 블로킹이기 때문에 구조적으로는 여전히 스레드 기반 서버입니다. 반면 WebFlux는 Netty 기반의 이벤트 루프 모델을 사용하며 모든 I/O가 논블로킹으로 처리됩니다. EventLoop 스레드 하나가 수백~수천 커넥션을 관리할 수 있고, 블로킹 호출은 반드시 boundedElastic 스레드풀로 분리해야 합니다. 그래서 MVC 비동기는 “스레드 활용 개선”이고, WebFlux는 “아키텍처 자체가 고성능 논블로킹 모델”이라는 차이가 있습니다.</li>
  </ul>
</details>
