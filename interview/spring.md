# CS 면접을 위한 Spring 질문 리스트

<details>
  <summary>스프링이란 무엇인가요?</summary>
  <ul>
    <li> 자바의 오픈소스 애플리케이션 프레임워크 중 하나로 스프링의 기본 철학은 특정 기술에 종속되지 않고 객체를 관리할 수 있는 프레임워크를 제공하는 것입니다. 그래서 컨테이너로 자바 객체를 관리하면서 의존성 주입과 제어의 역전을 통해 결합도를 낮추게 됩니다.</li>
  </ul>
</details>

<details>
  <summary>라이브러리와 프레임워크의 차이는 뭔가요?</summary>
  <ul>
    <li> IOC의 개념이 적용되엇는지가 핵심 차이점입니다. 라이브러리를 사용하는 코드는 흐름을 직접 제어하고 피룡한 기능이 있을때 능동적으로 사용합니다. 반면 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용됩니다. 프레임워크 위해 개발한 클래스를 등록해두고 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식입니다.</li>
  </ul>
</details>

<details>
  <summary>스프링과 스프링 mvc, 스프링 boot는 차이점이 뭔가요?</summary>
  <ul>
    <li> 스프링은 DI와 AOP 등을 제공하는 핵심 프레임워크로, 객체 관리와 트랜잭션 같은 기반 기능을 제공합니다. 스프링 MVC는 그 위에서 동작하는 웹 프레임워크로, HTTP 요청을 컨트롤러에 매핑하고 view 또는 rest api 응답을 만드는 역할을 담당합니다. 스프링 부트는 스프링과 스프링 mvc를 더 빠르고 쉽게 사용하기 위한 실행 플랫폼으로, 자동 설정, 내장 서버, 스타터 의존성, 내장 톰캣 등을 제공해 설정에 드는 비용을 줄여줍니다.</li>
  </ul>
</details>

<details>
  <summary>스프링 서버에 API 요청이 오면 어떻게 동작하나요?</summary>
  <ul>
    <li> 클라이언트가 HTTP 요청을 보내면 스프링의 DispatcherServlet이 이를 가장 먼저 수신합니다. 서블릿은 프론트 컨트롤러로서 요청 URL에 매핑된 컨트롤러 메서드를 HandlerMapping을 통해 찾습니다. 이후 핸들러 어댑터가 해당 메서드를 호출해 요청을 처리하고 생성된 응답을 다시 디스패처서블릿이 클라이언트로 반환합니다.</li>
  </ul>
</details>

<details>
  <summary>스프링 MVC의 라이프 사이클에 대해 알고있나요?</summary>
  <ul>
    <li> Filter -> DispatcherServlet -> HandlerMapping -> HandlerInterceptor -> controller -> Service -> Repository -> ViewResolver 순으로 진행되게 됩니다. </li>
  </ul>
</details>

<details>
  <summary>스프링 프레임 워크의 탄생 배경에 대해 설명해주세요</summary>
  <ul>
    <li> 초기 서버사이드 처리는 직접 스레드, 소켓 연결등 개발자들이 직접 처리하는게 많았고 개발자마다 구현하는 방법이 다 달라 협업에 불편함이 많았습니다. 이런 개발 표준을 잡기 위해 java EE였습니다. 하지만 너무 무겁고 설정이 복잡했고 이것도 구현방법이 여러 방법으로 나뉘었습니다. 그래서 프레임워크라는 개념이 등장하게 되었습니다. 자바 진영에서는 EJB라는것이 나왔지만 분산환경 처리에 특화된 EJB 또한 무겁고 불편한점이 많았고, EJB에 반기를 들고 탄생한 경량화된 자바 엔터프라이즈용 프레임워크가 스프링이였습니다. </li>
  </ul>
</details>

<details>
  <summary>스프링을 그럼 왜 사용하는건가요?</summary>
  <ul>
    <li> 스프링은 프레임워크이고, 프레임워크는 개발자들이 좀더 쉽고 편리하게 개발할 수 있도록 미리 갖춰진 구조를 말합니다. 프레임워크가 없다면 개발자가 처음부터 끝까지 모든 구조를 만들어야 하고 그렇게 만들어진 프로그램의 성능은 개발자의 역량에 많이 좌우되게 될것입니다. 스프링은 애플리케이션 개발에 필요한 하부 구조를 포괄적으로 제공해 개발자들이 핵심 비즈니스 로직에만 집중할수 있도록 하여 생산성이 향상이 될 수 있고 일정수준의 성능과 안정성을 보장하게 됩니다. </li>
  </ul>
</details>

<details>
  <summary>Dependency Injection은 무엇인가요?</summary>
  <ul>
    <li> 객체간의 의존관계를 미리 설정해두면 스프링 컨테이너가 의존관계를 연결해줍니다. 이렇게 되면 직접 의존하는 객체를 생성하거나 검색해서 가져올 필요가 없어 결합도가 낮아지는 장점이 있습니다.</li>
  </ul>
</details>

<details>
  <summary>IOC는 무엇인가요?</summary>
  <ul>
    <li> Inversion of Control의 약자로 제어의 역전을 의미합니다. 제어권이 사용자에게 있지 않고 프레임워크에 있어서 필요에 따라서 사용자의 코드를 호출하게 됩니다. 스프링에서는 인스턴스의 생성부터 소멸까지 개발자가 아닌 컨테이너에서 대신 관리하게 됩니다. </li>
  </ul>
</details>

<details>
  <summary>ORM은 무엇인가요?</summary>
  <ul>
    <li> Object Relational Mapping의 약자로 관계형 데이터베이스를 OOP(객체지향 프로그래밍)언어로 변환해주는 기술입니다. 그래서 비즈니스 코드가 DB 테이블에 바로 접근하게 도와줍니다. </li>
  </ul>
</details>

<details>
  <summary>JPA가 뭔가요?</summary>
  <ul>
    <li> JPA는 ORM을 위해서 자바에서 제공하는 API 입니다. 자바 객체와 DB 테이블을 매핑하는데 구현체에는 하이버네이트가 있습니다. </li>
  </ul>
</details>

<details>
  <summary>ORM, JPA, Hibernate의 장단점은 뭔가요?</summary>
  <ul>
    <li> 비즈니스 로직에 집중하고 객체 중심의 개발을 하게 도와줍니다. 메소드를 호출하는 것만으로 쿼리를 수행해서 생산성이 향상되고 유지보수 비용이 줄어들며, 특정 DB에 의존하지 않게됩니다. 단점으로는 직접 SQL을 호출하는것보다 오버헤드가 있으며 복잡한 쿼리같은것은 메소드로 처리가 힘들다는 단점이 있습니다.</li>
  </ul>
</details>

<details>
  <summary>필터와 인터셉터에 대해 설명해주세요</summary>
  <ul>
    <li> 필터는 디스패처 서블릿에 요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 대해 부가작업을 처리할 수 있는 기능을 제공합니다. 즉, 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너(서블릿 컨테이너)에 의해 관리가 되는것이고 디스패처 서블릿 전/후에 처리하는것입니다. </li>
    <li> 인터셉터는 필터와 다르게 스프링이 제공하는 기술로서, 디스패처 서블릿이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능을 제공합니다. 즉 웹 컨테이너에서 동작하는 필터와 달리 인터셉터는 스프링 컨텍스트에서 동작합니다. </li>
  </ul>
</details>

<details>
  <summary>필터와 인터셉터는 언제 사용하면 좋을까요?</summary>
  <ul>
    <li> 필터는 xss/방어 및 인증/인가 관련 작업, 모든 요청에 대한 로깅 또는 감사, 이미지/데이터 압축 및 문자열 인코딩, 스프링과 분리되어야 하는 기능 용도로 사용합니다. 또한 request/response 객체를 조작할 필요가 있을때 사용합니다. </li>
    <li>  인터셉터는 세부적인 보안 및 인증/인가 공통 작업, API 호출에 대한 로깅 또는 감사, Controller로 넘겨주는 정보의 가공 시 사용합니다. Request와 response를 조작할 수 없으며 스프링 예외처리도 불가능합니다.</li>
  </ul>
</details>

<details>
  <summary>AOP는 뭔가요?</summary>
  <ul>
    <li> 로깅, 트랜잭션 등 핵심 비즈니스 로직과 별개의 횡단 관심사를 모듈화 하는 프로그래밍 기법입니다. 스프링에서 AOP는 Aspect, JoinPoint, Advice, PointCut 등의 개념을 통해 처리됩니다.</li>
  </ul>
</details>


<details>
  <summary>@Autowired에 대해 설명해주세요 </summary>
  <ul>
    <li> Spring 프레임워크에서 의존성 주입을 자동으로 수행하는데 사용됩니다. 개발자가 별도로 객체를 생성하거나 초기화할 필요 없이 스프링이 자동으로 필요한 빈을 찾아 주입합니다. 생성자, 세터 메서드, 필드에 적용할 수 있으며 주로 다른 빈의 참조를 주입할 때 사용됩니다.</li>
  </ul>
</details>

<details>
  <summary>생성자를 주입해주는 다른 어노테이션이 있나요? </summary>
  <ul>
    <li> Autowired 외에도 Inject, Resource 어노테이션이 있습니다. 오토와이어드는 스프링에서 지원하며 타입에 맞춰 연결합니다. inject는 자바에서 지원하며 타입에 맞춰 연결해줍니다. resource도 자바에서 지원하며 이름 기반으로 연결해줍니다. 타입 기반이여도 @qualifier을 통해 타입 이외의 방법으로 연결할 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary>생성자 주입과 Autowired를 비교해서 설명해주세요 </summary>
  <ul>
    <li> 생성자 주입은 의존성을 명확하게 드러내고 필수 의존성을 누락없이 주입할 수 있으며, 불변성을 보장하고 테스트 용이성이 높습니다. 순환 의존성을 조기에 발견(컨테이너가 빈을 생성하는 시점에 객체 생성 사이클 감지)할 수 있기때문에 스프링에서 가장 권장하는 방식입니다. 하지만 Autowired를 필드에 쓰는 방식은 테스트가 어렵고 변경 가능성이 있어 지양합니다.</li>
  </ul>
</details>

<details>
  <summary> Autowired와 RequiredArgsConstruct를 사용하는것의 차이점은 무엇인가요? </summary>
  <ul>
    <li> Autowired를 생성자에 사용하면 스프링이 해당 생성에 필요한 의존성을 자동으로 주입해줍니다. 이와 유사하게 RequiredArgsConstruct는 lombok 라이브러리에서 제공하는 어노테이션으로, 클래스 내 모든 final 필드와 notnull이 적용된 필드에 대해 생성자를 자동으로 생성합니다.</li>
    <li> 주요한 차이점은 RequiredArgsConstruct는 lombok 라이브러리를 사용해 코드의 간결함을 유지하고, 불필요한 보일러플레이트 코드를 줄여준다는 장점이 있습니다. Autowired는 스프링에서 제공하며 lombok을 사용하지 않을때 의존성 주입을 위해 활용됩니다.  </li>
  </ul>
</details>

<details>
  <summary> 보일러플레이트 코드가 뭔가요? </summary>
  <ul>
    <li> 소프트웨어 개발에서 반복적으로 작성해야하는, 하지만 비즈니스 코드와 직접적으로 관련이 없는 코드를 의미합니다.  </li>
  </ul>
</details>

<details>
  <summary> 스프링 컨테이너는 뭔가요? </summary>
  <ul>
    <li> 스프링 컨테이너는 객체를 생성하고, 의존성을 주입하며 생명주기를 관리하는 핵심 엔진입니다. ApplicationContext가 대표적인 컨테이너로, 빈 스캔,DI, AOP 프록시 생성, 환경설정, 이벤트 처리 등 스프링 애플리케이션의 모든 기반 동작을 담당합니다. 개발자가 객체 생성과 관리에서 벗어나 비즈니스 로직에 집중할 수 있도록 도와주는 것이 컨테이너의 역할입니다.</li>
  </ul>
</details>

<details>
  <summary> 스프링 컨테이너의 구성에 대해 설명해주세요 </summary>
  <ul>
    <li> 스프링 애플리케이션은 ApplicationContext라는 컨테이너를 통해 빈을 생성하고 의존성을 관리합니다. Spring MVC 환경에서는 보통 컨테이너가 두 계층으로 구성됩니다. Root ApplicationContext는 Service, Repository 같은 전역 빈을 관리하고,DispatcherServlet WebApplicationContext는Controller, HandlerMapping 같은 웹 계층 빈을 관리하는 자식 컨텍스트입니다.</li>
    <li> 자식 컨텍스트는 부모 빈을 조회할 수 있어 컨트롤러에서 서비스를 주입받을 수 있지만, 반대로 서비스가 컨트롤러를 주입받는 것은 구조적으로 불가능합니다.</li>
  </ul>1
</details>

<details>
  <summary>스프링에서 빈은 무엇인가요? </summary>
  <ul>
    <li> Spring 프레임워크에서 관리되는 객체를 의미합니다. 스프링 컨테이너에 의해 생성되고 관리되며, 필요할 때마다 주입되는 자바 객체입니다. 빈은 스프링의 IOC 컨테이너에 의해 생명주기가 관리되며, 애플리에이션 내에서 다양한 기능을 수행합니다. 스프링 빈은 기본적으로 싱글톤 패턴으로 스프링 컨테이너 내에서 동일한 타입의 빈은 하나만 생성됩니다. 또한 빈은 다른 빈들간의 의존성을 관리하여 객체간의 결합도를 낮추고 모듈성을 높힐 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary>스프링 빈의 생명주기에 대해 설명해주세요 </summary>
  <ul>
    <li> 스프링 빈의 생명주기는 컨테이너가 생성된 후 빈 생성 -> 의존성 주입 -> 초기화 -> 사용 -> 소멸 순으로 진행됩니다. 빈의 초기화는 @postconstruct 어노테이션을 사용하거나 afterPropertiesSet() 메서드를 오버라이드하거나 커스텀 init() 메소드를 정의하는 방식으로 동작합니다. 빈의 소멸은 @predestroy 어노테이션을 사용하거나 DisposableBean을 오버라이드하거나 커스텀 destroy-method를 정의하여 소멸시킬 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary>스프링 빈의 스코프에 대해 설명해주세요</summary>
  <ul>
    <li> 스프링 빈 스코프랑 스프링이 빈을 어떤 범위로 생성하고 관리할지 결정하는 설정입니다. 빈이 언제 생성되고 언제까지 살아있는지를 정의하는 개념입니다. 기본적으로 스프링은 싱글톤 스코프를 사용해 컨테이너당 하나의 인스턴스를 관리합니다. 그 외에도 요청할 때마다 새로운 빈을 만드는 프로토타입 스코프, HTTP 요청마다 한개씩 생성되는 request 스코프, 세션 단위로 유지되는 세션 스코프, 애플리케이션 전체에서 공유되는 애플리케이션 스코프가 있습니다. 비즈니스 로직은 대부분 싱글톤을 사용하고, 요청/세션 같은 웹 컨텍스트가 필요한 경우 request/session 스코프를 사용합니다.</li>
  </ul>
</details>

<details>
  <summary>결합도를 낮추는게 왜 좋은가요?</summary>
  <ul>
    <li> 결합도를 낮추면 변경의 영향이 최소화되고 테스트와 확장에 유리하며, 재사용성이 높아지기 때문에 유지보수성과 품질이 크게 올라갑니다. 결합도가 높으면 한 부분의 수정이 전체 시스템을 고쳐야 하는 상황이 발생할 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary>@Transactional 어노테이션의 동작 방식과 트랜잭션 전파 옵션에 대해 설명해주세요</summary>
  <ul>
    <li> 스프링에서는 Transactional 어노테이션을 통해 메서드나 클래스에 트랜잭션 경계를 정의하여 트랜잭션을 관리합니다. 이 어노테이션이 적용된 메서드는 호출 시점에 트랜잭션이 시작되며, 메서드가 정상적으로 완료되면 트랜잭션을 커밋하고 예외가 발생하면 트랜잭션을 롤백합니다. </li>
    <li> 트랜잭션 전파 옵션은 트랜잭션을 어떻게 처리할지를 지정하는데, 메서드가 호출될때 이미 실행중인 트랜잭션이 있는경우 그 트랜잭션에 어떻게 대응할지를 결정합니다. 기본 전파 옵션은 required로 현재 실행중인 트랜잭션이 있으면 그 트랜잭션에 참여하고 없다면 새 트랜잭션을 생성합니다. 기타 옵션으로는 항상 새 트랜잭션을 생성하는 requireds_new, 트랜잭션이 이미 있으면 참여하고 없으면 비트랜잭션 방식으로 작동하는 supports, 현재 트랜잭션이 있어야만 참여하는 mandatory, 트랜잭션 없이 실행하는 not_supported, 트랜잭션이 있으면 예외를 발생시키는 never 등이 있습니다.</li>
  </ul>
</details>

<details>
  <summary>스프링 트랜잭션에서 롤백이 발생하면 어떤일이 일어나나요?</summary>
  <ul>
    <li> 트랜잭션에 내에서 발생한 모든 변경사항이 취소됩니다. 이를 통해 데이터베이스의 일관성과 무결성이 유지됩니다. 롤백은 스프링 AOP를 통해 구현되며 런타임 오류가 발생하면 자동으로 트랜잭션을 롤백합니다. 또한 트랜잭션 어노테이션의 rollback for 속성을 사용해 특정 예외 발생시 롤백을 명시적으로 사용할 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary>트랜잭션 처리시 자바의 메모리 구조에서 어떤 영역이 영향을 받나요?</summary>
  <ul>
    <li> heap과 스택 영역이 영향을 받습니다. 트랜잭션 중 객체의 상태 변화는 힙에 반영됩니다. 데이터베이스와의 상호작용에서 생성된 엔티티 객체나 서비스 로직에서 변경된 상태가 힙에 저장됩니다. 스택은 메서드 호출 시 사용되며 트랜잭션 처리 중에 메서드 호출의 흐름이나 지역변수가 이곳에 저장됩니다.</li>
  </ul>
</details>

<details>
  <summary>@Async 어노테이션에 대해 설명해주세요</summary>
  <ul>
    <li> @Async는 스프링에서 메서드를 별도의 스레드에서 비동기로 실행할 수 있도록 해주는 기능입니다. 스프링이 해당 메서드를 프록시로 감싸고, 호출 시 TaskExecutor 스레드풀에 작업을 넘겨 비동기적으로 실행합니다. 다만 프록시 기반이라 같은 클래스 내부 호출 시 동작하지 않고, public 메서드만 가능하며, 트랜잭션 범위도 별도 스레드라 주의 해야합니다.</li>
  </ul>
</details>
