# CS 면접을 위한 Database 면접 질문 리스트

## DB 기초

<details>
  <summary>DB는 뭔가요?</summary>
  <ul>
    <li> 데이터베이스는 데이터를 여러 사용자가 공유하며 일관성 있게 사용할 수 있는 구조화된 집합입니다. 주요 특징으로는 데이터의 독립성, 무결성, 일관성, 보안성, 공유성, 중복 최소화가 있으며, DBMS는 이를 위해 트랜잭션, 제약조건, 권한 제어, 동시성 제어, 복구 기능을 제공합니다</li>
  </ul>
</details>

<details>
  <summary>DB는 왜 사용하는건가요?</summary>
  <ul>
    <li> 데이터베이스는 단순한 저장소가 아니라, 데이터를 안전하게(ACID), 빠르게(인덱스/쿼리 최적화), 동시에(동시성 제어), 일관되게(무결성 제약) 관리하기 위한 시스템입니다. 즉, 단순 파일 저장으로는 불가능한 데이터 일관성, 복구성, 동시성, 보안성을 체계적으로 보장하기 때문에 사용합니다.</li>
    <li> 파일 시스템은 데이터를 단순히 저장할 뿐, 데이터 간의 관계나 동시성, 무결성을 관리하지 못합니다. 반면 DBMS는 데이터를 구조화하고, 여러 사용자가 동시에 접근해도 정합성과 일관성(ACID) 을 유지합니다.</li>
  </ul>
</details>

<details>
  <summary>데이터베이스의 무결성이 뭔가요?</summary>
  <ul>
    <li> 데이터베이스 내의 데이터가 정확하고, 일관되며, 신뢰할 수 있는 상태로 유지되도록 보장하는 성질입니다. 즉, 데이터가 입력/수정/삭제되는 과정에서 오류나 불일치가 발생하지 않도록 데이터베이스 관리 시스템(DBMS)이 규칙(제약조건) 을 통해 지켜주는 것을 말합니다. </li>
    <li> 주요 무결성에는 개체 무결성(각 행은 유일하게 존재해야함), 참조 무결성(외래키는 항상 실제로 존재하는 부모키를 참조해야 함), 도메인 무결성(컬럼 값은 정의된 데이터 형식과 범위 안에 있어야 함), 사용자 정의 무결성(비즈니스 규칙 기반 제약 - 트리거 등)이 있습니다. </li>
  </ul>
</details>

<details>
  <summary>릴레이션, 스키마, 데이터 모델에 대해 설명해주세요</summary>
  <ul>
    <li> 릴레이션은 관계형 데이터베이스에서 데이터를 저장하는 테이블을 의미합니다. 행(Row)은 튜플, 열(Column)은 속성(Attribute)이라 부르며, 릴레이션은 데이터의 집합을 수학적 관계(Relation)로 표현한 것입니다</li>
    <li> 스키마는 데이터베이스의 구조적 설계도입니다. 테이블, 컬럼, 제약조건, 관계 등을 정의하며 DDL로 생성됩니다.</li>
    <li> 데이터 모델은 현실 세계의 데이터를 데이터베이스로 표현하기 위한 개념적 설계 방식입니다. 개체, 속성, 관계를 정의해 ER 다이어그램 등으로 시각화하고, 이후 스키마로 구체화됩니다.</li>
  </ul>
</details>

<details>
  <summary>데이터베이스의 특징은 뭔가요?</summary>
  <ul>
    <li> 데이터베이스 내의 데이터가 정확하고, 일관되며, 신뢰할 수 있는 상태로 유지되도록 보장하는 성질입니다. 즉, 데이터가 입력/수정/삭제되는 과정에서 오류나 불일치가 발생하지 않도록 데이터베이스 관리 시스템(DBMS)이 규칙(제약조건) 을 통해 지켜주는 것을 말합니다. </li>
    <li> 주요 무결성에는 개체 무결성(각 행은 유일하게 존재해야함), 참조 무결성(외래키는 항상 실제로 존재하는 부모키를 참조해야 함), 도메인 무결성(컬럼 값은 정의된 데이터 형식과 범위 안에 있어야 함), 사용자 정의 무결성(비즈니스 규칙 기반 제약 - 트리거 등)이 있습니다. </li>
  </ul>
</details>

<details>
  <summary>Primary Key와 Foreign Key에 대해 설명해주세요</summary>
  <ul>
    <li> Primary key는 candidate key 중 선택한 main key로써, Null 값을 가질 수 없고, 중복된 값을 가질 수 없습니다. Candidate key 중 선택했으므로 유일성과 최소성을 만족합니다.</li>
    <li> Foreign key는 다른 table의 Primary key column과 연결되는(참조되는) table의 column을 의미합니다</li>
  
  </ul>
</details>

<details>
  <summary>Super Key에 대해 설명해주세요</summary>
  <ul>
    <li> Super Key(슈퍼키)는 각 row를 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합입니다. 슈퍼키는 유일성만 만족하면 슈퍼키가 될 수 있습니다. </li>
  
  </ul>
</details>

<details>
  <summary>Candidate key에 대해 설명해주세요</summary>
  <ul>
    <li> Candidate key는 table을 구성하는 column들 중에서 최소성과 유일성을 만족하는 column 또는 column의 집합입니다. 즉 primary key로 사용할 수 있는 column들을 말합니다. </li>
  </ul>
</details>

<details>
  <summary>Alternative key에 대해 설명해주세요</summary>
  <ul>
    <li> Alternative key(대체키) 는 후보키가 두 개 이상일 경우, 기본키로 지정이 되지 못하고 남은 후보키들을 말합니다. </li>
  </ul>
</details>

<details>
  <summary>Composite key에 대해 설명해주세요</summary>
  <ul>
    <li> Composite key란 table에서 각 row를 식별할 수 있는 두 개 이상의 column으로 구성된 candidate key를 말합니다. </li>
  </ul>
</details>

<details>
  <summary>유일성과 최소성에 대해 설명해주세요</summary>
  <ul>
    <li> 유일성은 하나의 key 값으로 특정 row만을 유일하게 찾아낼 수 있어야 하는 것을 의미합니다. </li>
    <li> 최소성은 모든 row를 유일하게 식별하는데 꼭 필요한 속성만으로 구성되어야 하는 것을 의미합니다. </li>
  </ul>
</details>

<details>
  <summary>관계형 데이터베이스에서 1:N 관계를 설명해주세요</summary>
  <ul>
    <li> 관계형 데이터베이스에서 하나의 entity(table)가 관계를 맺은 entity의 여러 객체를 가질 수 있는 구조를 말합니다. </li>
  </ul>
</details>

<details>
  <summary>관계형 데이터베이스에서 N:M 관계를 설명해주세요</summary>
  <ul>
    <li> 관계형 데이터베이스에서 양쪽 entity 모두가 서로에게 1:N 관계를 갖는 구조를 말합니다. </li>
  </ul>
</details>

<details>
  <summary> left outer join, inner join 차이를 설명해 주세요 </summary>
  <ul>
    <li> Join이란 두 개 이상의 테이블을 서로 연결하여 하나의 결과를 만들어 보여주는 것을 말합니다. </li>
    <li> inner join(또는 join)은 두 테이블에 모두 있는 내용만 join되는 방식입니다.  </li>
    <li> left outer join(또는 left join)은 왼쪽 table의 모든 행에 대해서 join을 진행합니다. </li>
  </ul>
</details>

<details>
  <summary> RDB - NoSQL를 비교 설명해 주세요. </summary>
  <ul>
    <li> 관계형 데이터베이스(RDB)는 사전에 엄격하게 정의된 DB schema를 요구하는 table 기반 데이터 구조를 갖습니다. </li>
    <li> NoSQL(비관계형 데이터베이스)은 table 형식이 아닌 비정형 데이터를 저장할 수 있도록 지원합니다.  </li>
    <li> RDB는 엄격한 schema로 인해 데이터 중복이 없기 때문에 데이터 update가 많을 때 유리합니다. </li>
    <li> NoSQL의 경우 데이터 중복으로 인해 데이터 update 시 모든 컬렉션에서 수정이 필요하기 때문에 update가 적고 조회가 많을 때 유리합니다. </li>
  </ul>
</details>

<details>
  <summary> RDB - NoSQL의 장단점을 설명해 주세요. </summary>
  <ul>
    <li> RDB는 명확한 데이터 구조를 보장할 수 있고, 데이터 중복 없이 한번만 저장할 수 있어 무결성을 보장할 수 있습니다. 데이터 중복이 없어 update 또한 유리합니다. </li>
    <li> 단점으로는 시스템이 커지게 되면 join문이 많은 복잡한 쿼리가 필요하게 되며, 수평적 확장이 까다로워 주로 수직적 확장을 사용하게 됩니다. 또한 데이터 구조가 유연하지 못하다는 단점이 있습니다.  </li>
    <li> NoSQL은 유연하고 자유로운 구조를 가지고 있어 새로운 필드 추가가 자유롭고, 수평적 확장이 용이하다는 장점이 있습니다. </li>
    <li> 하지만 데이터 중복이 발생할 수 있고, 중복 데이터가 많기 때문에 데이터 변경시 모든 컬렉션에서 수정해야 한다는 단점이 있습니다. 또한 명확한 데이터 구조를 보장해주지 못합니다.</li>
  </ul>
</details>

<details>
  <summary> RDB - NoSQL은 언제 각각 사용하면 좋을지 설명해주세요. </summary>
  <ul>
    <li> NoSQL은 정확한 데이터 구조가 정해지지 않은 경우, 데이터 update가 자주 이루어지지 않고 조회가 많은 경우, 또 scale out이 가능하므로 데이터 양이 매우 많은 경우에 사용하면 좋습니다. </li>
    <li> RDB는 데이터 구조가 명확하여 변경될 여지가 없는 경우, 또 데이터 중복이 없으므로 데이터 update가 잦은 시스템에서 사용하면 좋습니다.  </li>
  </ul>
</details>


<details>
  <summary> NoSQL은 조회에 왜 조회가 많은 시스템에 사용하면 좋은가요? </summary>
  <ul>
    <li> NoSQL은 스키마가 없고 조인을 하지 않으며, 필요한 데이터를 한 번에 가져올 수 있도록 설계되어 있기 때문입니다. 즉, 데이터를 정규화 하지 않고 읽기 최적화(key-base) 구조로 저장하기 때문입니다.</li>
    <li> RDB는 데이터 구조가 명확하여 변경될 여지가 없는 경우, 또 데이터 중복이 없으므로 데이터 update가 잦은 시스템에서 사용하면 좋습니다.  </li>
  </ul>
</details>

<details>
  <summary> RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? </summary>
  <ul>
    <li> RDB는 모든 트랜잭션에서 ACID (원자성, 일관성, 고립성, 지속성) 특성을 엄격하게 준수해야 합니다. 데이터를 수정할때 ACID 원칙을 지키기 위해 데이터를 잠그거나 MVCC를 통핸 버전 관리등 추가적으로 수행함에 따라 추가적인 부하가 생깁니다. 또한 REDO/UNDO 로그를 기록하고 수행하는 등의 추가 작업을 거치게 됩니다. 
또한 스키마가 엄격하게 정의되어 있기 때문에 새로운 colummn을 추가하는 경우 모든 데이터에 적용해야 하기 때문에 시간이 오래걸릴 수 있습니다. 따라서 NOSQL에 비해 부하가 많이 걸릴 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary> 페이지 버퍼와 버퍼 매니저에 대해 설명해주세요 </summary>
  <ul>
    <li> 페이지 버퍼는 디스크에 저장된 데이터를 일정 크기의 페이지 또는 블록단위로 메모리에 복사하여 임시 저장하는 공간입니다. 쿼리로 데이터를 요청하면, DBMS는 페이지 버퍼에 해당 데이터가 있으면 바로 반환하고 없다면 메모리로 불러와 처리합니다. 
      데이터가 변경된다면 해당 버퍼 내에서 처리되고 실제로 디스크에 반영되지 않는 Dirty Page 상태가 됩니다. 이 페이지는 성능을 위해 즉시 디스크에 쓰지 않고, 나중에 일괄적으로 버퍼 매니저에 의해 디스크에 적용되게 됩니다.</li>
    <li> 페이지 버퍼를 이용해 더 빠른 고속 처리가 가능하며, 여러 트랜잭션이 접근해 데이터를 수정할 수 있도록 동시성을 제공합니다. 또한 변경된 페이지와 트랜잭션 로그를 기록해 복구 작업에 필요한 데이터를 제공합니다.</li>
  </ul>
</details>

<details>
  <summary> 스토리지 엔진은 정확히 뭘하는건가요? </summary>
  <ul>
    <li> DBMS는 크게 스토리지 엔진과 쿼리 프로세서로 이루어져있습니다. 그중 스토리지 엔진은 데이터베이스 내에서 실제 데이터와 인덱스를 저장, 검색, 관리하는 역할을 합니다. 쿼리 프로세스가 두뇌처럼 SQL을 해석하고 계획을 세우면 스토리지 엔진은 실제로 손과 발이 되어 그 명령을 수행하는 역햘을 전담합니다.</li>
  </ul>
</details>

<details>
  <summary> CAP이론은 뭔가요? </summary>
  <ul>
    <li>분산 시스템에서 동시에 만족시킬 수 없는 세 가지 특성을 정의한 이론입니다. Consistency(일관성), Availability(가용성), Partition tolerance(분할 내성입니다)</li>
    <li>일관성은 모든 노드가 동일한 데이터를 본다는 특성입니다. 한 노드에 쓰기가 발생하면 다른 노드도 즉시 같은 값을 읽을 수 있습니다.</li>
    <li>가용성은 일부 노드에 장애가 나더라도 항상 응답 가능한 상태를 유지하는 특성입니다. 요청이 오면 반드시 응답합니다.</li>
    <li>분할 내성은 네트워크가 분리되어 노드 간 통신이 안돼도 시스템이 전체적으로 동작해야 하는 특성입니다.</li>
    <li>네트워크 분할이 발생하면, 시스템은 일관성(C) 을 선택할지, 가용성(A) 을 선택할지 결정해야 합니다. 예를 들어 Cassandra는 AP를, MongoDB는 CP를 택합니다. 즉, CAP은 분산 시스템의 설계 방향 — ‘정확도를 우선할지, 가용성을 우선할지’ — 를 결정하는 기준이 됩니다.</li>
  </ul>
</details>

<details>
  <summary> AP시스템은 뭐고, CP 시스템은 뭔가요?</summary>
  <ul>
    <li>CP 시스템은 C와 P를 선택하고 A를 포기한 시스템입니다. 데이터 불일치는 허용하지 않지만, 장애시 일부 요청은 거절할 수 있습니다. 몽고디비가 대표적입니다.</li>
    <li>AP시스템은 항상 응답하지만, 데이터는 잠시 불일치 할 수 있는 시스템입니다. 카산트라나 다이나모 디비가 대표적입니다.</li>
  </ul>
</details>

<details>
  <summary> 트리거에 대해 설명해주세요</summary>
  <ul>
    <li>트리거는 테이블에 INSERT, UPDATE, DELETE 같은 이벤트가 발생했을 때 자동으로 실행되는 SQL 코드입니다. 보통 데이터 무결성 유지, 변경 로그 기록, 자동 연산 처리 등에 사용되며, BEFORE/AFTER 트리거와 NEW/OLD 값을 이용해 변경 전후 데이터를 참조할 수 있습니다.</li>
  </ul>
</details>



<details>
  <summary> 각 정규화 단계에 대한 설명과, 각 단계에서 테이블이 어떻게 변화하는지에 설명해주세요 </summary>
  <ul>
    <li> 정규화(Normalization)는 관계형 데이터베이스의 설계 과정에서 데이터의 중복을 최소화하고, 데이터의 일관성(무결성)을 확보하며, 이상 현상(Anomaly)을 방지하기 위해 테이블을 구조적으로 분해(쪼개는) 하는 과정입니다.</li>
    <li> 제1 정규화에서는 테이블 컬럼이 원자값을 갖도록 테이블을 분리하는것을 말합니다. 하나의 셀에 오직 하나의 값만이 존재해야 합니다. 전화번호와 같이 여러 값이 포함되어 있다면 별도의 컬럼으로 분리하거나 각 값을 별도의 로우로 분리합니다.</li>
    <li> 제2 정규화에서는 부분 함수 종속을 제거합니다. 복합키가 기본키일 경우, 그 부분집합 키가 결정자가 되어선 안됩니다. 부분 함수 종속 관계를 가지는 컬럼들을 별도의 테이블로 분리하고, 기존 테이블에는 분리된 테이블의 기본 키를 외래 키(FK)로 남깁니다. 예를 들면 수강신청 내역에서 (강좌 ID, 학번)이 있을때 학번만으로 수강생의 이름이 결정되는데, 이를 부분 함수 종속이라고 합니다.</li>
    <li> 제3 정규화에서는 이행적 종속을 없애기 위해 테이블을 분리하는것입니다. A->B, B->C 이면 A->C가 성립되는것이 이행적 종속입니다. 이를 위해 릴레이션이 2정규화를 만족해야하고, 기본키가 아닌 속성들은 기본키에 의존해야한다는 조건을 만족시켜야 합니다. 예륻 들면 (대회, 개최년도) -> 우승자 를 결정하고 우승자 -> 생년월일 이라고 했을때 생년월일이 우승자에 의해 결정되고 있습니다. 따라서 이 생년월일을 따로 사람이름-생년월일 과 같이 분리해야합니다. </li>
    <li> BCNF는 모든 결정자(Determinant)는 후보 키(Candidate Key)가 되도록 합니다. 문제가 되는 종속성을 포함하는 컬럼들을 가장 완벽하게 분리하여 데이터의 무결성을 최고 수준으로 높입니다.</li>
    <li> 제 4 정규화는 다치 종속을 제거하게 됩니다. </li>
    <li> 제 5 정규화는 조인 종속을 제거해 중복을 최소화 합니다. </li>
  </ul>
</details>

<details>
  <summary> 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요. </summary>
  <ul>
    <li> 정규화를 수행하지 않고 데이터를 관리할 경우, 데이터 중복(Redundancy) 때문에 데이터베이스의 일관성(Consistency)이 깨지는 삽입 이상, 갱신 이상, 삭제 이상이 발생합니다.</li>
    <li> 삽입 이상(Insertion Anomaly)은 테이블에 새로운 데이터를 삽입하려고 할때 불필요한 다른 데이터까지 추가해야 삽입이 가능한 상황을 말합니다. 기본키가 (학생ID, 수업ID)인 경우 수업이 없는 학생은 등록할 수 없어 '미수강'과 같은 아이디를 만들어야 합니다.</li>
    <li> 갱신 이상(Update Anomaly)은 중복된 데이터 중 일부 행의 값만 수정되어 불일치가 발생하는 현상입니다. 교수가 전화번호를 바꿨는데 깜빡하고 모든 강좌 정보에 담당 교수 전화번호를 바꾸지 못하면 불일치가 발생합니다. </li>
    <li> 삭제 이상(Deletion Anomaly)은 튜플 삭제로 인해 꼭 필요한 데이터까지 함께 삭제되는 현상입니다. 교수와 강좌정보가 함께 있는 테이블에 교수가 모든 강좌를 폐지한다면 꼭 필요한 교수의 정보가 모두 날아가게 됩니다.</li>
  </ul>
</details>

<details>
  <summary> PK가 AUTO_INCREASE면 bulk 연산이 가능한가요? </summary>
  <ul>
    <li> AUTO_INCREMENT라고 해서 bulk insert가 불가능한 것은 아닙니다. 단지 InnoDB의 auto-increment lock 때문에 다중 스레드 환경에서는 성능이 떨어질 수 있습니다. 단일 bulk insert는 오히려 빠르게 동작하지만, 대규모 병렬 insert에서는 lock 경합이 생길 수 있습니다.</li>
    <li> 기능적으로는 AUTO_INCREMENT여도 Bulk Insert가 가능합니다. 하지만 InnoDB에서는 AUTO_INCREMENT 값을 row마다 생성해야 하고,
이 과정에서 auto-increment lock이나 ID 생성 직렬화가 발생합니다. 그래서 Bulk Insert로 묶어도 내부적으로는 각 row가 개별적으로 ID 생성 → 삽입 과정을 거쳐 실질적인 성능 향상은 거의 없습니다. 그래서 대량 Insert에서는 Snowflake나 UUID 같은 별도 키 생성 방식을 사용합니다</li>
  </ul>
</details>

<details>
  <summary> MySQL에서 batch insert vs multi-row insert 차이? </summary>
  <ul>
    <li> multi-row insert는 SQL 한 번으로 여러 row를 삽입하는 것이고, batch insert는 JDBC나 MyBatis가 여러 insert를 ‘네트워크 한 번에’ 보낸 것입니다. SQL 레벨에서 한 번 insert하는 multi-row insert가 훨씬 빠르지만, 로직에 따라 batch insert를 선호하는 경우도 있습니다.</li>
  </ul>
</details>




## Connection Pool

<details>
  <summary>Connection Pool에 대해 설명해주세요</summary>
  <ul>
    <li>클라이언트 요청에 따라 각 어플리케이션의 스레드에서 데이터베이스에 접근하기 위해서는 커넥션이 필요합니다. 커넥션 풀은 이런 커넥션을 여러개 생성해두어 저장해놓은 공간(캐시), 또는 이 공간의 커넥션을 필요할 때 꺼내 쓰고 반환하는 기법을 말합니다.</li>
    
  </ul>
</details>

<details>
  <summary>Connection Pool을 왜 사용하나요?</summary>
  <ul>
    <li>매 연결마다 커넥션 객체를 생성하고 소멸시키는 비용을 줄일 수 있고, 미리 생성된 커넥션 객체를 사용하기 때문에 DB 접근 시간이 단축됩니다. 또한 커넥션 수를 제한하여 메모리와 DB에 걸리는 부하를 조정할 수 있습니다.</li>
    
  </ul>
</details>


## Transaction

<details>
  <summary>Transaction에 대해 설명해주세요</summary>
  <ul>
    <li>transaction는 데이터베이스 내에서 수행되는 작업의 최소 단위로, 데이터베이스의 무결성을 유지하며 DB의 상태를 변화시키는 기능을 수행합니다. transaction은 하나 이상의 query를 포함해야 하고, ACID라고 칭해지는 원자성, 일관성, 고립성, 지속성의 4가지 규칙을 만족해야합니다.  </li>
    
  </ul>
</details>

<details>
  <summary>ACID에 대해 설명해주세요</summary>
  <ul>
    <li>데이터의 무결성을 유지하기 위한 성질입니다. </li>
    <li>Atomicity(원자성) : transaction에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 말아야 합니다.(all or nothing)</li>
    <li>Consistency(일관성): transaction이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미합니다다. 송금 전후 모두 잔액의 data type은 integer이여야 한다는 것이 일관성의 한 예가 될 수 있습니다.</li>
    <li>Isolation(고립성): 여러 Transaction은 동시에 수행됩니다. 이때 각 transaction은 다른 transaction의 연산 작업이 끼어들지 못하도록 보장하여 독립적으로 작업을 수행합니다. 따라서 동시에 수행되는 transaction이 동일한 data를 가지고 충돌하지 않도록 제어해줘야 합니다. 이를 동시성제어(concurrency control) 라고합니다.</li>
    <li>Durability(지속성): 성공적으로 수행된 transaction은 데이터베이스에 영원히 반영되어야 함을 의미합니다. transaction이 완료되어 저장이 된 데이터베이스는 저장 후에 생기는 정전, 장애, 오류 등에 영향을 받지 않아야 합니다.</li>
  </ul>
</details>

<details>
  <summary>동시성 제어에 대해 설명해주세요</summary>
  <ul>
    <li>동시성 제어란 여러 개의 트랜잭션 또는 프로세스가 공유 데이터에 동시에 접근하여 작업할 때, 그 결과의 일관성(Consistency)과 정확성(Correctness)을 보장하기 위한 기능을 말합니다.</li>
  </ul>
</details>

<details>
  <summary>Commit과 Rollback에 대해 설명해주세요</summary>
  <ul>
    <li>데이터베이스는 COMMIT과 ROLLBACK 명령어를 통해 데이터 무결성을 보장합니다. COMMIT이란 transaction 작업을 완료했다고 확정하는 명령어입니다. transaction 작업 내용을 실제 DB에 저장하고, DB가 변경됩니다. ROLLBACK은 작업 중 문제가 발생했을 때, transaction 처리 과정에서 발생한 변경 사항을 취소하고, 이전 COMMIT의 상태로 되돌립니다.</li>
  </ul>
</details>

<details>
  <summary>DeadLock이란 무엇인지 설명해 주세요.</summary>
  <ul>
    <li>데이터베이스 deadlock(교착 상태)이란, 여러 transaction들이 각각 자신의 데이터에 대하여 lock을 획득한 상태에서 상대방 데이터에 대하여 접근하고자 대기를 할 때 교차 대기를 하게 되면서 서로 영원히 기다리는 상태를 말합니다.</li>
  </ul>
</details>

<details>
  <summary>DeadLock을 해결하려면 어떻게 해야하나요?</summary>
  <ul>
    <li>각 transaction이 실행되기 전에 사용될 모든 데이터를 미리 locking을 해주는 예방기법이 있고, 자원 할당시 timestamp를 사용하여 deadlock이 발생하지 않도록 회피하는 기법이 있습니다. 또한 deadlock이 발생하면 이를 감지하고 회복시키는 탐지/회복기법이 있습니다.</li>
  </ul>
</details>

<details>
  <summary>예방/탐지회복/회피 기법에 대해 설명해주세요</summary>
  <ul>
    <li>예방기법은 각 transaction이 실행되기 전에 필요한 데이터를 모두 Locking 해주는 것입니다. 하지만 locking해줘야 하는 데이터가 많다면 사실상 모든 데이터를 전부 locking한 것과 동일하여 transaction의 병행성을 보장하지 못할 수 있습니다. </li>
    <li>회피 기법은 deadlock을 예방하기 위해 트랜잭션이 시작된 시간을 timestamp로 삼고, 이를 기준으로 크게 Wait-die, Wound-wait 두 방식으로 처리합니다. </li>
    <li>Wait-die는 T2가 선점중인 자원에 T1이 접근하려고 할때, T1의 타임스탬프가 T2보다 Older 하다면 대기하지만 그렇지 않으면 대기하지 않고 T1을 롤백시키는 방법입니다. </li>
    <li>Wound-wait는 T2가 선점중인 자원에 T1이 접근하려고 할때, T1의 타임스탬프가 T2보다 younger 하다면 대기하지만 그렇지 않으면 T2를 롤백시키는 방법입니다. </li>
  </ul>
</details>

<details>
  <summary>Transaction 상태 중 Partially Committed 와 Committed의 차이점을 말해주세요</summary>
  <ul>
    <li>Commit 요청이 들어오면 상태는 Partially Commited 상태가 됩니다. 이후 커밋을 문제 없이 수행할 수 있으면 Commited 상태로 전이되고, 오류가 있으면 failed 상태가 됩니다.</li>
    <li>즉 Partially Commited는 커밋 요청이 들어왔을 때를 말하며, Committed는 커밋을 정상적으로 완료한 상태를 말합니다.</li>
  </ul>
</details>

<details>
  <summary>UNDO와 REDO에 대해 설명해주세요</summary>
  <ul>
    <li>REDO는 지속성을 보장하기 위해 디스크에 반영되지 않은 커밋된 데이터를 다시 적용해 최신 상태로 복구하는 것을 말합니다. 장애 발생 시 커밋 로그를 토대로 최신 상태로 복구합니다.</li>
    <li>UNDO는 일관성을 보장하기 위해 디스크에 반영된 커밋되지 않은 데이터를 되돌려 이전 상태로 롤백하는 것을 말합니다. 수정된 page들이 버퍼 교체 알고리즘에 따라서 디스크에 출력될 수 있습니다. 버퍼 교체는 트랜잭션과 무관하게 버퍼에 상태에 따라서 결정됩니다. 이로 인해 커밋되지 않은 것들이 디스크에 반영될 수 있습니다. 이때 UNDO를 통해 Dirty Write를 방지합니다. 트랜잭션이 수행될 때 변경 전의 값을 UNDO 로그에 기록 해놓고, 장애 발생 시 로그를 참조하여 변경 전 상태로 되돌립니다.</li>
  </ul>
</details>

<details>
  <summary>UNDO와 REDO를 버퍼 관리 정책에 연관지어 대해 설명해주세요</summary>
  <ul>
    <li>REDO는 FORCE, No-FORCE가 있습니다. FORCE는 수정했던 모든 페이지를 트랜잭션 커밋 시점에 디스크에 반영하도록 하는것이며, 커밋되었을때만 수정된 페이지들이 디스크에 반영되므로 redo가 필요 없습니다. NOFORCE는 커밋 시점에 반영하지 않는 정책이고, 트랜잭션상의 DB에 반영되지 않을 수 있기에 REDO 복구가 필요하며 대부분의 DBMS는 이방법을 채택합니다. 왜냐하면 버퍼에 있는걸 지속적으로 변경할 수 있는데 매번 작성하도록 하면 추가적으로 자원이 소모되기 때문입니다. </li>
    <li>UNDO는 Steal, No-Steal이 있습니다. steal은 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책을 말하며, 대부분의 DMBS가 채택하고 있습니다. 추가적인 UNDO logging과 복구가 필요합니다. No-steal은 수정된 페이지들을 트랜잭션 종료까지는 버퍼에 유지하는 정책입니다. UNDO작업이 필요하지 않지만 매우 큰 메모리 버퍼가 필요합니다.</li>
  </ul>
</details>

## Transaction 격리 수준

<details>
  <summary> 트랜잭션 격리 수준에 대해서 설명해주세요</summary>
  <ul>
    <li>1. Read Uncommited(Lv 0) : select 문장이 수행되는 동안 shared lock이 걸리지 않는 가장 낮은 격리 수준입니다. 다른 트랜잭션의 미커밋된 데이터를 읽을 수 있어 dirty read가 발생할 수 있고, 데이터 일관성을 보장할 수 없습니다. 락을 거의 사용하지 않아 성능은 가장 좋지만 거의 사용되지 않습니다.</li>
    <li>2. Read Commited(Lv 1) : select 문장이 수행되는 동안 shared lock이 걸리며, 오직 커밋된 데이터만 읽을 수 있는 수준입니다. 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하며, 대부분의 sql서버가 기본으로 사용하는 수준입니다. dirty read는 방지되지만, 트랜잭션 도중 같은 데이터를 다시 조회했을 때 값이 바뀔 수 있어 Non-repeatable read가 발생할 수 있습니다.</li>
    <li>3. Repeatable Read(Lv 2) : 트랜잭션이 끝날 때까지 조회한 모든 데이터에 Shared Lock을 유지하는 격리수준입니다. 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장하고, 다른 사용자는 트랜잭션 영역에 해당하는 데이터에 대한 수정을 할 수 없습니다. Mysql이나 innoDB에서 기본으로 사용하는 격리 수준입니다. innoDB는 gap lock을 통해 팬텀 리드도 일부 방지합니다. 
      Dirty Read와 non-repeatable read를 방지할 수 있으나, 다른 트랜잭션이 새로운 행을 삽입했을 때 기존 조건으로 조회 시 결과가 달라질 수 있어 Phantom Read가 발생할 수 있습니다.</li>
    <li>4. Serializable(Lv 3) : 완벽한 읽기 일관성을 제공합니다. 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능하며, 앞선 모든 문제를 방지할 수 있습니다. select 시점의 데이터 뿐만 아니라 해당 조건에 걸릴 수 있는 신규 데이터 삽입도 제한합니다. 동시성 성능 저하가 가장 심하며, 락 충돌 가능성이 높습니다.ㅇ</li>
  </ul>
</details>

<details>
  <summary> 트랜잭션 격리 수준을 선택할 때 고려해야할 점은 뭘까요?</summary>
  <ul>
    <li>격리 수준에 대한 조정은 동시성과 데이터 무결성에 연관됩니다. 동시성을 증가시키면 데이터 무결성에 문제가 생기고, 데이터 무결성을 유지하면 동시성이 떨어지게 됩니다. 또한 레벨을 높게 조정할 수록 발생하는 비용이 증가합니다. 이러한 점들을 고려해 비즈니스 요구사항에 맞는 격리 수준을 선택하면 됩니다. </li>
  </ul>
</details>


## Lock

<details>
  <summary> 비관적 락과 낙관적 락에 대해 설명해주세요</summary>
  <ul>
    <li>비관적 락은 충돌이 발생할것이라고 가정하고 아예 데이터를 조회하는 시점부터 배타적 잠금을 걸어 다른 트랜잭션의 접근을 선제적으로 막는 방식입니다. 정합성이 가장 확실하게 보장되지만 동시성이 떨어지고 데드락에 걸릴 수 있다는 단점이 있습니다.</li>
    <li>낙관적 락은 충돌이 거의 발생하지 않을것이라고 가정하고 잠금 없이 작업을 수행한 후 commit 시점에만 충돌 여부를 확인하는 방식입니다. 테이블에 버전이나 타임스탬프 컬럼을 보고 조회 시점과 현재 데이터의 시점을 비교하게 됩니다. 버전이 일치하면 커밋되고, 일치하지 않으면 롤백합니다. 동시성이 높지만, 충돌이 많으면 잦은 롤백과 재시도로 성능이 저하될 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary> 배타적 락과 공유락에 대해 설명해주세요</summary>
  <ul>
    <li>공유락(Shared Lock)은 데이터를 읽을 때 사용하는 락으로, 여러 트랜잭션이 동시에 읽을 수 있지만 수정은 불가능합니다. 반면 배타락(Exclusive Lock)은 데이터를 수정할 때 사용하는 락으로, 한 트랜잭션이 락을 잡으면 다른 트랜잭션은 읽기나 쓰기 모두 불가능합니다. 즉, 공유락은 읽기 공유, 배타락은 쓰기 독점을 의미합니다.</li>
  </ul>
</details>

<details>
  <summary>낙관적 락과 비관적 락을 실행하는 도중 오류가 나면 어떻게 되나요?</summary>
  <ul>
    <li>비관적 락을 잡고 작업을 하던 중 오류가 나게되면 전체 트랜잭션이 롤백되게 되고, DB는 해당 트랜잭션이 끝나는 순간 락을 즉시 해제합니다. 락의 생애 주기는 트랜잭션이 붙어있기 때문입니다. </li>
    <li>낙관적 락은 락을 잡지 않기 때문에, 트랜잭션 중간에 오류가 나도 다른 트랜잭션에 영향을 주지 않습니다. 업데이트 시점의 버전 비교 실패는 예외로 처리되며, 보통 재시도 로직으로 해결합니다.</li>
  </ul>
</details>

<details>
  <summary>낙관적 락과 비관적 락을 실행하는 도중 오류가 나면 어떻게 되나요?</summary>
  <ul>
    <li>비관적 락을 잡고 작업을 하던 중 오류가 나게되면 전체 트랜잭션이 롤백되게 되고, DB는 해당 트랜잭션이 끝나는 순간 락을 즉시 해제합니다. 락의 생애 주기는 트랜잭션이 붙어있기 때문입니다. </li>
    <li>낙관적 락은 락을 잡지 않기 때문에, 트랜잭션 중간에 오류가 나도 다른 트랜잭션에 영향을 주지 않습니다. 업데이트 시점의 버전 비교 실패는 예외로 처리되며, 보통 재시도 로직으로 해결합니다.</li>
  </ul>
</details>

<details>
  <summary>실제 락이 걸리는 주체는 어디인가요?</summary>
  <ul>
    <li>비관적 락은 실제 락을 DB가 로우 레벨 단위로 걸어서 다른 트랜잭션의 접근을 막습니다. 반면 낙관적 락은 실제 락을 걸지 않습니다. DB나 애플리케이션이 물리적으로 락을 잡지 않고 version 필드를 통한 비교로 충돌을 감지하는 방식입니다. 그렇기 때문에 실제 감지하는 주체는 애플리케이션 레이어입니다. DB는 버전이 다르면 0건이 업데이트 되었다는 알림을 보내주고, 애플리케이션은 그 결과를 보고 충돌이 일어났다고 판단하고 예외를 던집니다. </li>
  </ul>
</details>

<details>
  <summary> 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?</summary>
  <ul>
    <li>요청된 트랜잭션이 비정상 종료되어 영구적으로 락이 해제가 되지 않는 경우는 없습니다. 잠금은 트랜잭션의 생애주기에 종속되어 있으며, 트랜잭션이 커밋 또는 롤백 될때 해제됩니다. DBMS의 복구 관리자는 비정상 종료를 감지하면 즉시 롤백을 시도하며, 이 과정에서 획득된 락은 모두 해제가 되게 됩니다.</li>
    <li>데드락이 걸린다면 DBMS에서 순환이 있는지 탐지하고 있다가, 발생하면 둘중 하나는 victim으로 지정해 강제로 종료하게 됩니다.</li>
    <li>만약 없다면, 저희는 애플리케이션 레벨에서 잠금을 획득하는 순서를 통일하거나 트랜잭션의 범위나 길이를 최소화 하려는 노력이 필요합니다.</li>
  </ul>
</details>

<details>
  <summary> 새로운 데이터에 대해서 락을 걸고 싶다고 할 때 낙관적 락이나 비관적 락을 사용해서 걸 수 있을까요?</summary>
  <ul>
    <li>걸 수 없습니다. 낙관적 락은 버전이나 타임스탬프를 기반으로 합니다. 버전 컬럼을 바탕으로 충돌을 감지하는 구조인데, 아직 로우가 디비에 존재하기 때문에 버전이 없어 충돌을 감지할 대상이 없습니다. 비관적 락은 실제 데이터 로우를 기반으로 select 하면서 락을 걸게됩니다. 하지만 새로운 로우는 DB에 없어 select할 대상 자체가 없어 락을 걸 수 없습니다.</li>
    <li>만약 걸고 싶다면, 유니크 제약조건을 이용해 중복을 막는 방법이 있습니다. 또는 Insert On Conflict(Upsert)를 사용하거나, 분산락을 사용할 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary> MVCC에 대해 설명해주세요</summary>
  <ul>
    <li></li>
    <li>MVCC는 Multi-Version Concurrency Control의 약자로, 하나의 데이터를 여러 버전으로 관리해 락 없이 동시 접근이 가능하도록 하는 동시성 제어 기법입니다. 트랜잭션이 시작될 때 자신의 시점에 맞는 스냅샷을 읽고,쓰기 작업은 새로운 버전을 생성합니다. 덕분에 읽기와 쓰기가 서로 블로킹되지 않으며, PostgreSQL이나 InnoDB에서 Undo Log를 이용해 구현됩니다</li>
  </ul>
</details>



## Index

<details>
  <summary>Index가 무엇인가요?</summary>
  <ul>
    <li>Index는 데이터베이스에서 table의 검색 성능을 높여주는 대표적인 방법중 하나입니다. 일반적인 RDBMS(관계형데이터베이스)에서는 B+Tree구조로 된 index를 사용하여 검색속도를 향상시킵니다.</li>
    <li> index는 책마다 마지막 페이지에 있는 색인(index)과 같은 역할을 하는 자료구조입니다. 책에서 어떤 용어나 단어를 찾기위해 첫 페이지부터 끝 페이지 까지 전체를 훑지 않아도(Full Table Scan) index를 찾아보면 몇 페이지에 적혀 있는지 바로 찾을 수 있는 것(Index Scan)과 비슷합니다.  </li>
    <li>SELECT ~WHERE query를 통해 특정 조건을 만족하는 데이터를 찾을 때, full table scan할 필요 없이 정렬되어 있는 index에서 훨씬 빠른 속도로 검색을 할 수 있게 됩니다.</li>
  </ul>
</details>

<details>
  <summary>Index는 왜필요한가요?</summary>
  <ul>
    <li> Table에 데이터를 지속적으로 저장하게 되면 내부적으로 순서 없이 쌓이게 됩니다. 이 경우에 특정 조건을 만족하는 데이터를 찾고자 WHERE절을 사용한다면 Table의 row(record)를 처음부터 끝까지 모두 접근하여 검색조건과 일치하는지 비교하는 과정이 필요합니다. 이를 Full Table Scan이라고 합니다. 하지만 특정 coloumn에 대한 Index를 생성해 놓은 경우 해당 속성에 대하여 search-key가 정렬되어 저장되어 있기 때문에 조건 검색(SELECT ~ WHERE) 속도가 굉장히 빠릅니다.</li>
  </ul>
</details>

<details>
  <summary>Clustering Index는 뭔가요?</summary>
  <ul>
    <li> 특정 column을 기본키(primary key)로 지정하면 자동으로 클러스터형 인덱스가 생성되고, 해당 column 기준으로 정렬이 됩니다. Table 자체가 정렬된 하나의 index인 것입니다.</li>
  </ul>
</details>

<details>
  <summary>Secondary Index는 뭔가요?</summary>
  <ul>
    <li> 일반 책의 찾아보기와 같이 별도의 공간에 인덱스가 생성됩니다. create index와 같이 index를 생성하기를 하거나 고유키(unique key)로 지정하면 보조 인덱스가 생성됩니다.</li>
  </ul>
</details>

<details>
  <summary>Composite Index는 뭔가요?</summary>
  <ul>
    <li> 두 개 이상의 컬럼을 조합하여 만든 인덱스입니다. (A, B) 처럼 순서가 중요한 인덱스로, 단일 컬럼 인덱스로 해결할 수 없는 복합적인 검색 조건에 유리합니다. A만으로 검색하는 경우 인덱스를 설정한 효과를 볼 수 있으나 B만으로 검색하는 경우 인덱스를 설정한 것이 효과가 없습니다. (prefix rule) </li>
  </ul>
</details>

<details>
  <summary>인덱스를 걸때 Composite Index와 단일 컬럼 인덱스의 차이가 뭔가요?</summary>
  <ul>
    <li> 단일 인덱스는 하나의 컬럼을 기준으로 만든 인덱스고, Composite Index는 여러 컬럼을 동시에 정렬해서 만든 인덱스입니다. 단일 인덱스는 각기 독립된 구조라 다중 조건을 효율적으로 처리하지 못하지만, 복합 인덱스는 (A, B) 순서로 정렬된 하나의 트리라 WHERE A AND B 같은 다중 조건을 인덱스만으로 매우 빠르게 처리할 수 있습니다. 그래서 실제 서비스에서는 여러 조건으로 자주 조회되는 경우 단일 인덱스 두 개보다 Composite Index가 훨씬 성능이 좋습니다</li>
    <li> 만약 A와 B 인덱스가 있다면, 단일 인덱스는 Mysql 옵티마이저가 A와 B의 조건이 얼마나 좁은지 코스트나 카디널리티를 계산하게 되고, 둘중 선택도가 낮은(골라내기 쉬운) 인덱스를 계산합니다. 그중 하나를 사용해서 추가적으로 필터링 하게 됩니다. 단일 인덱스 두 개를 병합하여 동시에 사용하는 경우는 제한적입니다. 하지만 복합 인덱스는 그러한 최적화 연산을 줄여주기 때문에 더 빠른 성능을 비교할 수 있도록 합니다.</li>
  </ul>
</details>

<details>
  <summary>Index의 장단점에 대해 설명해주세요.</summary>
  <ul>
    <li> 인덱스의 장점으로는 검색 속도 향상입니다. 테이블을 풀 스캔할 필요없이 조건에 맞는 데이터를 빠르게 찾아낼 수 있는 장점이 있습니다.</li>
    <li> 단점은 추가 저장공간이 필요하다는 점입니다. search-key와 pointer로 이루어진 자료구조를 위한 추가 공간이 필요하게 되며 통상 테이블 크기의 10%를 차지하게됩니다. 또한 검색이 아닌 데이터를 자주 변경하면 성능이 안좋아진다는 단점이 있습니다. 그 이유는 보통 B+ Tree 구조에는 인덱스가 추가되거나 삭제될때 트리의 구조가 바뀔 수 있기 때문입니다.즉 인덱스의 재구성이 필요하기 떄문에 추가 자원이 소모됩니다.</li>
  </ul>
</details>

<details>
  <summary>Index의 내부 동작에 대해 설명해주세요.</summary>
  <ul>
    <li> 인덱스는 대부분 B+ Tree로 이루어져 있어, where 조건과 일치하는 데이터의 저장위치를 훨씬 빠르게 알 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary>Index를 많이 생성하면 안되나요?</summary>
  <ul>
    <li> index를 사용하면 조건 검색 성능이 높아질 수 있습니다. 하지만 추가 저장공간이 필요하며, 데이터를 추가/수정/삭제 시마다 연관된 인덱스를 모두 수정해주어야해서 시간이 추가적으로 소모됩니다. 따라서 추가 저장공간과 업데이트시 소요되는 시간을 복합적으로 고려해서 조건 검색의 성능 향상이 더 큰 이득이 된다고 판단되는 컬럼에만 사용하는것이 좋습니다.</li>
  </ul>
</details>

<details>
  <summary>index를 어느 column에 사용하는 것이 좋을까요?</summary>
  <ul>
    <li> index는 where절에 의해 자주 조회되고, 수정 빈도는 낮으며 카디널리티는 높고, 선택도가 낮은 컬럼에 사용하는것이 좋습니다.</li>
  </ul>
</details>

<details>
  <summary>카디널리티는 뭔가요?</summary>
  <ul>
    <li>카디널리티는 데이터가 중복되는 정도를 말합니다. 예를들어 주민번호는 중복이 되지 않아 카디널리티가 높으며, 성별의 경우 중복이 많아 카디널리티가 낮습니다. </li>
  </ul>
</details>

<details>
  <summary>선택도는 뭔가요?</summary>
  <ul>
    <li>선택도는 전체 데이터 중에서 특정 조건(조건절)을 만족하는 데이터의 비율, 즉 전체 행 대비 유니크한 값의 분포 정도를 나타냅니다. 이는 쿼리 결과로 얼마나 많은 행이 반환될지 예측하는 척도입니다. </li>
  </ul>
</details>

<details>
  <summary> true 또는 false 값을 갖는 column에서, true 1%, false 99%의 비율로 구성된 상황에서는 index를 거는게 좋을까요?</summary>
  <ul>
    <li>아무리 1%, 99%로 비율에 차이가 있어도, true / false 두 종류로만 나눠지는 경우에는 카디널리티가 매우 낮게 됩니다. 이 경우, index가 주는 이점이 매우 적고 오히려 저장공간 차지와 데이터 수정시 성능저하등을 고려하여 index를 생성하지 않는 것이 좋습니다. </li>
    <li>또한 true의 경우 선택도가 낮을 수 있으나 false의 경우 선택도가 매우 높아져 비효율적입니다. </li>
  </ul>
</details>

<details>
  <summary> 데이터를 검색을 할 때 hash table의 시간복잡도는 O(1)이고 b+tree는 O(logn)으로 더 느린데 왜 index는 hash table이 아니라 b+tree로 구현되나요?</summary>
  <ul>
    <li>Hash table을 사용하면 하나의 데이터를 탐색하는 시간은 O(1)로 b+tree보 다 빠르지만, 값이 정렬되어 있지 않기 때문에 부등호를 사용하는 query에 대해서는 매우 비효율적이게 되어 데이터를 정렬해서 저장하는 b+tree를 이용합니다.</li>
    <li>B+ 트리는 항상 정렬된 상태를 유지해 부등호 연산이 쉽고, 데이터 수정/삽입/삭제 연산에도 항상 O(logN)의 복잡도를 유지합니다.</li>
  </ul>
</details>

<details>
  <summary> B- Tree와 B+ Tree에 대해 설명해주세요</summary>
  <ul>
    <li>B- Tree는 이진 탐색 트리와 유사한 자료구조 입니다. 자식 노드를 둘 이상 가질 수 있고 balanced Tree라는 특징이 있습니다. 따라서 탐색 연산에 O(log N)의 복잡도를 가집니다. 모든 노드들에 대해 값을 저장하고 있으며 포인터 역할을 동반합니다.</li>
    <li>B+ 트리는 B-Tree를 개선한 형태의 자료구조입니다. 값을 리프노드에만 저장하며 리프노드들 끼리는 링크드리스트로 연결되어 있기 때문에 부등호문 연산에 효과적입니다. 리프 노드를 제외한 노드들은 포인터의 역할만을 수행합니다.</li>
  </ul>
</details>

<details>
  <summary> B- Tree와 B+ Tree에 대해 설명해주세요</summary>
  <ul>
    <li>MySQL은 디스크 기반 DB이기 때문에, 인덱스를 조회할 때 디스크 I/O를 최대한 줄여야 합니다. B+ Tree는 한 노드에 많은 키를 담을 수 있어서 트리 깊이가 매우 낮고, Leaf 노드가 순차적으로 연결되어 있어서 범위 검색이 빠릅니다. 또한 디스크 페이지(16KB)를 효율적으로 사용하고, 삽입/삭제도 O(log n)으로 안정적이라 대용량에서도 성능이 잘 유지됩니다. 이런 이유로 MySQL의 인덱스 구조는 B+ Tree를 사용합니다.</li>
  </ul>
</details>

<details>
  <summary> DML이 일어날때의 상황을 말해주세요</summary>
  <ul>
    <li>INSERT 작업에서는 기존 block에 여유가 없을때 새로운 데이터가 입력되면, 새로운 block을 할당받은 후 키를 옮기는 작업을 수행합니다. index split 작업동안 해당 블록의 키값에 대해 DML이 블로킹됩니다. 이때 block의 논리적인 순서와 물리적인 순서가 달라져 인덱스 조각화 현상이 발생할 수 있습니다. </li>
    <li>DELETE 작업에서는, 테이블에서 데이터가 delete되면 데이터가 지워지고 다른 데이터가 그 공간을 사용할 수 있습니다. 하지만 인덱스에서 데이터가 delete되는 경우는 데이터가 지워지지 않고 사용 안됨 표시만 해둡니다. 그래서 테이블의 데이터 수와 인덱스의 데이터 수가 달라질 수 있습니다.</li>
    <li>UPDATE 작업에서는, 인덱스는 업데이트 할 수 없어 delete를 먼저 수행한 후 새로운 insert를 수행하게 됩니다.</li>
  </ul>
</details>

<details>
  <summary> 인덱스 조각화를 해결하기 위해서는 어떻게 해야 할까요?</summary>
  <ul>
    <li>기존 인덱스를 삭제하고 새로운 인덱스를 생성하여 물리적으로 연속되게 위치하도록 재구성 하는 방법이 있습니다.다만 대규모 데이터의 경우 시간이 오래 걸릴 수 있으며 해당 테이블이 잠길 수 있습니다. </li>
    <li>또한 인덱스의 논리적인 순서는 유지하되 물리적으로 연속되게 위치하도록 물리적으로 인접한 블록들을 다시 정렬하여 공간을 압축합니다. 완벽하게 해결할 수 없지만 서비스 중에서도 변경할 수 있어 중단 시간을 최소화 할 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary> 랜덤 UUID를 PK로 쓴다면 느린가요?</summary>
  <ul>
    <li>UUID는 값이 랜덤이기 때문에 클러스터드 인덱스의 중간에 계속 삽입됩니다. 그 결과 페이지 split, 인덱스 재정렬, 랜덤 write가 발생해 AUTO_INCREMENT보다 훨씬 느립니다</li>
  </ul>
</details>

## JDBC

<details>
  <summary> Statement와 PreparedStatement를 비교해서 설명해주세요 </summary>
  <ul>
    <li>Statement는 정적인 SQL을 실행할 때 사용되는 가장 기본적인 SQL 실행 도구입니다. SQL 구문을 문자열로 직접 작성해서 실행됩니다. SQL구문이 매번 서버에서 재 컴파일되어 비효율적이고, SQL Injection 공격에 취약하다는 단점이 있습니다. </li>
    <li>PreparedStatment는 동적 SQL을 처리할 수 있는 SQL 실행 도구입니다. 물음표로 값을 바인딩하고 쿼리를 미리 컴파일 해둡니다. 쿼리를 미리 컴파일 해두기때문에 반복 실행시 빠르고, 입력값이 자동으로 이스케이프 처리가 되어 SQL 인젝션을 방지할 수 있으며 가독성과 유지보수성이 좋다는 장점이 있습니다.</li>
    <li>그렇다고 PreparedStatment가 항상 빠르다고 할 수는 없습니다. 컴파일 파싱 실행은 SQL 수행시간 중 극히 일부분이며 대부분은 디스크 IO에서 발생하기 때문입니다. 그렇다 하더라도 PreparedStatment는 SQL 인젝션이 방지되고 재사용성이 높고 DB 캐시를 사용할 수 있다는 장점때문에 사용이 권장됩니다.</li>
  </ul>
</details>

<details>
  <summary> JDBC에 대해 설명해주세요 </summary>
  <ul>
    <li>JDBC는 Java 언어로 작성된 애플리케이션이 데이터베이스와 통신하고 데이터를 조작할 수 있도록 표준화된 방법을 제공하는 Java API입니다. JDBC는 Java 애플리케이션이 특정 DBMS의 내부 구현 방식에 관계없이 동일한 코드를 사용하여 데이터베이스에 접근하도록 돕는 표준 인터페이스 역할을 합니다.</li>
  </ul>
</details>

<details>
  <summary> JDBC는 하는일이 뭔가요? </summary>
  <ul>
    <li>Connection 생성, statement, resultset등 자원의 생성과 반환, resultset loop 처리, 예외 처리 및 반환, 트랜잭션 처리를 담당합니다. 개발자는 데이터 소스 설정, sql문 작성, 결과 처리만 해주면 나머지는 프레임워크가 알아서 작업을 수행해줍니다.</li>
  </ul>
</details>

## 클러스터링/레플리케이션 (분산 환경)

<details>
  <summary> RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요. </summary>
  <ul>
    <li>RDBMS에서 레플리케이션은 일반적으로 마스터-슬레이브 구조로 되어있으며, 비동기식 복제를 이용해 데이터를 동기화합니다. 마스터 노드는 모든 쓰기 작업과 트랜잭션을 처리하며 변경 로그를 남깁니다. 슬레이브 노드는 이 변경 로그를 받아와 순차적으로 처리하며, 주로 읽기 연산을 수행합니다. 주로 읽기 부하 분산과 장애 복구등의 목적으로 사용하며, 처리 지연이 발생해 일시적으로 데이터가 데이터가 불일치할 수 있습니다.</li>
    <li>RDBMS에서 클러스터링은 여러 서버가 하나의 공유 디스크에 접근하여 액티브-스탠바이로 형태로 구성되며 고가용성을 확보합니다. </li>
    <li>NoSQL에서 레플리케이션은 일반적으로 Replica Set 방식을 사용합니다. 샤딩된 데이터 또는 전체 데이터의 복사본을 여러 노드에 저장하여 가용성을 확보합니다.프라이머리 노드와 세컨더리 노드를 두어 프라이머리 노드에서 쓰기 작업을 수행하고 세컨더리 노드에 복제합니다. 장애가 발생할 경우 세턴더리가 자동으로 프라이머리로 승격됩니다. </li>
    <li>NoSQL에서 클러스터링은 전체 데이터를 수평적으로 나누어 여러대의 노드에 분산 저장하는 샤딩 방식을 사용합니다. 샤딩 키를 기준으로 데이터가 나뉘며, 갹 샤드는 데이터의 일부분만을 가집니다. 쓰기/읽기 부하를 분산하고 단일 서버 용량의 한계를 극복하는데 사용됩니다. </li>
  </ul>
</details>

<details>
  <summary> 이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요? </summary>
  <ul>
    <li>RDBMS에서는 강한 일관성을 위해 여러 노드에 걸친 트랜잭션을 2PC(Two-Phase Commit)으로 관리합니다. 강한 일관성을 유지하지만 느리고, 코디네이터 장애시 blocking이 발생할 수 있습니다.</li>
    <li>Nosql에서는 대규모 확장성과 가용성을 중시하기 때문에 CAP이론에 따라 일시적인 불일치를 허용하고, 최종적인 일치를 목표로 합니다.</li>
  </ul>
</details>


<details>
  <summary> 2PC가 뭔가요?</summary>
  <ul>
    <li>분산 트랜잭션을 여러 노드에 걸쳐 수행할 때, 모든 노드가 같이 커밋하거나 같이 롤백하도록 보장하는 방식입니다. prepare 단계에서 coordinator가 각 노드에 커밋 가능한지 요청을 보내고 모든 노드에서 응답이 오면 커밋을 수행합니다. 
      한개의 노드라도 실패가 오면 다른 모든 커밋을 롤백합니다. 강한 일관성을 보장할 수 있지만 코디네이터 장애시 blocking에 걸릴 수 있고 네트워크 지연시 모든 트랜잭션이 멈출 수 있다는 단점이 있습니다.</li>
    <li>분산 시스템에서는 DBMS간 분산 트랜잭션을 지원해야 적용이 가능하고, 동일 제품군이여야 합니다. NoSQL와 RDBMS와 같이 제품군이 다르면 구현하기 어렵습니다. 또한 보통 하나의 API 엔드포인트를 통해 요청이 들어오고 내부적으로 DB가 분산되어 있을때 사용되지만 MSA에서는 각 서비스에서 담당하므로 구현이 용이하지 않습니다.</li>
  </ul>
</details>

<details>
  <summary> 3PC가 뭔가요?</summary>
  <ul>
    <li>2PC의 단점을 보완하기 위해 non-blocking의 특성을 추가한 프로토콜입니다. can-commit단계에서 각 노드에 커밋 준비 가능한지 확인하고, pre-commit 단계에서 모든 노드에 예비 커밋(로그 기록, 실제 커밋 전 단계)를 지시합니다. 이후 do-commit단계에서 최종 커밋을 수행합니다.
    코디네이터 장애시에도 노드가 스스로 커밋하거나 롤백을 판단할 수 있다는 장점이 있지만 네트워크 비용이 더 커지고, 복잡하여 잘 사용되지 않는 방식입니다.</li>
  </ul>
</details>

<details>
  <summary> TCC가 뭔가요?</summary>
  <ul>
    <li>각 로컬 트랜잭션을 3단계 (시도, 확정, 취소)로 나누어 분산 트랜잭션을 보상 방식으로 처리하는 패턴입니다. 리소스가 경합이 크거나 복구 가능성이 필요한 상황에서 유용하며,먼저 자원을 예약해 임시 상태로 잠금하고, 모든 try가 성공하면 확정해 커밋하고, 일부 실패시 모든 시도를 취소하고 롤백합니다. 동기화된 일관성을 어느정도 유지하면서도 2PC보다 비동기적으로 동작하고, 독립성과 복구 가능성이 높습니다.
    하지만 구현 복잡도가 높고, 각 단계별 로직을 직접 구현해야하는 단점이 있습니다.</li>
  </ul>
</details>

<details>
  <summary> SAGA패턴이 뭔가요?</summary>
  <ul>
    <li>SAGA 패턴은 여러 개의 마이크로서비스에 걸쳐 하나의 트랜잭션을 처리할 때,2PC 같은 강한 일관성 대신 보상 트랜잭션(Compensation) 을 이용해 최종 일관성(Eventual Consistency) 을 보장하는 분산 트랜잭션 패턴입니다. 전체 업무 흐름을 여러 단계의 로컬 트랜잭션(Local Transaction) 으로 나누고, 중간에 하나라도 실패하면 이전 단계에서 수행한 작업들을 되돌리는 보상 트랜잭션을 순차적으로 실행합니다.
      구현 방식은 두 가지로 나뉩니다. Orchestration 방식은 중앙 조정자가 각 서비스의 트랜잭션을 순서대로 호출하며 실패 시 보상 호출을 수행하고, Choreography 방식은 이벤트 기반으로 각 서비스가 자율적으로 이벤트를 발행하고 구독하면서 보상을 수행합니다.</li>
    <li>Choreography 방식은 이해하기 쉽고 구축하기 쉽다는 장점이 있지만, 어떤 서비스가 어떤 이벤트를 수신하는지 추측하기 어렵고, 트랜잭션이 많은 서비스를 거쳐야 할 때 상태를 인지하기 어렵고, 모든 서비스는 호출되는 각 서비스의 이벤트를 확인해야 하며 서비스간 순환 의존이 생길 수 있다는 단점이 있습니다.</li>
    <li>오케스트레이션 방식은 서비스 간의 종속성이 없고, 오케스트레이터가 호출하기 때문에 분산 트랜잭션의 중앙화가 이루어져 서비스의 복잡성이 줄어들고 롤백을 쉽게 관리할 수 있다는 장점이 있습니다. 하지만 모든 트랜잭션을 오케스트레이터가 관리하기에 로직이 복잡할 수 있고 해당 서비스가 추가적으로 들어가고 이를 관리해야한다는 단점이 있습니다.</li>
  </ul>
</details>

<details>
  <summary> OutBox패턴이 뭔가요?</summary>
  <ul>
    <li>아웃박스 패턴은 데이터베이스의 변경과 메시지 브로커로의 이벤트 발행을 원자적으로 처리하기 위한 패턴입니다. 마이크로서비스 환경에서는 한 서비스가 DB에 데이터를 저장하고, 동시에 카프카나 래빗엠큐와 같은 메시지 브로커로 이벤트를 발행해야 할 때가 많습니다. 그런데 두 작업이 별개의 시스템에서 수행되기 때문에 DB만 커밋되고 메시지가 전송되거나 그 반대가 되는 문제가 발생할 수 있습니다.</li>
    <li>아웃박스 패턴은 패턴은 이 문제를 해결하기 위해 비즈니스 데이터와 이벤트 데이터를 같은 DB 트랜잭션 안에서 함께 저장합니다. DB에 실제 데이터와 이벤트 레코드인 Outbox 테이블을 한번에 insert합니다. 이후 별도의 백그라운드 프로세서나 CDC도구가 그 테이블을 읽어 카프카에 이벤트를 발행합니다. 
      이를 통해 DB와 이벤트 발행의 원자성을 확보하고 장애가 나더라도 outbox 테이블에 남은 이벤트를 재시도할 수 있어 이벤트 유실이나 중복 발행없이 안정적인 비동기 처리가 가능해집니다. 하지만 별도의 outbox 테이블 및 메시지 중복 처리가 필요하다는 단점이 있습니다.</li>
  </ul>
</details>
