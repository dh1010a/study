# CS 면접을 위한 Database 면접 질문 리스트


## DB 구조 및 설계
<details>
  <summary>Primary Key와 Foreign Key에 대해 설명해주세요</summary>
  <ul>
    <li> Primary key는 candidate key 중 선택한 main key로써, Null 값을 가질 수 없고, 중복된 값을 가질 수 없습니다. Candidate key 중 선택했으므로 유일성과 최소성을 만족합니다.</li>
    <li> Foreign key는 다른 table의 Primary key column과 연결되는(참조되는) table의 column을 의미합니다</li>
  
  </ul>
</details>

<details>
  <summary>Super Key에 대해 설명해주세요</summary>
  <ul>
    <li> Super Key(슈퍼키)는 각 row를 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합입니다. 슈퍼키는 유일성만 만족하면 슈퍼키가 될 수 있습니다. </li>
  
  </ul>
</details>

<details>
  <summary>Candidate key에 대해 설명해주세요</summary>
  <ul>
    <li> Candidate key는 table을 구성하는 column들 중에서 최소성과 유일성을 만족하는 column 또는 column의 집합입니다. 즉 primary key로 사용할 수 있는 column들을 말합니다. </li>
  </ul>
</details>

<details>
  <summary>Alternative key에 대해 설명해주세요</summary>
  <ul>
    <li> Alternative key(대체키) 는 후보키가 두 개 이상일 경우, 기본키로 지정이 되지 못하고 남은 후보키들을 말합니다. </li>
  </ul>
</details>

<details>
  <summary>Composite key에 대해 설명해주세요</summary>
  <ul>
    <li> Composite key란 table에서 각 row를 식별할 수 있는 두 개 이상의 column으로 구성된 candidate key를 말합니다. </li>
  </ul>
</details>

<details>
  <summary>유일성과 최소성에 대해 설명해주세요</summary>
  <ul>
    <li> 유일성은 하나의 key 값으로 특정 row만을 유일하게 찾아낼 수 있어야 하는 것을 의미합니다. </li>
    <li> 최소성은 모든 row를 유일하게 식별하는데 꼭 필요한 속성만으로 구성되어야 하는 것을 의미합니다. </li>
  </ul>
</details>

<details>
  <summary>관계형 데이터베이스에서 1:N 관계를 설명해주세요</summary>
  <ul>
    <li> 관계형 데이터베이스에서 하나의 entity(table)가 관계를 맺은 entity의 여러 객체를 가질 수 있는 구조를 말합니다. </li>
  </ul>
</details>

<details>
  <summary>관계형 데이터베이스에서 N:M 관계를 설명해주세요</summary>
  <ul>
    <li> 관계형 데이터베이스에서 양쪽 entity 모두가 서로에게 1:N 관계를 갖는 구조를 말합니다. </li>
  </ul>
</details>

<details>
  <summary> left outer join, inner join 차이를 설명해 주세요 </summary>
  <ul>
    <li> Join이란 두 개 이상의 테이블을 서로 연결하여 하나의 결과를 만들어 보여주는 것을 말합니다. </li>
    <li> inner join(또는 join)은 두 테이블에 모두 있는 내용만 join되는 방식입니다.  </li>
    <li> left outer join(또는 left join)은 왼쪽 table의 모든 행에 대해서 join을 진행합니다. </li>
  </ul>
</details>

<details>
  <summary> RDB - NoSQL를 비교 설명해 주세요. </summary>
  <ul>
    <li> 관계형 데이터베이스(RDB)는 사전에 엄격하게 정의된 DB schema를 요구하는 table 기반 데이터 구조를 갖습니다. </li>
    <li> NoSQL(비관계형 데이터베이스)은 table 형식이 아닌 비정형 데이터를 저장할 수 있도록 지원합니다.  </li>
    <li> RDB는 엄격한 schema로 인해 데이터 중복이 없기 때문에 데이터 update가 많을 때 유리합니다. </li>
    <li> NoSQL의 경우 데이터 중복으로 인해 데이터 update 시 모든 컬렉션에서 수정이 필요하기 때문에 update가 적고 조회가 많을 때 유리합니다. </li>
  </ul>
</details>

<details>
  <summary> RDB - NoSQL의 장단점을 설명해 주세요. </summary>
  <ul>
    <li> RDB는 명확한 데이터 구조를 보장할 수 있고, 데이터 중복 없이 한번만 저장할 수 있어 무결성을 보장할 수 있습니다. 데이터 중복이 없어 update 또한 유리합니다. </li>
    <li> 단점으로는 시스템이 커지게 되면 join문이 많은 복잡한 쿼리가 필요하게 되며, 수평적 확장이 까다로워 주로 수직적 확장을 사용하게 됩니다. 또한 데이터 구조가 유연하지 못하다는 단점이 있습니다.  </li>
    <li> NoSQL은 유연하고 자유로운 구조를 가지고 있어 새로운 필드 추가가 자유롭고, 수평적 확장이 용이하다는 장점이 있습니다. </li>
    <li> 하지만 데이터 중복이 발생할 수 있고, 중복 데이터가 많기 때문에 데이터 변경시 모든 컬렉션에서 수정해야 한다는 단점이 있습니다. 또한 명확한 데이터 구조를 보장해주지 못합니다.</li>
  </ul>
</details>

<details>
  <summary> RDB - NoSQL은 언제 각각 사용하면 좋을지 설명해주세요. </summary>
  <ul>
    <li> NoSQL은 정확한 데이터 구조가 정해지지 않은 경우, 데이터 update가 자주 이루어지지 않고 조회가 많은 경우, 또 scale out이 가능하므로 데이터 양이 매우 많은 경우에 사용하면 좋습니다. </li>
    <li> RDB는 데이터 구조가 명확하여 변경될 여지가 없는 경우, 또 데이터 중복이 없으므로 데이터 update가 잦은 시스템에서 사용하면 좋습니다.  </li>
  </ul>
</details>

<details>
  <summary> RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? </summary>
  <ul>
    <li> RDB는 모든 트랜잭션에서 ACID (원자성, 일관성, 고립성, 지속성) 특성을 엄격하게 준수해야 합니다. 데이터를 수정할때 ACID 원칙을 지키기 위해 데이터를 잠그거나 MVCC를 통핸 버전 관리등 추가적으로 수행함에 따라 추가적인 부하가 생깁니다. 또한 REDO/UNDO 로그를 기록하고 수행하는 등의 추가 작업을 거치게 됩니다. 
또한 스키마가 엄격하게 정의되어 있기 때문에 새로운 colummn을 추가하는 경우 모든 데이터에 적용해야 하기 때문에 시간이 오래걸릴 수 있습니다. 따라서 NOSQL에 비해 부하가 많이 걸릴 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary> 페이지 버퍼와 버퍼 매니저에 대해 설명해주세요 </summary>
  <ul>
    <li> 페이지 버퍼는 디스크에 저장된 데이터를 일정 크기의 페이지 또는 블록단위로 메모리에 복사하여 임시 저장하는 공간입니다. 쿼리로 데이터를 요청하면, DBMS는 페이지 버퍼에 해당 데이터가 있으면 바로 반환하고 없다면 메모리로 불러와 처리합니다. 
      데이터가 변경된다면 해당 버퍼 내에서 처리되고 실제로 디스크에 반영되지 않는 Dirty Page 상태가 됩니다. 이 페이지는 성능을 위해 즉시 디스크에 쓰지 않고, 나중에 일괄적으로 버퍼 매니저에 의해 디스크에 적용되게 됩니다.</li>
    <li> 페이지 버퍼를 이용해 더 빠른 고속 처리가 가능하며, 여러 트랜잭션이 접근해 데이터를 수정할 수 있도록 동시성을 제공합니다. 또한 변경된 페이지와 트랜잭션 로그를 기록해 복구 작업에 필요한 데이터를 제공합니다.</li>
  </ul>
</details>

<details>
  <summary> 스토리지 엔진은 정확히 뭘하는건가요? </summary>
  <ul>
    <li> DBMS는 크게 스토리지 엔진과 쿼리 프로세서로 이루어져있습니다. 그중 스토리지 엔진은 데이터베이스 내에서 실제 데이터와 인덱스를 저장, 검색, 관리하는 역할을 합니다. 쿼리 프로세스가 두뇌처럼 SQL을 해석하고 계획을 세우면 스토리지 엔진은 실제로 손과 발이 되어 그 명령을 수행하는 역햘을 전담합니다.</li>
  </ul>
</details>

<details>
  <summary> CAP이론은 뭔가요? </summary>
  <ul>
    <li>분산 시스템에서 동시에 만족시킬 수 없는 세 가지 특성을 정의한 이론입니다. Consistency(일관성), Availability(가용성), Partition tolerance(분할 내성입니다)</li>
    <li>일관성은 모든 노드가 동일한 데이터를 본다는 특성입니다. 한 노드에 쓰기가 발생하면 다른 노드도 즉시 같은 값을 읽을 수 있습니다.</li>
    <li>가용성은 일부 노드에 장애가 나더라도 항상 응답 가능한 상태를 유지하는 특성입니다. 요청이 오면 반드시 응답합니다.</li>
    <li>분할 내성은 네트워크가 분리되어 노드 간 통신이 안돼도 시스템이 전체적으로 동작해야 하는 특성입니다.</li>
    <li>네트워크 분할이 발생하면, 시스템은 일관성(C) 을 선택할지, 가용성(A) 을 선택할지 결정해야 합니다. 예를 들어 Cassandra는 AP를, MongoDB는 CP를 택합니다. 즉, CAP은 분산 시스템의 설계 방향 — ‘정확도를 우선할지, 가용성을 우선할지’ — 를 결정하는 기준이 됩니다.</li>
  </ul>
</details>

<details>
  <summary> AP시스템은 뭐고, CP 시스템은 뭔가요?</summary>
  <ul>
    <li>CP 시스템은 C와 P를 선택하고 A를 포기한 시스템입니다. 데이터 불일치는 허용하지 않지만, 장애시 일부 요청은 거절할 수 있습니다. 몽고디비가 대표적입니다.</li>
    <li>AP시스템은 항상 응답하지만, 데이터는 잠시 불일치 할 수 있는 시스템입니다. 카산트라나 다이나모 디비가 대표적입니다.</li>
  </ul>
</details>

<details>
  <summary> 각 정규화 단계에 대한 설명과, 각 단계에서 테이블이 어떻게 변화하는지에 설명해주세요 </summary>
  <ul>
    <li> 정규화(Normalization)는 관계형 데이터베이스의 설계 과정에서 데이터의 중복을 최소화하고, 데이터의 일관성(무결성)을 확보하며, 이상 현상(Anomaly)을 방지하기 위해 테이블을 구조적으로 분해(쪼개는) 하는 과정입니다.</li>
    <li> 제1 정규화에서는 테이블 컬럼이 원자값을 갖도록 테이블을 분리하는것을 말합니다. 하나의 셀에 오직 하나의 값만이 존재해야 합니다. 전화번호와 같이 여러 값이 포함되어 있다면 별도의 컬럼으로 분리하거나 각 값을 별도의 로우로 분리합니다.</li>
    <li> 제2 정규화에서는 부분 함수 종속을 제거합니다. 복합키가 기본키일 경우, 그 부분집합 키가 결정자가 되어선 안됩니다. 부분 함수 종속 관계를 가지는 컬럼들을 별도의 테이블로 분리하고, 기존 테이블에는 분리된 테이블의 기본 키를 외래 키(FK)로 남깁니다. 예를 들면 수강신청 내역에서 (강좌 ID, 학번)이 있을때 학번만으로 수강생의 이름이 결정되는데, 이를 부분 함수 종속이라고 합니다.</li>
    <li> 제3 정규화에서는 이행적 종속을 없애기 위해 테이블을 분리하는것입니다. A->B, B->C 이면 A->C가 성립되는것이 이행적 종속입니다. 이를 위해 릴레이션이 2정규화를 만족해야하고, 기본키가 아닌 속성들은 기본키에 의존해야한다는 조건을 만족시켜야 합니다. 예륻 들면 (대회, 개최년도) -> 우승자 를 결정하고 우승자 -> 생년월일 이라고 했을때 생년월일이 우승자에 의해 결정되고 있습니다. 따라서 이 생년월일을 따로 사람이름-생년월일 과 같이 분리해야합니다. </li>
    <li> BCNF는 모든 결정자(Determinant)는 후보 키(Candidate Key)가 되도록 합니다. 문제가 되는 종속성을 포함하는 컬럼들을 가장 완벽하게 분리하여 데이터의 무결성을 최고 수준으로 높입니다.</li>
    <li> 제 4 정규화는 다치 종속을 제거하게 됩니다. </li>
    <li> 제 5 정규화는 조인 종속을 제거해 중복을 최소화 합니다. </li>
  </ul>
</details>

<details>
  <summary> 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요. </summary>
  <ul>
    <li> 정규화를 수행하지 않고 데이터를 관리할 경우, 데이터 중복(Redundancy) 때문에 데이터베이스의 일관성(Consistency)이 깨지는 삽입 이상, 갱신 이상, 삭제 이상이 발생합니다.</li>
    <li> 삽입 이상(Insertion Anomaly)은 테이블에 새로운 데이터를 삽입하려고 할때 불필요한 다른 데이터까지 추가해야 삽입이 가능한 상황을 말합니다. 기본키가 (학생ID, 수업ID)인 경우 수업이 없는 학생은 등록할 수 없어 '미수강'과 같은 아이디를 만들어야 합니다.</li>
    <li> 갱신 이상(Update Anomaly)은 중복된 데이터 중 일부 행의 값만 수정되어 불일치가 발생하는 현상입니다. 교수가 전화번호를 바꿨는데 깜빡하고 모든 강좌 정보에 담당 교수 전화번호를 바꾸지 못하면 불일치가 발생합니다. </li>
    <li> 삭제 이상(Deletion Anomaly)은 튜플 삭제로 인해 꼭 필요한 데이터까지 함께 삭제되는 현상입니다. 교수와 강좌정보가 함께 있는 테이블에 교수가 모든 강좌를 폐지한다면 꼭 필요한 교수의 정보가 모두 날아가게 됩니다.</li>
  </ul>
</details>


## Connection Pool

<details>
  <summary>Connection Pool에 대해 설명해주세요</summary>
  <ul>
    <li>클라이언트 요청에 따라 각 어플리케이션의 스레드에서 데이터베이스에 접근하기 위해서는 커넥션이 필요합니다. 커넥션 풀은 이런 커넥션을 여러개 생성해두어 저장해놓은 공간(캐시), 또는 이 공간의 커넥션을 필요할 때 꺼내 쓰고 반환하는 기법을 말합니다.</li>
    
  </ul>
</details>

<details>
  <summary>Connection Pool을 왜 사용하나요?</summary>
  <ul>
    <li>매 연결마다 커넥션 객체를 생성하고 소멸시키는 비용을 줄일 수 있고, 미리 생성된 커넥션 객체를 사용하기 때문에 DB 접근 시간이 단축됩니다. 또한 커넥션 수를 제한하여 메모리와 DB에 걸리는 부하를 조정할 수 있습니다.</li>
    
  </ul>
</details>


## Transaction

<details>
  <summary>Transaction에 대해 설명해주세요</summary>
  <ul>
    <li>transaction는 데이터베이스 내에서 수행되는 작업의 최소 단위로, 데이터베이스의 무결성을 유지하며 DB의 상태를 변화시키는 기능을 수행합니다. transaction은 하나 이상의 query를 포함해야 하고, ACID라고 칭해지는 원자성, 일관성, 고립성, 지속성의 4가지 규칙을 만족해야합니다.  </li>
    
  </ul>
</details>

<details>
  <summary>ACID에 대해 설명해주세요</summary>
  <ul>
    <li>데이터의 무결성을 유지하기 위한 성질입니다. </li>
    <li>Atomicity(원자성) : transaction에 포함된 작업은 전부 수행되거나 아니면 전부 수행되지 말아야 합니다.(all or nothing)</li>
    <li>Consistency(일관성): transaction이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미합니다다. 송금 전후 모두 잔액의 data type은 integer이여야 한다는 것이 일관성의 한 예가 될 수 있습니다.</li>
    <li>Isolation(고립성): 여러 Transaction은 동시에 수행됩니다. 이때 각 transaction은 다른 transaction의 연산 작업이 끼어들지 못하도록 보장하여 독립적으로 작업을 수행합니다. 따라서 동시에 수행되는 transaction이 동일한 data를 가지고 충돌하지 않도록 제어해줘야 합니다. 이를 동시성제어(concurrency control) 라고합니다.</li>
    <li>Durability(지속성): 성공적으로 수행된 transaction은 데이터베이스에 영원히 반영되어야 함을 의미합니다. transaction이 완료되어 저장이 된 데이터베이스는 저장 후에 생기는 정전, 장애, 오류 등에 영향을 받지 않아야 합니다.</li>
  </ul>
</details>

<details>
  <summary>동시성 제어에 대해 설명해주세요</summary>
  <ul>
    <li>동시성 제어란 여러 개의 트랜잭션 또는 프로세스가 공유 데이터에 동시에 접근하여 작업할 때, 그 결과의 일관성(Consistency)과 정확성(Correctness)을 보장하기 위한 기능을 말합니다.</li>
  </ul>
</details>

<details>
  <summary>Commit과 Rollback에 대해 설명해주세요</summary>
  <ul>
    <li>데이터베이스는 COMMIT과 ROLLBACK 명령어를 통해 데이터 무결성을 보장합니다. COMMIT이란 transaction 작업을 완료했다고 확정하는 명령어입니다. transaction 작업 내용을 실제 DB에 저장하고, DB가 변경됩니다. ROLLBACK은 작업 중 문제가 발생했을 때, transaction 처리 과정에서 발생한 변경 사항을 취소하고, 이전 COMMIT의 상태로 되돌립니다.</li>
  </ul>
</details>

<details>
  <summary>DeadLock이란 무엇인지 설명해 주세요.</summary>
  <ul>
    <li>데이터베이스 deadlock(교착 상태)이란, 여러 transaction들이 각각 자신의 데이터에 대하여 lock을 획득한 상태에서 상대방 데이터에 대하여 접근하고자 대기를 할 때 교차 대기를 하게 되면서 서로 영원히 기다리는 상태를 말합니다.</li>
  </ul>
</details>

<details>
  <summary>DeadLock을 해결하려면 어떻게 해야하나요?</summary>
  <ul>
    <li>각 transaction이 실행되기 전에 사용될 모든 데이터를 미리 locking을 해주는 예방기법이 있고, 자원 할당시 timestamp를 사용하여 deadlock이 발생하지 않도록 회피하는 기법이 있습니다. 또한 deadlock이 발생하면 이를 감지하고 회복시키는 탐지/회복기법이 있습니다.</li>
  </ul>
</details>

<details>
  <summary>예방/탐지회복/회피 기법에 대해 설명해주세요</summary>
  <ul>
    <li>예방기법은 각 transaction이 실행되기 전에 필요한 데이터를 모두 Locking 해주는 것입니다. 하지만 locking해줘야 하는 데이터가 많다면 사실상 모든 데이터를 전부 locking한 것과 동일하여 transaction의 병행성을 보장하지 못할 수 있습니다. </li>
    <li>회피 기법은 deadlock을 예방하기 위해 트랜잭션이 시작된 시간을 timestamp로 삼고, 이를 기준으로 크게 Wait-die, Wound-wait 두 방식으로 처리합니다. </li>
    <li>Wait-die는 T2가 선점중인 자원에 T1이 접근하려고 할때, T1의 타임스탬프가 T2보다 Older 하다면 대기하지만 그렇지 않으면 대기하지 않고 T1을 롤백시키는 방법입니다. </li>
    <li>Wound-wait는 T2가 선점중인 자원에 T1이 접근하려고 할때, T1의 타임스탬프가 T2보다 younger 하다면 대기하지만 그렇지 않으면 T2를 롤백시키는 방법입니다. </li>
  </ul>
</details>

<details>
  <summary>Transaction 상태 중 Partially Committed 와 Committed의 차이점을 말해주세요</summary>
  <ul>
    <li>Commit 요청이 들어오면 상태는 Partially Commited 상태가 됩니다. 이후 커밋을 문제 없이 수행할 수 있으면 Commited 상태로 전이되고, 오류가 있으면 failed 상태가 됩니다.</li>
    <li>즉 Partially Commited는 커밋 요청이 들어왔을 때를 말하며, Committed는 커밋을 정상적으로 완료한 상태를 말합니다.</li>
  </ul>
</details>

<details>
  <summary>UNDO와 REDO에 대해 설명해주세요</summary>
  <ul>
    <li>REDO는 지속성을 보장하기 위해 디스크에 반영되지 않은 커밋된 데이터를 다시 적용해 최신 상태로 복구하는 것을 말합니다. 장애 발생 시 커밋 로그를 토대로 최신 상태로 복구합니다.</li>
    <li>UNDO는 일관성을 보장하기 위해 디스크에 반영된 커밋되지 않은 데이터를 되돌려 이전 상태로 롤백하는 것을 말합니다. 수정된 page들이 버퍼 교체 알고리즘에 따라서 디스크에 출력될 수 있습니다. 버퍼 교체는 트랜잭션과 무관하게 버퍼에 상태에 따라서 결정됩니다. 이로 인해 커밋되지 않은 것들이 디스크에 반영될 수 있습니다. 이때 UNDO를 통해 Dirty Write를 방지합니다. 트랜잭션이 수행될 때 변경 전의 값을 UNDO 로그에 기록 해놓고, 장애 발생 시 로그를 참조하여 변경 전 상태로 되돌립니다.</li>
  </ul>
</details>

<details>
  <summary>UNDO와 REDO를 버퍼 관리 정책에 연관지어 대해 설명해주세요</summary>
  <ul>
    <li>REDO는 FORCE, No-FORCE가 있습니다. FORCE는 수정했던 모든 페이지를 트랜잭션 커밋 시점에 디스크에 반영하도록 하는것이며, 커밋되었을때만 수정된 페이지들이 디스크에 반영되므로 redo가 필요 없습니다. NOFORCE는 커밋 시점에 반영하지 않는 정책이고, 트랜잭션상의 DB에 반영되지 않을 수 있기에 REDO 복구가 필요하며 대부분의 DBMS는 이방법을 채택합니다. 왜냐하면 버퍼에 있는걸 지속적으로 변경할 수 있는데 매번 작성하도록 하면 추가적으로 자원이 소모되기 때문입니다. </li>
    <li>UNDO는 Steal, No-Steal이 있습니다. steal은 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책을 말하며, 대부분의 DMBS가 채택하고 있습니다. 추가적인 UNDO logging과 복구가 필요합니다. No-steal은 수정된 페이지들을 트랜잭션 종료까지는 버퍼에 유지하는 정책입니다. UNDO작업이 필요하지 않지만 매우 큰 메모리 버퍼가 필요합니다.</li>
  </ul>
</details>

## Transaction 격리 수준

<details>
  <summary> 트랜잭션 격리 수준에 대해서 설명해주세요</summary>
  <ul>
    <li>1. Read Uncommited(Lv 0) : select 문장이 수행되는 동안 shared lock이 걸리지 않는 가장 낮은 격리 수준입니다. 다른 트랜잭션의 미커밋된 데이터를 읽을 수 있어 dirty read가 발생할 수 있고, 데이터 일관성을 보장할 수 없습니다. 락을 거의 사용하지 않아 성능은 가장 좋지만 거의 사용되지 않습니다.</li>
    <li>2. Read Commited(Lv 1) : select 문장이 수행되는 동안 shared lock이 걸리며, 오직 커밋된 데이터만 읽을 수 있는 수준입니다. 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하며, 대부분의 sql서버가 기본으로 사용하는 수준입니다. dirty read는 방지되지만, 트랜잭션 도중 같은 데이터를 다시 조회했을 때 값이 바뀔 수 있어 Non-repeatable read가 발생할 수 있습니다.</li>
    <li>3. Repeatable Read(Lv 2) : 트랜잭션이 끝날 때까지 조회한 모든 데이터에 Shared Lock을 유지하는 격리수준입니다. 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장하고, 다른 사용자는 트랜잭션 영역에 해당하는 데이터에 대한 수정을 할 수 없습니다. Mysql이나 innoDB에서 기본으로 사용하는 격리 수준입니다. innoDB는 gap lock을 통해 팬텀 리드도 일부 방지합니다. 
      Dirty Read와 non-repeatable read를 방지할 수 있으나, 다른 트랜잭션이 새로운 행을 삽입했을 때 기존 조건으로 조회 시 결과가 달라질 수 있어 Phantom Read가 발생할 수 있습니다.</li>
    <li>4. Serializable(Lv 3) : 완벽한 읽기 일관성을 제공합니다. 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능하며, 앞선 모든 문제를 방지할 수 있습니다. select 시점의 데이터 뿐만 아니라 해당 조건에 걸릴 수 있는 신규 데이터 삽입도 제한합니다. 동시성 성능 저하가 가장 심하며, 락 충돌 가능성이 높습니다.ㅇ</li>
  </ul>
</details>

<details>
  <summary> 트랜잭션 격리 수준을 선택할 때 고려해야할 점은 뭘까요?</summary>
  <ul>
    <li>격리 수준에 대한 조정은 동시성과 데이터 무결성에 연관됩니다. 동시성을 증가시키면 데이터 무결성에 문제가 생기고, 데이터 무결성을 유지하면 동시성이 떨어지게 됩니다. 또한 레벨을 높게 조정할 수록 발생하는 비용이 증가합니다. 이러한 점들을 고려해 비즈니스 요구사항에 맞는 격리 수준을 선택하면 됩니다. </li>
  </ul>
</details>


## Lock

<details>
  <summary> 비관적 락과 낙관적 락에 대해 설명해주세요</summary>
  <ul>
    <li>비관적 락은 충돌이 발생할것이라고 가정하고 아예 데이터를 조회하는 시점부터 배타적 잠금을 걸어 다른 트랜잭션의 접근을 선제적으로 막는 방식입니다. 정합성이 가장 확실하게 보장되지만 동시성이 떨어지고 데드락에 걸릴 수 있다는 단점이 있습니다.</li>
    <li>낙관적 락은 충돌이 거의 발생하지 않을것이라고 가정하고 잠금 없이 작업을 수행한 후 commit 시점에만 충돌 여부를 확인하는 방식입니다. 테이블에 버전이나 타임스탬프 컬럼을 보고 조회 시점과 현재 데이터의 시점을 비교하게 됩니다. 버전이 일치하면 커밋되고, 일치하지 않으면 롤백합니다. 동시성이 높지만, 충돌이 많으면 잦은 롤백과 재시도로 성능이 저하될 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary> 물리적인 Lock을 건다면, 만약 이를 수행중인 요청에 문제가 생겨 비정상 종료되면 Lock이 절대 해제되지 않는 문제가 생길 수도 있을 것 같습니다. DB는 이를 위한 해결책이 있나요? 없다면, 우리가 이 문제를 해결할 수 없을까요?</summary>
  <ul>
    <li>요청된 트랜잭션이 비정상 종료되어 영구적으로 락이 해제가 되지 않는 경우는 없습니다. 잠금은 트랜잭션의 생애주기에 종속되어 있으며, 트랜잭션이 커밋 또는 롤백 될때 해제됩니다. DBMS의 복구 관리자는 비정상 종료를 감지하면 즉시 롤백을 시도하며, 이 과정에서 획득된 락은 모두 해제가 되게 됩니다.</li>
    <li>데드락이 걸린다면 DBMS에서 순환이 있는지 탐지하고 있다가, 발생하면 둘중 하나는 victim으로 지정해 강제로 종료하게 됩니다.</li>
    <li>만약 없다면, 저희는 애플리케이션 레벨에서 잠금을 획득하는 순서를 통일하거나 트랜잭션의 범위나 길이를 최소화 하려는 노력이 필요합니다.</li>
  </ul>
</details>



## Index

<details>
  <summary>Index가 무엇인가요?</summary>
  <ul>
    <li>Index는 데이터베이스에서 table의 검색 성능을 높여주는 대표적인 방법중 하나입니다. 일반적인 RDBMS(관계형데이터베이스)에서는 B+Tree구조로 된 index를 사용하여 검색속도를 향상시킵니다.</li>
    <li> index는 책마다 마지막 페이지에 있는 색인(index)과 같은 역할을 하는 자료구조입니다. 책에서 어떤 용어나 단어를 찾기위해 첫 페이지부터 끝 페이지 까지 전체를 훑지 않아도(Full Table Scan) index를 찾아보면 몇 페이지에 적혀 있는지 바로 찾을 수 있는 것(Index Scan)과 비슷합니다.  </li>
    <li>SELECT ~WHERE query를 통해 특정 조건을 만족하는 데이터를 찾을 때, full table scan할 필요 없이 정렬되어 있는 index에서 훨씬 빠른 속도로 검색을 할 수 있게 됩니다.</li>
  </ul>
</details>

<details>
  <summary>Index는 왜필요한가요?</summary>
  <ul>
    <li> Table에 데이터를 지속적으로 저장하게 되면 내부적으로 순서 없이 쌓이게 됩니다. 이 경우에 특정 조건을 만족하는 데이터를 찾고자 WHERE절을 사용한다면 Table의 row(record)를 처음부터 끝까지 모두 접근하여 검색조건과 일치하는지 비교하는 과정이 필요합니다. 이를 Full Table Scan이라고 합니다. 하지만 특정 coloumn에 대한 Index를 생성해 놓은 경우 해당 속성에 대하여 search-key가 정렬되어 저장되어 있기 때문에 조건 검색(SELECT ~ WHERE) 속도가 굉장히 빠릅니다.</li>
  </ul>
</details>

<details>
  <summary>Clustering Index는 뭔가요?</summary>
  <ul>
    <li> 특정 column을 기본키(primary key)로 지정하면 자동으로 클러스터형 인덱스가 생성되고, 해당 column 기준으로 정렬이 됩니다. Table 자체가 정렬된 하나의 index인 것입니다.</li>
  </ul>
</details>

<details>
  <summary>Secondary Index는 뭔가요?</summary>
  <ul>
    <li> 일반 책의 찾아보기와 같이 별도의 공간에 인덱스가 생성됩니다. create index와 같이 index를 생성하기를 하거나 고유키(unique key)로 지정하면 보조 인덱스가 생성됩니다.</li>
  </ul>
</details>

<details>
  <summary>Composite Index는 뭔가요?</summary>
  <ul>
    <li> 두 개 이상의 컬럼을 조합하여 만든 인덱스입니다. (A, B) 처럼 순서가 중요한 인덱스로, 단일 컬럼 인덱스로 해결할 수 없는 복합적인 검색 조건에 유리합니다. A만으로 검색하는 경우 인덱스를 설정한 효과를 볼 수 있으나 B만으로 검색하는 경우 인덱스를 설정한 것이 효과가 없습니다. </li>
  </ul>
</details>

<details>
  <summary>Index의 장단점에 대해 설명해주세요.</summary>
  <ul>
    <li> 인덱스의 장점으로는 검색 속도 향상입니다. 테이블을 풀 스캔할 필요없이 조건에 맞는 데이터를 빠르게 찾아낼 수 있는 장점이 있습니다.</li>
    <li> 단점은 추가 저장공간이 필요하다는 점입니다. search-key와 pointer로 이루어진 자료구조를 위한 추가 공간이 필요하게 되며 통상 테이블 크기의 10%를 차지하게됩니다. 또한 검색이 아닌 데이터를 자주 변경하면 성능이 안좋아진다는 단점이 있습니다. 그 이유는 보통 B+ Tree 구조에는 인덱스가 추가되거나 삭제될때 트리의 구조가 바뀔 수 있기 때문입니다.즉 인덱스의 재구성이 필요하기 떄문에 추가 자원이 소모됩니다.</li>
  </ul>
</details>

<details>
  <summary>Index의 내부 동작에 대해 설명해주세요.</summary>
  <ul>
    <li> 인덱스는 대부분 B+ Tree로 이루어져 있어, where 조건과 일치하는 데이터의 저장위치를 훨씬 빠르게 알 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary>Index를 많이 생성하면 안되나요?</summary>
  <ul>
    <li> index를 사용하면 조건 검색 성능이 높아질 수 있습니다. 하지만 추가 저장공간이 필요하며, 데이터를 추가/수정/삭제 시마다 연관된 인덱스를 모두 수정해주어야해서 시간이 추가적으로 소모됩니다.
    따라서 추가 저장공간과 업데이트시 소요되는 시간을 복합적으로 고려해서 조건 검색의 성능 향상이 더 큰 이득이 된다고 판단되는 컬럼에만 사용하는것이 좋습니다.</li>
  </ul>
</details>

<details>
  <summary>index를 어느 column에 사용하는 것이 좋을까요?</summary>
  <ul>
    <li> index는 where절에 의해 자주 조회되고, 수정 빈도는 낮으며 카디널리티는 높고, 선택도가 낮은 컬럼에 사용하는것이 좋습니다.</li>
  </ul>
</details>

<details>
  <summary>카디널리티는 뭔가요?</summary>
  <ul>
    <li>카디널리티는 데이터가 중복되는 정도를 말합니다. 예를들어 주민번호는 중복이 되지 않아 카디널리티가 높으며, 성별의 경우 중복이 많아 카디널리티가 낮습니다. </li>
  </ul>
</details>

<details>
  <summary>선택도는 뭔가요?</summary>
  <ul>
    <li>선택도는 전체 데이터 중에서 특정 조건(조건절)을 만족하는 데이터의 비율, 즉 전체 행 대비 유니크한 값의 분포 정도를 나타냅니다. 이는 쿼리 결과로 얼마나 많은 행이 반환될지 예측하는 척도입니다. </li>
  </ul>
</details>

<details>
  <summary> true 또는 false 값을 갖는 column에서, true 1%, false 99%의 비율로 구성된 상황에서는 index를 거는게 좋을까요?</summary>
  <ul>
    <li>아무리 1%, 99%로 비율에 차이가 있어도, true / false 두 종류로만 나눠지는 경우에는 카디널리티가 매우 낮게 됩니다. 이 경우, index가 주는 이점이 매우 적고 오히려 저장공간 차지와 데이터 수정시 성능저하등을 고려하여 index를 생성하지 않는 것이 좋습니다. </li>
    <li>또한 true의 경우 선택도가 낮을 수 있으나 false의 경우 선택도가 매우 높아져 비효율적입니다. </li>
  </ul>
</details>

<details>
  <summary> 데이터를 검색을 할 때 hash table의 시간복잡도는 O(1)이고 b+tree는 O(logn)으로 더 느린데 왜 index는 hash table이 아니라 b+tree로 구현되나요?</summary>
  <ul>
    <li>Hash table을 사용하면 하나의 데이터를 탐색하는 시간은 O(1)로 b+tree보 다 빠르지만, 값이 정렬되어 있지 않기 때문에 부등호를 사용하는 query에 대해서는 매우 비효율적이게 되어 데이터를 정렬해서 저장하는 b+tree를 이용합니다.</li>
    <li>B+ 트리는 항상 정렬된 상태를 유지해 부등호 연산이 쉽고, 데이터 수정/삽입/삭제 연산에도 항상 O(logN)의 복잡도를 유지합니다.</li>
  </ul>
</details>

<details>
  <summary> B- Tree와 B+ Tree에 대해 설명해주세요</summary>
  <ul>
    <li>B- Tree는 이진 탐색 트리와 유사한 자료구조 입니다. 자식 노드를 둘 이상 가질 수 있고 balanced Tree라는 특징이 있습니다. 따라서 탐색 연산에 O(log N)의 복잡도를 가집니다. 모든 노드들에 대해 값을 저장하고 있으며 포인터 역할을 동반합니다.</li>
    <li>B+ 트리는 B-Tree를 개선한 형태의 자료구조입니다. 값을 리프노드에만 저장하며 리프노드들 끼리는 링크드리스트로 연결되어 있기 때문에 부등호문 연산에 효과적입니다. 리프 노드를 제외한 노드들은 포인터의 역할만을 수행합니다.</li>
  </ul>
</details>

<details>
  <summary> DML이 일어날때의 상황을 말해주세요</summary>
  <ul>
    <li>INSERT 작업에서는 기존 block에 여유가 없을때 새로운 데이터가 입력되면, 새로운 block을 할당받은 후 키를 옮기는 작업을 수행합니다. index split 작업동안 해당 블록의 키값에 대해 DML이 블로킹됩니다. 이때 block의 논리적인 순서와 물리적인 순서가 달라져 인덱스 조각화 현상이 발생할 수 있습니다. </li>
    <li>DELETE 작업에서는, 테이블에서 데이터가 delete되면 데이터가 지워지고 다른 데이터가 그 공간을 사용할 수 있습니다. 하지만 인덱스에서 데이터가 delete되는 경우는 데이터가 지워지지 않고 사용 안됨 표시만 해둡니다. 그래서 테이블의 데이터 수와 인덱스의 데이터 수가 달라질 수 있습니다.</li>
    <li>UPDATE 작업에서는, 인덱스는 업데이트 할 수 없어 delete를 먼저 수행한 후 새로운 insert를 수행하게 됩니다.</li>
  </ul>
</details>

<details>
  <summary> 인덱스 조각화를 해결하기 위해서는 어떻게 해야 할까요?</summary>
  <ul>
    <li>기존 인덱스를 삭제하고 새로운 인덱스를 생성하여 물리적으로 연속되게 위치하도록 재구성 하는 방법이 있습니다.다만 대규모 데이터의 경우 시간이 오래 걸릴 수 있으며 해당 테이블이 잠길 수 있습니다. </li>
    <li>또한 인덱스의 논리적인 순서는 유지하되 물리적으로 연속되게 위치하도록 물리적으로 인접한 블록들을 다시 정렬하여 공간을 압축합니다. 완벽하게 해결할 수 없지만 서비스 중에서도 변경할 수 있어 중단 시간을 최소화 할 수 있습니다.</li>
  </ul>
</details>

## JDBC

<details>
  <summary> Statement와 PreparedStatement를 비교해서 설명해주세요 </summary>
  <ul>
    <li>Statement는 정적인 SQL을 실행할 때 사용되는 가장 기본적인 SQL 실행 도구입니다. SQL 구문을 문자열로 직접 작성해서 실행됩니다. SQL구문이 매번 서버에서 재 컴파일되어 비효율적이고, SQL Injection 공격에 취약하다는 단점이 있습니다. </li>
    <li>PreparedStatment는 동적 SQL을 처리할 수 있는 SQL 실행 도구입니다. 물음표로 값을 바인딩하고 쿼리를 미리 컴파일 해둡니다. 쿼리를 미리 컴파일 해두기때문에 반복 실행시 빠르고, 입력값이 자동으로 이스케이프 처리가 되어 SQL 인젝션을 방지할 수 있으며 가독성과 유지보수성이 좋다는 장점이 있습니다.</li>
    <li>그렇다고 PreparedStatment가 항상 빠르다고 할 수는 없습니다. 컴파일 파싱 실행은 SQL 수행시간 중 극히 일부분이며 대부분은 디스크 IO에서 발생하기 때문입니다. 그렇다 하더라도 PreparedStatment는 SQL 인젝션이 방지되고 재사용성이 높고 DB 캐시를 사용할 수 있다는 장점때문에 사용이 권장됩니다.</li>
  </ul>
</details>

<details>
  <summary> JDBC에 대해 설명해주세요 </summary>
  <ul>
    <li>JDBC는 Java 언어로 작성된 애플리케이션이 데이터베이스와 통신하고 데이터를 조작할 수 있도록 표준화된 방법을 제공하는 Java API입니다. JDBC는 Java 애플리케이션이 특정 DBMS의 내부 구현 방식에 관계없이 동일한 코드를 사용하여 데이터베이스에 접근하도록 돕는 표준 인터페이스 역할을 합니다.</li>
  </ul>
</details>

<details>
  <summary> JDBC는 하는일이 뭔가요? </summary>
  <ul>
    <li>Connection 생성, statement, resultset등 자원의 생성과 반환, resultset loop 처리, 예외 처리 및 반환, 트랜잭션 처리를 담당합니다. 개발자는 데이터 소스 설정, sql문 작성, 결과 처리만 해주면 나머지는 프레임워크가 알아서 작업을 수행해줍니다.</li>
  </ul>
</details>

## 클러스터링/레플리케이션 (분산 환경)

<details>
  <summary> RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요. </summary>
  <ul>
    <li>RDBMS에서 레플리케이션은 일반적으로 마스터-슬레이브 구조로 되어있으며, 비동기식 복제를 이용해 데이터를 동기화합니다. 마스터 노드는 모든 쓰기 작업과 트랜잭션을 처리하며 변경 로그를 남깁니다. 슬레이브 노드는 이 변경 로그를 받아와 순차적으로 처리하며, 주로 읽기 연산을 수행합니다. 주로 읽기 부하 분산과 장애 복구등의 목적으로 사용하며, 처리 지연이 발생해 일시적으로 데이터가 데이터가 불일치할 수 있습니다.</li>
    <li>RDBMS에서 클러스터링은 여러 서버가 하나의 공유 디스크에 접근하여 액티브-스탠바이로 형태로 구성되며 고가용성을 확보합니다. </li>
    <li>NoSQL에서 레플리케이션은 일반적으로 Replica Set 방식을 사용합니다. 샤딩된 데이터 또는 전체 데이터의 복사본을 여러 노드에 저장하여 가용성을 확보합니다.프라이머리 노드와 세컨더리 노드를 두어 프라이머리 노드에서 쓰기 작업을 수행하고 세컨더리 노드에 복제합니다. 장애가 발생할 경우 세턴더리가 자동으로 프라이머리로 승격됩니다. </li>
    <li>NoSQL에서 클러스터링은 전체 데이터를 수평적으로 나누어 여러대의 노드에 분산 저장하는 샤딩 방식을 사용합니다. 샤딩 키를 기준으로 데이터가 나뉘며, 갹 샤드는 데이터의 일부분만을 가집니다. 쓰기/읽기 부하를 분산하고 단일 서버 용량의 한계를 극복하는데 사용됩니다. </li>
  </ul>
</details>

<details>
  <summary> 이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요? </summary>
  <ul>
    <li>RDBMS에서는 강한 일관성을 위해 여러 노드에 걸친 트랜잭션을 2PC(Two-Phase Commit)으로 관리합니다. 강한 일관성을 유지하지만 느리고, 코디네이터 장애시 blocking이 발생할 수 있습니다.</li>
    <li>Nosql에서는 대규모 확장성과 가용성을 중시하기 때문에 CAP이론에 따라 일시적인 불일치를 허용하고, 최종적인 일치를 목표로 합니다.</li>
  </ul>
</details>


<details>
  <summary> 2PC가 뭔가요?</summary>
  <ul>
    <li>분산 트랜잭션을 여러 노드에 걸쳐 수행할 때, 모든 노드가 같이 커밋하거나 같이 롤백하도록 보장하는 방식입니다. prepare 단계에서 coordinator가 각 노드에 커밋 가능한지 요청을 보내고 모든 노드에서 응답이 오면 커밋을 수행합니다. 
      한개의 노드라도 실패가 오면 다른 모든 커밋을 롤백합니다. 강한 일관성을 보장할 수 있지만 코디네이터 장애시 blocking에 걸릴 수 있고 네트워크 지연시 모든 트랜잭션이 멈출 수 있다는 단점이 있습니다.</li>
    <li>분산 시스템에서는 DBMS간 분산 트랜잭션을 지원해야 적용이 가능하고, 동일 제품군이여야 합니다. NoSQL와 RDBMS와 같이 제품군이 다르면 구현하기 어렵습니다. 또한 보통 하나의 API 엔드포인트를 통해 요청이 들어오고 내부적으로 DB가 분산되어 있을때 사용되지만 MSA에서는 각 서비스에서 담당하므로 구현이 용이하지 않습니다.</li>
  </ul>
</details>

<details>
  <summary> 3PC가 뭔가요?</summary>
  <ul>
    <li>2PC의 단점을 보완하기 위해 non-blocking의 특성을 추가한 프로토콜입니다. can-commit단계에서 각 노드에 커밋 준비 가능한지 확인하고, pre-commit 단계에서 모든 노드에 예비 커밋(로그 기록, 실제 커밋 전 단계)를 지시합니다. 이후 do-commit단계에서 최종 커밋을 수행합니다.
    코디네이터 장애시에도 노드가 스스로 커밋하거나 롤백을 판단할 수 있다는 장점이 있지만 네트워크 비용이 더 커지고, 복잡하여 잘 사용되지 않는 방식입니다.</li>
  </ul>
</details>

<details>
  <summary> TCC가 뭔가요?</summary>
  <ul>
    <li>각 로컬 트랜잭션을 3단계 (시도, 확정, 취소)로 나누어 분산 트랜잭션을 보상 방식으로 처리하는 패턴입니다. 리소스가 경합이 크거나 복구 가능성이 필요한 상황에서 유용하며,먼저 자원을 예약해 임시 상태로 잠금하고, 모든 try가 성공하면 확정해 커밋하고, 일부 실패시 모든 시도를 취소하고 롤백합니다. 동기화된 일관성을 어느정도 유지하면서도 2PC보다 비동기적으로 동작하고, 독립성과 복구 가능성이 높습니다.
    하지만 구현 복잡도가 높고, 각 단계별 로직을 직접 구현해야하는 단점이 있습니다.</li>
  </ul>
</details>

<details>
  <summary> SAGA패턴이 뭔가요?</summary>
  <ul>
    <li>SAGA 패턴은 여러 개의 마이크로서비스에 걸쳐 하나의 트랜잭션을 처리할 때,2PC 같은 강한 일관성 대신 보상 트랜잭션(Compensation) 을 이용해 최종 일관성(Eventual Consistency) 을 보장하는 분산 트랜잭션 패턴입니다. 전체 업무 흐름을 여러 단계의 로컬 트랜잭션(Local Transaction) 으로 나누고, 중간에 하나라도 실패하면 이전 단계에서 수행한 작업들을 되돌리는 보상 트랜잭션을 순차적으로 실행합니다.
      구현 방식은 두 가지로 나뉩니다. Orchestration 방식은 중앙 조정자가 각 서비스의 트랜잭션을 순서대로 호출하며 실패 시 보상 호출을 수행하고, Choreography 방식은 이벤트 기반으로 각 서비스가 자율적으로 이벤트를 발행하고 구독하면서 보상을 수행합니다.</li>
    <li>Choreography 방식은 이해하기 쉽고 구축하기 쉽다는 장점이 있지만, 어떤 서비스가 어떤 이벤트를 수신하는지 추측하기 어렵고, 트랜잭션이 많은 서비스를 거쳐야 할 때 상태를 인지하기 어렵고, 모든 서비스는 호출되는 각 서비스의 이벤트를 확인해야한다는 단점이 있습니다.</li>
    <li>오케스트레이션 방식은 서비스 간의 종속성이 없고, 오케스트레이터가 호출하기 때문에 분산 트랜잭션의 중앙화가 이루어져 서비스의 복잡성이 줄어들고 롤백을 쉽게 관리할 수 있다는 장점이 있습니다. 하지만 모든 트랜잭션을 오케스트레이터가 관리하기에 로직이 복잡할 수 있고 해당 서비스가 추가적으로 들어가고 이를 관리해야한다는 단점이 있습니다.</li>
  </ul>
</details>

<details>
  <summary> OutBox패턴이 뭔가요?</summary>
  <ul>
    <li>아웃박스 패턴은 데이터베이스의 변경과 메시지 브로커로의 이벤트 발행을 원자적으로 처리하기 위한 패턴입니다. 마이크로서비스 환경에서는 한 서비스가 DB에 데이터를 저장하고, 동시에 카프카나 래빗엠큐와 같은 메시지 브로커로 이벤트를 발행해야 할 때가 많습니다. 그런데 두 작업이 별개의 시스템에서 수행되기 때문에 DB만 커밋되고 메시지가 전송되거나 그 반대가 되는 문제가 발생할 수 있습니다.</li>
    <li>아웃박스 패턴은 패턴은 이 문제를 해결하기 위해 비즈니스 데이터와 이벤트 데이터를 같은 DB 트랜잭션 안에서 함께 저장합니다. DB에 실제 데이터와 이벤트 레코드인 Outbox 테이블을 한번에 insert합니다. 이후 별도의 백그라운드 프로세서나 CDC도구가 그 테이블을 읽어 카프카에 이벤트를 발행합니다. 
      이를 통해 DB와 이벤트 발행의 원자성을 확보하고 장애가 나더라도 outbox 테이블에 남은 이벤트를 재시도할 수 있어 이벤트 유실이나 중복 발행없이 안정적인 비동기 처리가 가능해집니다. 하지만 별도의 outbox 테이블 및 메시지 중복 처리가 필요하다는 단점이 있습니다.</li>
  </ul>
</details>
