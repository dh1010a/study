# CS 면접을 위한 자바 질문리스트

<details>
  <summary>자바와 C나 C++과의 차이점은 뭘까요?</summary>
  <ul>
    <li> 자바와 C/C++의 가장 큰 차이는 메모리 관리 방식과 실행 구조입니다. 자바는 JVM 위에서 동작하며 GC가 자동으로 메모리를 회수해 주기 때문에 안전성과 생산성이 높습니다. 반면 C/C++은 개발자가 직접 메모리를 관리해성능 최적화가 용이하고 저수준의 메모리 접근이 가능합니다.</li>
  </ul>
</details>

<details>
  <summary>자바 언어의 장단점에 대해 말해주세요</summary>
  <ul>
    <li> 자바는 운영체제에 독립적이고, 객체 지향언어이기 때문에 유지보수와 확장성에 뛰어납니다. JVM이 자동으로 메모리를 관리해줘 비즈니스 로직에 집중할 수 있고, 멀티 스레드를 쉽게 구현할 수 있다는 장점이 있습니다. </li>
    <li> 다만 자바는 비교적 속도가 느립니다. 한번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고 JVM에 의해 기계어로 번역되고 실행되는 과정을 거치기 때문에 C나 C++의 컴파일 단계에서 만들어지는 완전한 기계어보다는 속도가 느립니다. 그러나 하드웨어의 성능 향상과 바이트 코드를 기계어로 변환해주는 JIT 컴파일러 같은 기술 적용으로 그 격차가 많이 줄었으며, 예외 처리가 불편한 단점이 있습니다.</li>
  </ul>
</details>

<details>
  <summary>JIT 컴파일러가 뭔가요?</summary>
  <ul>
    <li> JIT 컴파일러는 JVM이 바이트코드를 실행하면서, 자주 실행되는 코드(Hotspot)를 감지해 해당 부분을 네이티브 머신 코드로 동적 컴파일하는 기술입니다. 처음에는 인터프리터로 실행되지만, 특정 코드가 반복되면
JIT이 그 부분을 직접 기계어로 변환해 캐싱하고, 이후에는 기계어로 바로 실행되기 때문에 C/C++ 수준으로 빠른 성능을 제공합니다</li>
  </ul>
</details>

<details>
  <summary>자바 애플리케이션의 실행과정에 대해 말해주세요</summary>
  <ul>
    <li> 컴파일러가 자바 소스를 바이트코드로 변환합니다. 클래스 로더가 바이트 코드를 런타임 데이터 영역에 로드시킵니다. 로딩된 바이트코드가 실행엔진에 의해서 실행되게 됩니다. </li>
  </ul>
</details>

<details>
  <summary>자바 데이터 타입에 대해 설명해주세요</summary>
  <ul>
    <li> 자바 데이터 타입은 기본 타입과 참조 타입으로 나뉩니다. 기본 타입은 8가지로 정수·실수·문자·논리 형태이며 기본 타입의 크기가 작고 고정적이기 때문에 스택에 값 자체가 저장됩니다. 참조 타입은 객체의 주소를 저장하며 실제 값은 힙에 존재합니다. 기본 타입은 null을 가질 수 없지만 참조 타입은 null이 가능하고, Wrapper 클래스를 통해 기본 타입도 객체처럼 사용할 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary>Wrapper class</summary>
  <ul>
    <li> 프로그램에 따라 기본 타입의 데이터를 객체로 취급해야 하는 경우가 있습니다. 예를 들어, 메소드의 인수로 객체 타입만이 요구되면, 기본 타입의 데이터를 그대로 사용할 수 수는 없습니다. 또는 컬렉션에는 기본 타입을 넣을 수 없습니다. 이때, 기본 타입의 데이터를 먼저 객체로 변환한 후 작업을 수행해야 합니다. 8개의 기본 타입에 해당하는 데이터를 객체로 포장해 주는 클래스를 래퍼 클래스(Wrapper class)라고 합니다. 래퍼 클래스는 각각의 타입에 해당하는 데이터를 인수로 전달받아, 해당 값을 가지는 객체로 만들어 줍니다. 이러한 래퍼 클래스는 모두 java.lang 패키지에 포함되어 제공됩니다.</li>
  </ul>
</details>

<details>
  <summary>Boxing, Unboxing</summary>
  <ul>
    <li> 래퍼 클래스(Wrapper class)는 산술 연산을 위해 정의된 클래스가 아니므로, 인스턴스에 저장된 값을 변경할 수 없습니다. 단지, 값을 참조하기 위해 새로운 인스턴스를 생성하고, 생성된 인스턴스의 값만을 참조할 수 있습니다.</li>
    <li> 기본 타입의 데이터를 래퍼 클래스의 인스턴스로 변환하는 과정을 박싱(Boxing), 래퍼 클래스의 인스턴스에 저장된 값을 다시 기본 타입의 데이터로 꺼내는 과정을 언박싱(UnBoxing)이라고 합니다.</li>
  </ul>
</details>

<details>
  <summary>AutoBoxing, AutoUnboxing</summary>
  <ul>
    <li> JDK 1.5부터는 박싱과 언박싱이 필요한 상황에서 자바 컴파일러가 이를 자동으로 처리해 줍니다. 이렇게 자동화된 박싱과 언박싱을 오토 박싱(AutoBoxing)과 오토 언박싱(AutoUnBoxing)이라고 부릅니다.</li>
    <li> 오토 박싱을 이용하면 new 키워드를 사용하지 않고도 자동으로 Character 인스턴스를 생성할 수 있다. 반대로 charValue() 메소드를 사용하지 않고도, 오토 언박싱을 이용하여 인스턴스에 저장된 값을 바로 참조할 수 있습니다.
</li>
    <li> 래퍼 클래스의 비교 연산도 오토언박싱을 통해 가능해지지만, 인스턴스에 저장된 값의 동등 여부 판단은 비교 연산자인 동등 연산자를 사용해서는 안되면, equals 메서드를 사용해야만 합니다. 래퍼 클래스도 객체이므로 두 인스턴의 값을 비교하는것이 아니라 두 인스턴스의 주소값을 비교하기 때문입니다.
</li>
  </ul>
</details>

<details>
  <summary>클래스와 객체와 인스턴스가 뭔가요?</summary>
  <ul>
    <li> 클래스는 객체를 만들기 위한 설계도이고, 객체는 그 설계도를 기반으로 생성된 실체입니다. 인스턴스는 ‘객체가 어떤 클래스에서 만들어졌는지’를 나타내는 관계적 표현으로, 결국 객체는 클래스의 인스턴스라고 말할 수 있습니다.</li>
    <li> 클래스는 추상화된 명세이고, 객체는 그 명세를 기반으로 소프트웨어 세계에 만들어진 실체입니다. 인스턴스는 이 객체가 특정 클래스의 구체적인 예시라는 관계를 강조할 때 사용하는 용어입니다. 즉 객체는 넓은 개념이고, 인스턴스는 ‘A는 B의 인스턴스다’처럼 관계 중심의 표현입니다.oop의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 '인스턴스'라고 부르기도 합니다.</li>
  </ul>
</details>

<details>
  <summary>인터페이스와 추상 클래스에 대해 설명해주세요</summary>
  <ul>
    <li> 추상 메서드는 abstract 키워드와 함께 원형만 선언되고, 코드는 작성되지 않은 메서드입니다.</li>
    <li> 추상 클래스는 abstract 키워드로 선언된 클래스입니다. 추상 메서드를 최소 한 개 이상 가지고 abstract로 선언된 클래스입니다. 한 개의 추상 메서드를 포함하는 경우 반드시 추상 클래스로 선언해야 합니다. 추상 메서드가 없어도 abstract로 추상 클래스를 선언할 수 있습니다(클래스 자체를 인스턴스화 하면 안되는 경우). 서브 클래스에서 슈퍼 클래스의 모든 추상 메서드를 오버라이딩하여 실행하능한 코드로 구현합니다. 공통 속성과 공통 동작은 추상 클래스에서 정의하고, 구체적인 동작은 하위 클래스가 구현하도록 강제할 수 있습니다. 추상 클래스의 추상 메서드를 자식 클래스가 구체화하여 그 기능을 확장하는데에 목적이 있습니다.</li>
    <li> 인터페이스는 추상 메서드와 상수만을 포함하며, interface 키워드를 사용하여 선언합니다. 인터페이스를 상속받고 추상 메서드를 모두 구현한 클래스를 작성하며, implements 키워드를 사용하여 구현합니다. 상속받은 서브 클래스에게 구현할 메서드들의 원형을 모두 알려주어, 클래스가 자신의 목적에 맞게 메서드를 구현하도록 하는것입니다. 구현객체의 같은 동작을 보장하기 위한 목적이 있습니다. 서로 관련이 없는 클래스에서 공통적으로 사용하는 방식이 필요하지만 기능을 구현할 필요가 없는 경우게 사용합니다.</li>
    <li> 인터페이스는 상수 필드와 추상 메서드만으로 구성됩니다. 모든 메서드는 추상 메서드로서, abstract public 속성이며 생략 가능합니다. 상수는 public static final 속성이며, 생략하여 선언할 수 있습니다. 인터페이스를 상속해서 또다른 인터페이스를 만들 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary>인터페이스와 추상 클래스의 공통점과 차이점은 뭔가요?</summary>
  <ul>
    <li> 공통점은 인스턴스(객체)는 생성할 수 없습니다. 선언만 있고 구현 내용이 없으며, 자식 클래스가 메서드의 구체적인 동작을 구현하도록 책임을 위임합니다. 자식 클래스가 메서드의 구체적인 동작을 구현하도록 책임을 위임합니다.</li>
    <li> 차이점으로는 추상 크래스는 추상 메서드를 자식 클래스가 구체화  하여 그 기능을 확장하는데에 목적이 있습니다.(상속을 위한 부모클래스) 반면 인터페이스는 서로 관련이 없는 클래스에서 공통적으로 사용하는 방식이 필요하지만 기능을 각각 구현할 필요가 있는 경우에 사용합니다.(구현 객체의 같은 동작을 보장)</li>
    <li> 추상클래스는 클래스이고 단일 상속입니다. 인터페이스는 클래스가 아니며 다중 상속이 가능합니다. 추상 클래슨 is a kind of, can do this.</li>
  </ul>
</details>

<details>
  <summary>자바의 메모리 구조에 대해 말해주세요</summary>
  <ul>
    <li> 자바 메모리 구조는 크게 5가지 영역으로 구분됩니다. 스레드마다 PC Register, JVM Stack, Natice Method Stack이 있습니다. 스레드 공통으로는 Heap과 Method 영역이 있습니다. PC Register는 현재 수행중인 JVM 명령어가 들어가 있고, JVM 스택은 호출된 메서드의 매개변수, 지역변수, 리턴 정보가 저장됩니다. 네이티브 메서드 스택은 자바 외의 언어인 C나 C++과 같은 것들을 수행하기 위한 영역입니다. 메서드 영역은 클래스 별로 전역변수, 정적 변수, 메소드 정보들이 저장됩니다. 힙 영역은 런타임중 생성되는 객체들이 동적으로 할당되는 것입니다.</li>
    <li> 힙 영역에는 permanent Generation, New/Young 영역, Old 영역이 있습니다. 퍼머넌트 제너레이션은 생성된 객체들 정보의 주소값이 저장되어있으며, 클래스나 메서드에 대한 메타정보가 저장됩니다. 또한 리플렉션을 사용하여 동적으로 클래스가 로딩되는 경우 사용합니다. new/young은 에덴에서 객체들이 최초로 생성되게 되며 서바이벌 0/1은 에덴에서 참조되는 객체들이 저장되는 공간입니다. 올드 영역은 뉴 영역에서 일정시간 참조되고 살아남은 객체들이 저장되고 있던 에덴에 객체가 가득차면 마이너 gc가 발생하는데, 이때 에덴에 있는 값들을 서바이벌 1 영역에 복사하고 나머지 영역의 객체를 삭제합니다. 다음 GC에는 서바이벌 1 -> 0 으로 복사하며 이 과정을 반복하는데, 일정 횟수 이상 살아남으면 올드 영역으로 이동합니다. </li>
  </ul>
</details>

<details>
  <summary>네이티브 메소드는 어떻게 자바 코드에서 호출되나요? </summary>
  <ul>
    <li> 네이티브 메소드는 JNI(java native interface) 라는 표준 프로그래밍 인터페이스를 통해 호출됩니다. 자바 개발자가 네이티브 키워드를 사용하여 메소드를 선언하며 JVM은 런타임에 JNI를 통해 실제 실제 네이티브 라이브러리 파일에 로드된 C/C++ 코드를 찾아 실행하게 됩니다.</li>
  </ul>
</details>

<details>
  <summary>네이티브 메소드 영역이 필요한 이유는?</summary>
  <ul>
    <li> 이 영역이 필요한 이유는 자바가 운영체제의 특정 기능이나 하드웨어에 직접 접근해야 할때, 또는 성능 최적화를 위해 플랫폼 의존적인 코드를 사용해야 할 때 자바 메모리 모델의 제약을 벗어나기 위함입니다.</li>
  </ul>
</details>

<details>
  <summary>자바에서 String, StringBuffer, StringBuilder에 대해 설명해주세요</summary>
  <ul>
    <li> String은 new 연산을 통해 생성된 인스턴스의 메모리 공간은 불변하며, GC 대상입니다. 문자열 연산시 새로 객체를 만드는 오버헤드가 있으며 멀티스레드에서 동기화를 신경 쓸 필요가 없다는 장점이 있습니다. 문자열 연산이 적고, 조회가 많은 멀티스레드 환경에서 좋습니다.</li>
    <li> String빌더와 스트링버퍼는 new 연산으로 클래스를 한번만 만들고, 연산시 새로 객체를 만들지 않고 크기를 변경시킵니다. 메서드도 동일한 공통점을 가지고 있습니다. 차이점으로는 스트링 버퍼는 멀티스레드 환경에서 안전하지만 스트링 빌더는 스레드 세이프 하지 않습니다. 그래서 스트링 버퍼는 문자열 연산이 많은 멀티 스레드 환경, 스트링 빌더는 문자열 연산이 많은 싱글 스레드 환경이나 동시성을 고려하지 않는 환경에서 적합니다.</li>
    <li> 스트링 버퍼는 모든 메서드에 싱크로나이즈드가 적용되어 있다. 스트링 빌더는 동기화가 없는 대신 훨씬 빠르다.</li>
  </ul>
</details>

<details>
  <summary>자바의 버전 8의 가장 큰 변화가 뭔가요?</summary>
  <ul>
    <li> 자바 8은 멀티 코어가 대중화 됨에 따라 병렬 처리를 더 잘 지원하기 위한 기능들이 추가되었습니다. Stream API, Method Reference & Lamda, Default Method 가 크게 추가되었습니다.</li>
    <li> 메서드 레퍼런스와 람다를 자바에서 활용할 수 있게 되면서, 동적 파라미터를 구현할 수 있게 되었습니다. 기존에도 익명 클래스로 구현은 가능했지만 코드가 복잡해지고 재사용이 힘든 단점을 해결할 수 있게 되었습니다. </li>
  </ul>
</details>

<details>
  <summary>스트림이란 뭔가요?</summary>
  <ul>
    <li> 스트림은 자바 8에서 추가된 데이터 처리용 API로, 데이터를 내부 반복 방식으로 처리하며 원본을 변경하지 않습니다. filter, map, sorted 같은 중간 연산과 collect, forEach 같은 최종 연산을 파이프라인 형태로 구성할 수 있어 코드가 선언적이고 간결해집니다. 기본은 단일 스레드지만, 필요하면 parallelStream을 통해 손쉽게 병렬 처리를 적용할 수 있는 점도 특징입니다.</li>
  </ul>
</details>

<details>
  <summary>스트림의 특징은 뭔가요?</summary>
  <ul>
    <li> 병렬 처리에 유리하다는 특징이 있습니다. 각 스레드가 개별 큐를 가지고 있으며 놀고있는 스레드가 있으면 일하는 스레드의 작업을 가져와 수행하며 최적의 성능을 도출하고, 코어의 수가 많을수록, 처리할 데이터가 많고 처리 시간이 길수록 병렬 처리 성능이 향상됩니다. 또한 원본 데이터 변경이 불가능하다는 점이 있습니다. 데이터를 저장하지 않으며 변경되는 내용은 Stream을 지원하는 컬렉션의 데이터입니다. 또한 lazy 특성이 있는데, 이는 중간 연산과 최종 연산이 있는데 중간 연산을 여러개 작성 시 모두 합쳐서 진행하고, 합쳐진 연산을 최종 연산에서 한번에 처리하는것입니다. 중간 연산에는 filter,map 등이 있고 최종 연산에는 allMatch, count, collect 등이 있으며 중간 연산은 데이터 처리된 스트림을 반환하여 파이프라이닝 가능합니다.  또한 재사용이 불가능합니다. 최종 연산 완료 후 스트림이 닫히므로 재사용이 불가능합니다.</li>
  </ul>
</details>

<details>
  <summary>스트림은 왜 지연 실행을 하나요?</summary>
  <ul>
    <li> 중간 연산을 죽시 수행하지 않고, 최종 연산 시 필요한 데이터만 처리해 성능을 최적화 하기 위함입니다. 이 덕분에 불필요한 연산을 건너뛰거나 병렬 처리를 효율적으로 할 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary>Map과 flatMap의 차이는 뭔가요?</summary>
  <ul>
    <li> map은 요소를 1ㄷ1로 변환하는 중간 연산이고, flatMap은 map 결과가 리스트나 스트림처럼 여러 요소를 반환할 때 이를 평탄화 해서 하나의 스트림으로 만드는 연산입니다. </li>
  </ul>
</details>

<details>
  <summary>병렬 스트림은 뭔가요?</summary>
  <ul>
    <li> 직렬 스트림은 요소를 하나의 스레드에서 순차적으로 처리하는 방식이고, 병렬 스트림은 데이터를 여러 조각으로 나누어 ForkJoinPool을 통해 여러 스레드에서 동시에 처리합니다. 병렬 스트림은 CPU 연산에서는 유리하지만 순서 보장이 어렵고 공유 자원 접근 시 동시성 문제가 생길 수 있습니다.</li>
    <li> 병렬 스트림은 ForkJoinPool.commonPool을 공유하기 때문에 성능 제어가 어렵고, 순서 보장이나 동시성 문제가 발생하기 쉽습니다. CPU 연산량이 큰 경우에만 유리하고, 대부분 경우 오히려 직렬 스트림보다 느립니다.</li>
  </ul>
</details>

<details>
  <summary>스트림은 언제 쓰면 좋고, 언제 쓰면 안좋나요?</summary>
  <ul>
    <li> 컬렉션 데이터를 가공하거나, filter/map/reduce 패턴이 많거나, 순차적인 데이터 처리나 병렬 처리를 편리하게 쓰고 싶을때 사용하면 좋습니다. 반면 극단적으로 많은 데이터를 다룰때나 디버깅이 중요한 코드, 성능이 중요한 코드, 상태 변화가 필요한 로직 등에는 쓰면 안좋습니다.</li>
  </ul>
</details>

<details>
  <summary>자바 8과 17의 차이점이 뭔가요?</summary>
  <ul>
    <li> 첫째, 성능과 GC가 많이 개선됐습니다. Java 17은 G1GC가 기본이고, 더 빠르고 안정적인 GC가 도입돼 서버 처리 성능과 지연시간이 줄어들었습니다. 둘째, 개발 생산성이 좋아졌습니다. var 키워드, text block("""), record 같은 문법이 추가되면서 코드가 훨씬 간결해졌고 DTO 만들 때도 편해졌습니다. 셋째, 보안과 표준 API가 업그레이드되었습니다. HttpClient, TLS 1.3 같은 최신 기능들이 기본 지원됩니다.</li>
  </ul>
</details>

<details>
  <summary>자바는 call-by-value인가요 call-by-reference인가요?</summary>
  <ul>
    <li> 자바는 call-by-value입니다. call-by-value는 함수 호출 시 전달되는 변수 값을 복사해서 인자로 전달합니다. 함수 안에서 인자 값이 변경되더라도 외부 변수의 값은 변경되지 않습니다. 원본의 데이터가 변경될 가능성은 없지만 인자를 넘겨줄때마다 메모리 공간을 할당해야 해서 메모리 공간이 추가적으로 필요합니다. call-by-reference는 함소 호출 시 인자로 전달되는 변수의 레퍼런스를 전달합니다. 따라서 함수 안에서 인자값이 변경되면 원본 값도 변경됩니다. 따라서 원본 값이 변경될 수 있다는 위험이 존재합니다.</li>
    <li> 자바는 call-by-value입니다. 기본형은 값 자체를 복사해서 전달하고 객체는 참조값(주소)를 값을 복사해서 전달하기 떄문에 메서드 안에서 객체 내부는 수정이 가능하지만 참조 자체를 바꾸면 원본에 영향을 주지 않습니다.</li>
  </ul>
</details>

<details>
  <summary>자바에서 직렬화와 역직렬화가 무엇인가요?</summary>
  <ul>
    <li> 직렬화란 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 시스템에서도 사용할 수 있도록 바이트 형태로 데이터를 변환하는 기술입니다. JVM의 메모리(힙 또는 스택)에 상주되어 있는 객체 데이터를 바이트 형태로 변환하는 기술입니다. 직렬화가 되기 위해서는 자바 기본 타입이거나, Serializable 인터페이스를 상속받은 객체여야 하고, ObjectOutputStream 객체를 이용해 직렬화합니다.</li>
    <li> 역직렬화(Deserialization)이란 바이트로 변환된 데이터를 다시 객체로 변환하는 기술을 말합니다. 직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM에 상주시키는 형태의 기술입니다. 역직렬화가 되기 위해서는 직렬화 대상이 된 객체의 클래스가 클래스 패스에 존재해야 하며 import 되어 있어야 합니다. 중요한 점은 직렬화와 역직렬화 진행하는 시스템이 서로 다를 수 있다는 것을 고려해야 합니다.(같은 시스템 내부라도 소스 버전이 다를 수 있음). 자바 직렬화 대상 객체는 동일한 serialVersionUID를 가지고 있어야 합니다. ObjectInputStream 객체를 이용해서 역직렬화 합니다.</li>
  </ul>
</details>

<details>
  <summary>serialVersionUID가 뭔가요?</summary>
  <ul>
    <li> serialVersionUID는 자바 직렬화에서 클래스 버전 관리를 위한 고유 ID입니다. 직렬화 된 객체를 역직렬화 할 때 JVM은 스트림에 저장된 serialVersionUID와 현재 클래스의 아이디를 비교해서 일치할 경우에만 역직렬화를 허용합니다. 클래스 구조가 변경되었는데, serialVersionUID가 같으면 데이터 손상 위험이 있고 반대로 자동 생성에 의존하면 사소한 수정에도 UID가 변해서 예외가 납니다.</li>
  </ul>
</details>

<details>
  <summary>자바 컬렉션이 뭔가요? 왜 쓰나요?</summary>
  <ul>
    <li> 자바 커렉션은 데이터를 저장하고 관리하기 위한 자료구조의 표준화된 프레임워크입니다. 리스트, 셋, 맵 인터페이스를 중심으로 다양한 구현체가 제공되어, 개발자가 직접 자료구조를 구현할 필요 없이 효율적으로 데이터를 처리할 수 있기 때문에 사용합니다.</li>
  </ul>
</details>

<details>
  <summary>자바 Set은 왜 중복을 허용하지 않나요?</summary>
  <ul>
    <li> 내부적으로 key만 존재하는 해쉬맵 구조를 사용하기 때문입니다. 즉, 키 중복이 불가능하므로 set도 중복을 허용하지 않습니다. </li>
  </ul>
</details>

<details>
  <summary>java Map 인터페이스 구현체의 종류에 대해 설명해주세요</summary>
  <ul>
    <li> HashMap은 가장 일반적인 비동기 Map이고, LinkedHashMap은 HashMap을 상속해 순서를 유지하며, TreeMap은 레드블랙 트리로 저장되며 기본적으로 오름차순으로 정렬된 Map을 제공합니다. Hashtable은 오래된 동기화 Map이고, ConcurrentHashMap은 고성능 동시성 Map입니다. 업데이트 할때만 동기 처리를 하며 null값을 허용하지 않습니다.</li>
  </ul>
</details>

<details>
  <summary>java Set 인터페이스 구현체의 종류에 대해 설명해주세요</summary>
  <ul>
    <li> HashSet은 저장순서를 유지않는 데이터의 집합입니다. 해시 알고리즘을 사용해 검색 속도가 매우 빠르며 HashMap 인스턴스를 이용해 요소를 저장합니다. LinkedHashSet 저장순서를 유지하며, TreeSet 데이터가 정렬된 상태로 저장되는 이진 탐색 트리의 형태로 요소를 저장합니다. 이진 탐색 트리 중에 성능을 향상시킨 레드 블랙 트리로 구현되어 있습니다.</li>
  </ul>
</details>

<details>
  <summary>java List 인터페이스 구현체의 종류에 대해 설명해주세요</summary>
  <ul>
    <li> ArrayList는 단방향 포인터 구조로 각 데이터에 대한 인덱스를 가지고 있어 검색에 적합합니다. 데이터 삽입, 삭제 시 해당 데이터 이후 모든 데이터가 복사되므로 삽입, 삭제가 빈번한 데이터에 부적합 합니다. LinkedList는 양방향 포인터 구조로 데이터의 삽입, 삭제 시 해당 노드의 주소미나 바꾸면 되므로 삽입, 삭제가 빈번한 데이터에 적합합니다. 검색시 처음부터 노드를 순회하므로 검색에는 부적합하며 스택, 큐, 양방향 큐를 만들기 위한 용도로 쓰입니다. 벡터는 내부에서 자동으로 동기화 처리가 일어나며 성능이 좋지 않고 무거워 잘 쓰지 않습니다. </li>
  </ul>
</details>

<details>
  <summary>자바에서 동기화와 비동기화에 대해 설명해주세요</summary>
  <ul>
    <li> 자바에서 동기화는 여러 스레드가 동일한 자원에 접근할 때 synchronized 등을 사용해 하나의 스레드만 접근하게 만들어 데이터 무결성을 보장하는 개념입니다. 반면 비동기 실행은 작업 호출 후 결과를 기다리지 않고 바로 다음 흐름을 이어가는 방식으로, Future, CompletableFuture, 스레드풀 등을 사용합니다. 즉 ‘동기화/비동기화’는 자원 보호를 의미하고, ‘동기/비동기’는 실행 흐름 방식을 의미합니다. </li>
  </ul>
</details>

<details>
  <summary>자바에서 리플렉션이란 뭔가요?</summary>
  <ul>
    <li> 자바 리플렉션은 자바에서 이미 로딩이 완료된 클래스에서 또 다른 클래스를 동적으로 로딩(Dynamic Loading)하여 생성자(Constructor), 멤버 필드(Member Variables), 그리고 멤버 메서드(Member Method) 등을 사용할 수 있는 기법입니다. </li>
    <li> 자바에서 리플렉션은 실행 중에 클래스와 메서드, 필드 정보를 동적으로 조회하거나 호출할 수 있게 해주는 기능입니다. Spring이 @Autowired나 @RequestMapping 처리할 때와 같이 프레임워크 내부에서 객체를 자동 생성하거나 메서드를 실행하는 데 사용됩니다.</li>
    <li> 실행 시간에 다른 클래스를 동적으로 로딩하여 접근할 때, 클래스와 멤버 필드 그리고 메서드 등에 관한 정보를 얻어야 할 때 사용합니다 예를 들면 JPA와 스프링 프레임워크의 AOP, DI 등을 수행할 때 사용됩니다. 속도가 느리고 캡슐화를 깨기 때문에 일반 비즈니스 로직에서는 사용을 자제해야 합니다. </li>
  </ul>
</details>

<details>
  <summary>자바에서 람다란 뭔가요?</summary>
  <ul>
    <li> 람다는 실행 가능한 코드를 간단한 식 형태로 표현한 익명 함수입니다. 자바는 객체지향 언어라 원래는 메서드를 값처럼 다룰 수 없었지만, 람다를 통해 함수도 값처럼 전달할 수 있게 되어 함수형 프로그래밍 패러다임을 지원합니다. Runnable, Comparator, Function 같은 ‘함수형 인터페이스’를 구현할 때 사용되며, 스트림 API(map, filter 등)에서 중요하게 사용됩니다. </li>
  </ul>
</details>

<details>
  <summary>람다의 장단점이 뭔가요?</summary>
  <ul>
    <li> 람다는 기존에 익명함수로 작성하던 코드를 줄여 간단하게 작성 가능하고 가독성이 증가하며, 병렬 프로그래밍에 용이합니다. 다만 남용하면 코드를 이해하는데 어려움이 있으며 재귀 활용 및 디버깅이 어렵습니다. </li>
  </ul>
</details>

<details>
  <summary>람다는 어떻게 동작하나요?</summary>
  <ul>
    <li> 자바 람다는 익명 클래스처럼 .class 파일을 만들지 않습니다(컴파일 시점). 컴파일러는 람다 구문을 invokedynamic 명령으로 바이트코드를 생성하고, JVM이 실행 시점에 LambdaMetafactory 를 통해 필요한 함수형 객체를 동적으로 생성(런타임)합니다. 이 방식은 클래스 난립을 막고 성능(JIT 최적화)을 크게 올릴 수 있어, 익명 클래스보다 훨씬 효율적입니다. </li>
  </ul>
</details>

<details>
  <summary>익명 내부 클래스가 뭔가요?</summary>
  <ul>
    <li> 익명 내부 클래스는 이름 없는 클래스를 즉석에서 정의해 객체를 생성하는 방식입니다. 인터페이스나 추상 클래스를 간단히 구현할 때 사용하며, 파일 없이 코드 한 곳에서만 쓸 수 있어서 편하지만 문법이 장황해져서 Java8부터는 람다로 대체되는 경우가 많습니다.</li>
  </ul>
</details>

<details>
  <summary>람다와 익명 내부 클래스의 차이점?</summary>
  <ul>
    <li> 람다는 함수형 인터페이스를 한 줄로 구현하는 익명 함수이고, 익명 내부 클래스는 새로운 클래스를 생성해 인터페이스나 클래스를 즉석에서 구현하는 방식입니다. 둘의 가장 큰 차이는 this 바인딩과 클래스 생성 여부입니다. 람다는 this가 외부를 가리키고 추가 클래스 생성이 없지만, 익명 내부 클래스는 자신의 클래스를 생성하고 this는 자신을 가리킵니다.</li>
  </ul>
</details>

<details>
  <summary>함수형 인터페이스란 뭔가요?</summary>
  <ul>
    <li> 추상 메서드를 딱 1개만 가지는 인터페이스입니다. 람다 표현식이 적용될 수 있는 인터페이스이며, @FunctionalInterface로 표현 가능합니다.Runnable, Callable, Function 등이 대표적입니다. </li>
    <li> <img width="511" height="230" alt="image" src="https://github.com/user-attachments/assets/b40a5c76-8f5b-4597-99cb-ae3328a8fac1" />
 </li>
  </ul>
</details>

<details>
  <summary>함수형 프로그래밍이란 뭔가요?</summary>
  <ul>
    <li> 함수형 프로그래밍은 불변성과 순수 함수를 기반으로 상태 변경을 최소화하는 프로그래밍 패러다임입니다. 함수 자체를 값처럼 전달하고 조합하여 사용하며, 자바에서는 람다와 스트림 API를 통해 부분적으로 FP 스타일을 지원합니다. 특징으로는 불변성(값을 변경하지 않고 새로운 값을 만들어 냄), 선언형 프로그래밍(어떻게 보다 무엇에 집중), 고차함수(함수를 인자로 받거나 반환하는 함수) 등이 있습니다. </li>
  </ul>
</details>

## 객체 지향

<details>
  <summary>OOP에 대해 설명해주세요</summary>
  <ul>
    <li> OOP는 객체를 중심으로 프로그램을 설계하는 방식으로, 객체가 상태와 행동을 함께 가지며 시스템을 구성합니다. 핵심 특징은 추상화/캡슐화/상속/다형성 네 가지이며, 이를 통해 코드의 재사용성, 확장성, 유지보수성을 크게 높일 수 있습니다</li>
    <li> 객체는 현실 세계의 실체 및 개념을 반영하는 상태와 행위를 정의한 데이터의 집합입니다. 객체 지향은 각자의 역할을 지닌 객체들끼리 서로 메시지를 주고받으며 동작할 수 있도록 프로그래밍 하는것입니다.</li>
  </ul>
</details>

<details>
  <summary>OOP의 특징에 대해 설명해주세요</summary>
  <ul>
    <li> 추상화(Abstraction) : 구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념(집합)으로 다루는 것입니다.</li>
    <li> 캡슐화(Encapsulation): 필요가 없는 정보는 외부에서 접근하지 못하도록 제한하는 정보를 은닉하는 것입니다. 높은 응집도와 낮은 결합도를 유지하여 유연함과 유지보수성을 증가시킵니다.</li>
    <li> 상속(Inheritance) : 여러 개체들이 가진 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립시키는 과정입니다. 기존 클래스를 확장해 재사용하는 개념입니다. </li>
    <li> 다형성(Polymorphism) : 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력입니다. 오버라이딩이나 오버로딩이 있습니다.</li>
    <li> 오버라이딩은 임의의 클래스가 다른 클래스를 상속 받거나 인터페이스를 구현했을 때 상위 클래스 또는 인터페이스에 정의된 메소드를 재정의하여 사용하는 것입니다. 메소드 호출 시 재정의 되어 있지 않다면 상위 클래스의 메서드가 호출됩니다.</li>
    <li> 오버로딩은 메소드에 주어진 인자에 따라 동작을 다르게 구현할 수 있는것입니다. 코드의 중복이 줄어들고 가독성이 늘어납니다. 반환 형은 바꿀 수 없지만 인자의개수, 인자의 타입에 따라 다르게 구현할 수 있습니다.</li>
  </ul>
</details>

<details>
  <summary>OOP의 장단점</summary>
  <ul>
    <li> 객체를 중심으로 프로그래밍하기 때문에 프로그램을 이해하고 파악하기 쉬우며 강한 응집력과 약한 결합력을 가집니다. 또한 재사용성과 확장성 , 융통성이 높기 때문에 디버깅과 유지보수가 용이하고 설계와 분석이 비교적 쉽습니다.</li>
    <li> 객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 오버헤드가 발생하게 됩니다. 객체가 상태를 갖기 때문에 예상치 못한 부작용이 발생할 수 있습니다. 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 가지게 되어 내부에서 버그를 발생시킬 수 있습니다. 이는 함수형 프로그래밍 등장의 패러다임입니다.</li>
  </ul>
</details>

<details>
  <summary>OOP의 5대 원칙</summary>
  <ul>
    <li> S(SRP, Single Responsibillity Principle): 단일 책임 원칙. 객체는 단 하나의 책임만 가져야 한다.</li>
    <li> O(OCP, Open Closed Principle): 개방-폐쇄 원칙. 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.</li>
    <li> L(LSP): 리스코프 치환 원칙. 일반화 관계에 대한 이야기이며, 자식 클래스는 최소환 자신의 부모 클래스에서 가능한 행위는 수행할 수 있음을 보장해야 합니다.</li>
    <li> I(ISP): 인터페이스 분리 원칙. 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.</li>
    <li> D(DSP): 고수준 모듈은 저수준 모듈에 의존하면 안 되고, 둘은 모두 추상화(인터페이스)에 의존해야 한다. 즉 구현 클래스에 의존하지 말고 인터페이스에 의존하라는 것.</li>
  </ul>
</details>

<details>
  <summary>객체지향 프로그래밍과 절차지향 프로그래밍의 차이</summary>
  <ul>
    <li> 절차지향 프로그래밍은 실행하고자 하는 절차를 정의하고 이 절차대로 프로그래밍 하는 방법입니다. 목적을 달성하기 위한 일의 흐름에 중점을 둡니다.</li>
    <li> 객체지향 프로그래밍은 실 세상의 물체를 객체로 표현하고, 이들 사이의 관계, 상호 작용을 프로그램으로 구현합니다. 객체 지향의 핵심은 연관되어 있는 변수와 메서드를 하나의 그룹으로 묶어서 그룹핑하는 것입니다. 사람의 사고와 가장 비슷하게 프로그래밍을 하기 위해 생성된 기법이며, 하나의 클래스를 바탕으로 서로 다른 상태를 가진 인스턴스를 만들면 서로 다른 행동을 하게됩니다. 즉, 하나의 클래스가 여러 개의 인스턴스가 될 수 있다는 점이 객체 지향이 제공하는 가장 기본적인 재활용성이라고 할 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary>java의 non-static과 static 차이</summary>
  <ul>
    <li> java non-static 멤버는 객체마다 별도로 존재하며 인스턴스 멤버라고 부릅니다. 객체 생성시에 멤버가 생성됩니다. 객체가 생길때 멤버도 생성되며, 생성 후 사용 가능합니다. 객체가 사라지면 함께 사라집니다. 멤버는 객체 내에 각각의 공간을 유지하며 공유되지 않습니다. </li>
    <li> static 멤버는 클래스당 하나가 생성됩니다. 객체 내부가 아닌 별도의 공간에 생성되며 클래스 멤버라고 부릅니다. 클래스 로딩 시에 멤버가 생성되며 객체가 생기기 전에 이미 생성됩니다. 객체를 생성하지 않고도 사용할 수 있으며 객체가 사라져도 멤버는 사라지지 않습니다. 동일한 클래스의 모든 객체들에 의해 공유됩니다. </li>
  </ul>
</details>

<details>
  <summary>java 메인 메서드가 스태틱인 이유가 뭔가요?</summary>
  <ul>
    <li> static 멤버는 클래스 로딩(프로그램 시작)시 메모리에 로드되어 인스턴스를 생성하지 않아도 호출이 가능합니다. 메인은 JVM 인스턴스가 없는 클래스의 메인을 호출해야하기 때문에 static이어야 합니다.</li>
  </ul>
</details>

<details>
  <summary>jvm에서의 static</summary>
  <ul>
    <li> 코드를 실행하면 컴파일러가 .java 코드를 .class(바이트 코드)로 변환합니다. 클래스 로더가 .class 파일을 메모리 영역에 로드합니다. 런타임 데이터 영역 중 메소드 영역(=class area=static area)라고 불리는 영역에 클래스 변수가 저장되는데, static 변수 또한 여기에 포함됩니다. JVM은 메소드 영역에 로드된 메인 함수를 실행합니다.</li>
  </ul>
</details>

<details>
  <summary>java에서 final은 뭔가요?</summary>
  <ul>
    <li> 자바에서 final 키워드는 변수나 메서드가 변경 불가능하도록 만드는 것입니다. 원시 타입의 변수에 적용시 해당 변수의 값은 변경이 불가능합니다. 참조 타입 변수에 적용시 참조 변수가 힙 내의 다른 객체를 가리키도록 변경할 수 없습니다. 메서드에 적용시 해당 메서드를 오버라이드 할 수 없으며, 클래스에 적용시 해당 클래스의 하위 클래스를 정의할 수 없습니다.</li>
  </ul>
</details>

<details>
  <summary>java에서 finally는 뭔가요?</summary>
  <ul>
    <li> try/catch 블록이 종료될 때 항상 실행될 코드 블록을 정의하기 위해 사용합니다. finally는 선택적으로 트라이 혹은 캐치 블록 뒤에 정의할 때 사용되며, 예외가 발생하더라도 항상 실행됩니다.</li>
  </ul>
</details>

<details>
  <summary>java에서 finalize()는 뭔가요?</summary>
  <ul>
    <li> GC가 더 이상의 참조가 존재하지 않는 객체를 메모리에서 삭제하겠다고 결정하는 순간 호출됩니다. Object 클래스의 finalize() 메서드를 오버라이드 해서 맞춤별 GC를 정의할 수 있습니다.</li>
  </ul>
</details>

## JVM

<details>
  <summary>JVM이 뭔가요?</summary>
  <ul>
    <li> JVM은 자바 가상 머신의 약자를 따서 부르는 용어입니다. 플랫폼 독립적으로 자바 바이트코드를 실행하기 위한 가상 머신입니다. 갖춘 기능으로는 크게 자바 프로그램이 어느 기기나 운영체제 상에서도 실행될 수 있도록 하는것이며, 프로그램 메모리를 관리하고 최적화 하는 것입니다. 개발자들이 말하는 JVM은 보통 어느 기기상에서 실행되고 있는 프로세스, 특히 자바 앱에 대한 리소스를 대표하고 통제하는 서버를 지칭합니다. 자바 애플리케이션을 클래스 로더를 통해 읽어들이고, 자바 API와 함꼐 실행하는 역할을 수행하며, JAVA와 OS 사이에서 중개자 역할을 수행하여 OS에 구애받지 않고 재사용을 가능하게 합니다. </li>
  </ul>
</details>

<details>
  <summary>JVM의 실행과정</summary>
  <ul>
    <li> 프로그램이 실행되면, JVM은 OS로부터 이 프로그램이 필요로하는 메모리를 할당받음. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리합니다. 자바 컴파일러(JAVAC)가 자바 소스코드를 읽고, 자바 바이트코드(.class)로 변환시키며, 변경된 class 파일들을 클래스 로더를 통해 JVM 메모리 영역으로 로딩합니다. 로딩된 class파일들은 Execution engine을 통해 해석되며, 해석된 바이트 코드는 메모리 영역에 배치되어 실질적인 수행이 이루어집니다.. 이러한 실행 과정 속 JVM은 필요에 따라 스레드 동기화나 가비지 컬렉션 같은 메모리 관리 작업을 수행하게됩니다.
</li>
  </ul>
</details>

<details>
  <summary>JVM은 어떻게 구성되어 있나요?</summary>
  <ul>
    <li> JVM은 자바 소스코드를 바이트 코드로 변환시켜 주는 컴파일러, JVM 런타임시에 처음으로 클래스를 참조할 때 해당 클래스를 로드하고 메모리 여역에 적재하는 클래스 로더, JVM이 운영체제 위에서 실행되면서 할당받는 메모리 영역인 데이터 영역, 로딩된 바이트 코드들을 실제로 실행하고 가비지 컬렉션 등을 수행하는 실행 엔진, 네이티브 코드와의 상호작용을 지원하는 JNI로 구성되어 있습니다.</li>
    <li> 실행 엔진에는 인터프리터, JIT(Just-In-Time) 컴파일러, GC가 있습니다. JIT는 핫스팍(자주 실행되는 코드)를 감지해서 바이트 코드를 네이티브 머신 코드로 컴파일해 속도를 개선하는 역할을 수행합니다. 컴파일 된 코드는 캐시되어 재사용되며, 자바가 인터프리터 언어와 컴파일 언어의 장점을 모두 가지게 해줍니다. 인터프리터는 바이트코드를 한 줄씩 순차적으로 해석하며 진행하는 것입니다. 초기 실행속도는 빠르지만 반복 실행시 비효율적입니다. 가비지 컬렉션은 JVM이 메모리를 관리하는것입니다. 가비지 컬렉션은 자바 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아내서 제거하는 역할을 합니다.</li>
  </ul>
</details>

<details>
  <summary>Stack Over Flow와 OOM의 차이점이 뭔가요?</summary>
  <ul>
    <li> 스택 오버플로우는 JVM 스택영역에서 발생합니다. 스레드 별로 존재하는 스택 메모리가 메서드 호출 프레임으로 가득 차서 발생하는 오류이고, 대표적으로 재귀 호출이 원인입니다. OOM은 힙이나 메타스페이스 처럼 JVM 전체 메모리에서 더 이상 객체나 클래스를 할당할 공간이 없을 때 발생하는 오류입니다. GC가 회수할 수 없을 만큼 메모리가 고갈된 상태에서 발생합니다.</li>
  </ul>
</details>

<details>
  <summary>GC에 대해 설명해주세요</summary>
  <ul>
    <li> 자바 이전에는 프로그래머가 모든 프로그램 메모리를 관리했지만, 자바에서는 JVM이 프로그램 메모리를 관리합니다. JVM에서 메모리를 관리하는 프로세스를 가비지 컬렌션이라고 하며, 자바 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아내서 제거하는 역할입니다. GC는 크게 마크-스윕-컴팩션(압축)단계로 진행되며, young 제너레이션에서는 마이너 gc, old 제너레이션에서는 메이저/full gc가 발생합니다. GC 수행시 stop-the-world로 애플리케이션이 잠시 멈추게 되며, G1 GC와 같은 알고리즘으로 최소화 합니다.</li>
    <li> 마이너 GC는 에덴 영역에 있는 객체를 서바이벌 영역으로 이동시키고, 이 과정을 반복하다 일정 횟수이상 살아남은 객체는 old로 이동시킵니다. 메이저 GC는 올드 영역에 있는 모든 객체를 검사해 참조되지 않는 객체를 한꺼번에 삭제합니다. 시간이 오래 걸리고 실행 중 프로세스가 정지됩니다. GC를 실행하는 스레드 외에 나머지 스레드는 모두 작업을 멈춥니다. full gc는 young+old+metaspace 모두를 정리합니다. 매우 비싸고 오래걸리며, 서버가 중단되게 되어 성능 문제에 큰 영향을 줍니다.</li>
  </ul>
</details>

<details>
  <summary>GC는 언제 일어나나요?</summary>
  <ul>
    <li> 마이너 gc는 에덴이나 서바이벌 영역에 객체를 더 할당할 수 없을때 발생합니다. 메이저 gc는 old 제너레이션이 가득 차거나 객체 승격 시 공간이 부족할 때 말생합니다. full gc는 메이저 gc로도 해결되지 않거나 메타 스페이스 부족, System.gc()를 호출할때 발생합니다. 즉 gc는 주로 할당 실패가 발생했을때 트리거 됩니다.</li>
  </ul>
</details>
