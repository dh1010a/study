# CS 면접을 위한 자바 질문리스트

<details>
  <summary>자바 애플리케이션의 실행과정에 대해 말해주세요</summary>
  <ul>
    <li> 컴파일러가 자바 소스를 바이트코드로 변환합니다. 클래스 로더가 바이트 코드를 런타임 데이터 영역에 로드시킵니다. 로딩된 바이트코드가 실행엔진에 의해서 실행되게 됩니다. </li>
  </ul>
</details>

<details>
  <summary>자바의 메모리 구조에 대해 말해주세요</summary>
  <ul>
    <li> 자바 메모리 구조는 크게 5가지 영역으로 구분됩니다. 스레드마다 PC Register, JVM Stack, Natice Method Stack이 있습니다. 스레드 공통으로는 Heap과 Method 영역이 있습니다. PC Register는 현재 수행중인 JVM 명령어가 들어가 있고, JVM 스택은 호출된 메서드의 매개변수, 지역변수, 리턴 정보가 저장됩니다. 네이티브 메서드 스택은 자바 외의 언어인 C나 C++과 같은 것들을 수행하기 위한 영역입니다. 메서드 영역은 클래스 별로 전역변수, 정적 변수, 메소드 정보들이 저장됩니다. 힙 영역은 런타임중 생성되는 객체들이 동적으로 할당되는 것입니다.</li>
    <li> 힙 영역에는 permanent Generation, New/Young 영역, Old 영역이 있습니다. 퍼머넌트 제너레이션은 생성된 객체들 정보의 주소값이 저장되어있으며, 클래스나 메서드에 대한 메타정보가 저장됩니다. 또한 리플렉션을 사용하여 동적으로 클래스가 로딩되는 경우 사용합니다. new/young은 에덴에서 객체들이 최초로 생성되게 되며 서바이벌 0/1은 에덴에서 참조되는 객체들이 저장되는 공간입니다. 올드 영역은 뉴 영역에서 일정시간 참조되고 살아남은 객체들이 저장되고 있던 에덴에 객체가 가득차면 마이너 gc가 발생하는데, 이때 에덴에 있는 값들을 서바이벌 1 영역에 복사하고 나머지 영역의 객체를 삭제합니다. 다음 GC에는 서바이벌 1 -> 0 으로 복사하며 이 과정을 반복하는데, 일정 횟수 이상 살아남으면 올드 영역으로 이동합니다. </li>
  </ul>
</details>

<details>
  <summary>자바의 버전 8의 가장 큰 변화가 뭔가요?</summary>
  <ul>
    <li> 자바 8은 멀티 코어가 대중화 됨에 따라 병렬 처리를 더 잘 지원하기 위한 기능들이 추가되었습니다. Stream API, Method Reference & Lamda, Default Method 가 크게 추가되었습니다.</li>
    <li> 스트림은 병렬 연산을 지원하는 API입니다. 기존에 병렬 처리를 위해 사용하던 synchronized를 사용하지 않아도 됩니다. 싱크로나이즈드는 에러를 유발할 가능성과 비용 측면에서 문제점이 많다는 단점이 있었습니다. 스트림은 주어진 항목들을 연속으로 제공하는 기능입니다. 파이프 라인을 구축하여, 진행되는 순서는 정해져 있지만 동시에 작업을 처리하는것이 가능합니다. 스트림 파이프 라인이 작업을 처리할 때 여러 CPU 코어에 할당 작업을 진행하여 하나의 큰 항목을 처리할 때 효율적으로 작업할 수 있습니다. 즉 스레드를 사용하지 않아도 병렬 처리를 간편하게 할 수 있게 되었습니다.</li>
    <li> 메서드 레퍼런스와 람다를 자바에서 활용할 수 있게 되면서, 동적 파라미터를 구현할 수 있게 되었습니다. 기존에도 익명 클래스로 구현은 가능했지만 코드가 복잡해지고 재사용이 힘든 단점을 해결할 수 있게 되었습니다. </li>
  </ul>
</details>

<details>
  <summary>자바 8과 17의 차이점이 뭔가요?</summary>
  <ul>
    <li> 첫째, 성능과 GC가 많이 개선됐습니다. Java 17은 G1GC가 기본이고, 더 빠르고 안정적인 GC가 도입돼 서버 처리 성능과 지연시간이 줄어들었습니다. 둘째, 개발 생산성이 좋아졌습니다. var 키워드, text block("""), record 같은 문법이 추가되면서 코드가 훨씬 간결해졌고 DTO 만들 때도 편해졌습니다. 셋째, 보안과 표준 API가 업그레이드되었습니다. HttpClient, TLS 1.3 같은 최신 기능들이 기본 지원됩니다.</li>
  </ul>
</details>

## JVM

<details>
  <summary>JVM이 뭔가요?</summary>
  <ul>
    <li> JVM은 자바 가상 머신의 약자를 따서 부르는 용어입니다. 플랫폼 독립적으로 자바 바이트코드를 실행하기 위한 가상 머신입니다. 갖춘 기능으로는 크게 자바 프로그램이 어느 기기나 운영체제 상에서도 실행될 수 있도록 하는것이며, 프로그램 메모리를 관리하고 최적화 하는 것입니다. 개발자들이 말하는 JVM은 보통 어느 기기상에서 실행되고 있는 프로세스, 특히 자바 앱에 대한 리소스를 대표하고 통제하는 서버를 지칭합니다. 자바 애플리케이션을 클래스 로더를 통해 읽어들이고, 자바 API와 함꼐 실행하는 역할을 수행하며, JAVA와 OS 사이에서 중개자 역할을 수행하여 OS에 구애받지 않고 재사용을 가능하게 합니다. </li>
  </ul>
</details>

<details>
  <summary>JVM은 어떻게 구성되어 있나요?</summary>
  <ul>
    <li> JVM은 자바 소스코드를 바이트 코드로 변환시켜 주는 컴파일러, JVM 런타임시에 처음으로 클래스를 참조할 때 해당 클래스를 로드하고 메모리 여역에 적재하는 클래스 로더, JVM이 운영체제 위에서 실행되면서 할당받는 메모리 영역인 데이터 영역, 로딩된 바이트 코드들을 실제로 실행하고 가비지 컬렉션 등을 수행하는 실행 엔진, 네이티브 코드와의 상호작용을 지원하는 JNI로 구성되어 있습니다.</li>
    <li> 실행 엔진에는 인터프리터, JIT(Just-In-Time) 컴파일러, GC가 있습니다. JIT는 핫스팍(자주 실행되는 코드)를 감지해서 바이트 코드를 네이티브 머신 코드로 컴파일해 속도를 개선하는 역할을 수행합니다. 컴파일 된 코드는 캐시되어 재사용되며, 자바가 인터프리터 언어와 컴파일 언어의 장점을 모두 가지게 해줍니다. 인터프리터는 바이트코드를 한 줄씩 순차적으로 해석하며 진행하는 것입니다. 초기 실행속도는 빠르지만 반복 실행시 비효율적입니다. 가비지 컬렉션은 JVM이 메모리를 관리하는것입니다. 가비지 컬렉션은 자바 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아내서 제거하는 역할을 합니다.</li>
  </ul>
</details>

<details>
  <summary>Stack Over Flow와 OOM의 차이점이 뭔가요?</summary>
  <ul>
    <li> 스택 오버플로우는 JVM 스택영역에서 발생합니다. 스레드 별로 존재하는 스택 메모리가 메서드 호출 프레임으로 가득 차서 발생하는 오류이고, 대표적으로 재귀 호출이 원인입니다. OOM은 힙이나 메타스페이스 처럼 JVM 전체 메모리에서 더 이상 객체나 클래스를 할당할 공간이 없을 때 발생하는 오류입니다. GC가 회수할 수 없을 만큼 메모리가 고갈된 상태에서 발생합니다.</li>
  </ul>
</details>

<details>
  <summary>GC에 대해 설명해주세요</summary>
  <ul>
    <li> 자바 이전에는 프로그래머가 모든 프로그램 메모리를 관리했지만, 자바에서는 JVM이 프로그램 메모리를 관리합니다. JVM에서 메모리를 관리하는 프로세스를 가비지 컬렌션이라고 하며, 자바 프로그램에서 사용되지 않는 메모리를 지속적으로 찾아내서 제거하는 역할입니다. GC는 크게 마크-스윕-컴팩션(압축)단계로 진행되며, young 제너레이션에서는 마이너 gc, old 제너레이션에서는 메이저/full gc가 발생합니다. GC 수행시 stop-the-world로 애플리케이션이 잠시 멈추게 되며, G1 GC와 같은 알고리즘으로 최소화 합니다.</li>
    <li> 마이너 GC는 에덴 영역에 있는 객체를 서바이벌 영역으로 이동시키고, 이 과정을 반복하다 일정 횟수이상 살아남은 객체는 old로 이동시킵니다. 메이저 GC는 올드 영역에 있는 모든 객체를 검사해 참조되지 않는 객체를 한꺼번에 삭제합니다. 시간이 오래 걸리고 실행 중 프로세스가 정지됩니다. GC를 실행하는 스레드 외에 나머지 스레드는 모두 작업을 멈춥니다. full gc는 young+old+metaspace 모두를 정리합니다. 매우 비싸고 오래걸리며, 서버가 중단되게 되어 성능 문제에 큰 영향을 줍니다.</li>
  </ul>
</details>

<details>
  <summary>GC는 언제 일어나나요?</summary>
  <ul>
    <li> 마이너 gc는 에덴이나 서바이벌 영역에 객체를 더 할당할 수 없을때 발생합니다. 메이저 gc는 old 제너레이션이 가득 차거나 객체 승격 시 공간이 부족할 때 말생합니다. full gc는 메이저 gc로도 해결되지 않거나 메타 스페이스 부족, System.gc()를 호출할때 발생합니다. 즉 gc는 주로 할당 실패가 발생했을때 트리거 됩니다.</li>
  </ul>
</details>
