# Redis Redlock

## 목차
1. 분산락과 Redlock
2. Redlock의 한계
3. 정리

# 1. 분산락과 Redlock
## 분산락의 필요성
- 분산 환경에서 서로 다른 클라이언트가 공유 리소스를 사용하는 경우가 많음
- 레디스는 싱글 스레드로 동작하기 때문에 단일 레디스 노드를 구축해 사용해도 동시성 문제가 발생하지 않음
- 리소스에 대해 값을 설정하여 값이 설정된 경우에는 다른 리소스의 접근을 차단할 수 있음
- `SET key value NX PX 30000`
  - key, value를 저장하는데 NotExists일 경우에만 저장하고, 30초(30000ms) 동안 유지(TTL)
  - 잠금 해제는 `DEL key`
  - 이렇게 DEL 연산을 검증없이 허용하면 잠금을 획득하지도 않은 클라이언트가 잠금을 해제할 수 있으므로 위험
  - 따라서 키가 존재하고, 키에 저장된 값이 클라이언트의 값과 일치하는 경우 잠금을 해제할 수 있도록 해야함
- 모든 잠금이 임의의 문자열로 서명되므로 클라이언트가 설정된 값과 동일한 경우에만 잠금이 제거되거나 시간이 지나면 자연스럽게 해제
- 아래와 같이 루아 스크립트를 작성해 사용할 수 있다

```
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

- 이러한 방식으로 구축된 단일 레디스 노드는 단일 장애 지점(SPOF)가 될 수 있음
- Master-Slave 복제(replication)모드로 레디스 서버를 구축하기도 함
- 이런 구조도 레디스의 복제는 비동기식이기 때문에 경쟁 상태가 발생할 수 있음
  1. A가 마스터에서 잠금 획득
  2. 키에 대한 쓰기가 복제본으로 전송되기 전에 마스터 다운
  3. 복제본이 마스터로 승격
  4. B는 A가 잠금을 보유하고 있는 리소스에 대해 잠금을 획득할 수 있음


 ## Redis가 제공하는 분산락 RedLock
 - 위와 같은 문제를 보완하기 위해 레디스는 분산락 알고리즘의 구현으로 레드락(Redlock) 알고리즘 제안
 - N개의 단일 레디스 노드들을 이용하여, Quorum 이상의 노드에서 잠금을 획득하면 분산락을 획득한 것으로 판단
 - 분산 환경에서 락을 획득하기 위한 작업
   1. 현재 시간을 ms 단위로 가져옴
   2. 모든 인스턴스에서 순차적으로 잠금을 획득하려고 시도. 각 인스턴스에 잠금을 설정할 때 클라이언트는 전체 잠금 자동 해제 시간에 비해 작은 타임아웃을 사용하여 잠금 획득.
      이를 통해 클라이언트가 다운된 레디스 노드와 통신하려고 오랫동안 블로킹 되는 것을 방지할 수 있음
   3. 클라이언트는 (현재시간 - 1단계에서 얻은 타임스탬프)를 통해 잠금을 획득하기 위해 경과한 시간을 계산. 클라이언트가 과반이 넘는 인스턴스에서 잠금을
      획득했고, 총 경과 시간이 잠금 유효시간 보다 적다면 분산락을 획득한 것으로 간주
   4. 분산락을 획득한 경우, 잠금 유효 시간은 3단계에서 계산한 시간으로 간주
   5. 분산락을 획득하지 못한 경우(과반이 넘는 인스턴스를 잠글 수 없거나 유효시간이 음수인 경우), 클라이언트는 모든 인스턴스에서 잠금을 해제하려고 시도
- 클라이언트가 잠금을 획득할 수 없는 경우, 동시에 동일한 리소스에 대해 잠금을 획득하려는 여러 클라이언트의 동기화를 해제하기 위해 무작위 지연 후 재시도 해야함
- 이로인해 어떠한 클라이언트도 잠금을 획득하지 못하는 Split brain Condition 문제가 발생할 수 있음
- 클라이언트가 잠금을 획득하려고 시도하는 속도가 빠를 수록 Split brain Condition문제의 가능성과 재시도 필요성이 작아지므로 이상적으로는 클라이언트가 멀티 플렉싱을 사용해 N개의 인스턴스에 동시에 SET 명령을 보내야 함
- 재시도 노력에도 불구하고 획득 실패시 잠금을 빠르게 해제함으로서 다른 클라이언트가 잠금을 획득해 만교를 기다릴 필요가 없도록 해야함

> Split brain Condition
>
> - 하나의 시스템이 여러 개의 독립된 두뇌처럼 행동하는 비정상 상태
> - 분산 시스템에서 노드들 사이의 네트워크 단절(Partition)이 발생했을 떄, 각 노드들이 자신이 마스터/리더 역할을 맡아야 한다고 착각하고 동시다발적으로 운영되면서 충돌이나 데이터 불일치를 초래하는 상황

> 멀티 플렉싱
>
> - 한개의 채널에 여러 개의 데이터 흐름을 동시에 실어 보내는 기술


# 2. RedLock의 한계

### Clock Drift로 인한 문제
- 레드락 알고리즘은 노드들 간에 동기화된 시계(Synchronized clock)은 없지만, 로컬 시간이 거의 동일한 속도로 갱신된다는 가정에 의존
- 하지만 현실에서는 클럭이 정확한 속도로 동작하지 않는 클럭 드리프트 현상으로 인해 레드락 알고리즘에 문제가 생길 수 있음

1. 클라이언트 1이 노트 A,B,C에서 잠금을 획득하지만 네트워크 문제로 인해 D,E에서는 획득 실패
2. 이때 노드 C의 시계가 앞으로 이동하며 잠금이 만료
3. 클라이언트 2가 노드 C,D,E에서 잠금을 획득하지만, 네트워크 문제로 인해 A와 B에서는 잠금 획득에 실패한다
4. 이제 클라이언트 1과 2는 모두 자신이 잠금을 획득했다고 믿음

- 획득한 잠금을 디스크에 저장하기 전에 노드 C가 다운되고 재시작되면 비슷한 문제가 발생할 수 있음
- Redlock은 다운된 노드의 재시작을 최소한 가장 긴 잠금의 수명 시간만큼 지연시킬 것을 권장
- 그러나 이러한 재시작 지연도 결국 상당히 정확한 시간 측정에 의존하며, 시계가 점프하면 실패

### 애플리케이션 중단 또는 네트워크 지연으로 인한 문제
- clock jump가 비현실적이라고 생각한다면, 다음과 같이 애플리케이션이 중지된 경우에도 문제가 생길 수 있다
  - 클라이언트가 공유 스토리지에 있는 파일을 업데이트 하는 경우, 먼저 잠금을 획득한 후 파일을 읽고 변경한 후에 수정된 파일을 쓰고 잠금을 해제
- 이때 클라이언트 1의 애플리케이션이 중지되면서 문제가 생길 수 있음

- 클라이언트 1이 분산락을 획득
- 이때 클라이언트1에서 애플리케이션 중지가 발생하고, 그 사이에 분산락이 만료
- 클라이언트 2는 분산락을 획득하고 파일을 갱신한다.
- 클라이언트 1의 애플리케이션이 복구되고 파일을 갱신한다.
  - 동시성 문제가 발생

![image](https://github.com/user-attachments/assets/6cb206c3-2887-4a3c-a784-c4c612f9c0c2)

- stop-the-world GC는 잠금이 만료될 만큼 오래 지속 될 수 있음
- 네트워크 지연 등에 의해서도 동일한 문제가 발생 가능
- 모든 쓰기 요청에 펜싱 토큰이나 버전을 포함시킬 수 있음
- 펜싱 토큰은 클라이언트가 잠금을 획득할 때 마다 증가하는 숫자를 의미
- 하지만 레드락은 이러한 기능이 없으면 경합 상태가 발생하여 동시성 문제가 생길 수 있음
- 그렇다고 단일 레디스에 관리하면 단일 장애지점(SPOF)가 되어 문제가 생길 수 있음
- 여러 노드에 카운터를 유지하면 카운터가 동기화 되지 않을 수 있음

# 3. 정리
## 레드락 알고리즘 요약
- N대의 싱글 노드 레디스 존재
- 클라이언트에서 잠금을 위해 N대의 노드에 동시 요청(SETNX)를 보냄
- N대 중 과반수의 잠금을 획득했다면 분산락 획득에 성공
- 만약 실패했다면 모든 N대의 노드에 해제 요청(DELETE)를 보냄
- 무작위 지연 후 재시도
- 자바 진영에서는 Redlock 구현체인 Redisson이 제공되고 있음
- 레드락은 절대적으로 안전하지 않고, 시스템 클록에 의한 clock drift 현상이나 애플리케이션 중지에 의해 충분히 문제가 생길 수 있음
- 완전한 정확성이 필요하다면 Redlock 대신 Zookeeper와 같은 합의 시스템을 사용하는 것이 더 좋은 선택이 될 수 있음

## Ref
- https://mangkyu.tistory.com/311
