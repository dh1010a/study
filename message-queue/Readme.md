# Message Queue

![image](https://github.com/user-attachments/assets/c1a0f219-e105-407e-8f0c-333e3f56aee1)


## 목차
1. 메세지 지향 미들웨어
2. 메세지 큐
3. 메세지 브로커와 이벤트 브로커
4. 메시지 큐의 종류

# 1. 메세지 지향 미들웨어(MOM)

> 메세지 지향 미들웨어(Message-Oriented Middleware)는 응용 소프트웨어 간의 비동기적 데이터 통신을 위한 미들웨어 소프트웨어

- 프로세스 간 데이터를 비동기 방식으로 주고받도록 지원
- 메시지를 **임시 저장(보관)**하거나, 라우팅 및 변환할 수 있음
- 송신자와 수신자가 동시에 연결되어 있을 필요가 없음
- 다양한 서비스 간에 느슨한 결합(loose coupling) 을 제공해 유지보수와 확장에 유리
- 내결함성(fault tolerance): 장애 발생 시에도 메시지를 유실하지 않고 재처리 가능
- 소비자 수 증가에 따라 수평 확장성이 우수

### 메세지 큐는 이러한 MOM의 구현체 중 하나

# 2. 메세지 큐

> 메세지 큐는 비동기적으로 데이터를 전달하는 시스템으로, 생산자(Producer) 와 소비자(Consumer) 간의 중개 역할을 수행

- 큐(Queue) 자료구조 기반: 선입선출(FIFO) 방식으로 메시지를 처리
- 메시지를 큐에 일시 저장해, 소비자가 처리 가능한 시점에 가져가도록 함
- 시스템 부하 분산, 안정성 확보, 서비스 간 독립성 보장
- 메시지 처리 속도 차이, 장애 복구, 재처리 등 상황에 대응 가능
- 대표 구성 요소:
  - Producer: 메시지를 생성하여 큐에 보냄
  - Queue (Broker): 메시지를 임시 저장
  - Consumer: 메시지를 꺼내어 처리
 
## 장점
1. 비동기(Asynchronous): Queue에 넣어두기 때문에 나중에 처리할 수 있음
2. 낮은 결합도(Decoupling): 애플리케이션과 분리할 수 있음
3. 탄력성(Resilience): 일부가 실패 시 전체에 영향을 받지 않음
4. 과잉(Redundancy): 실패 할 경우 재실행이 가능
5. 신뢰성(Guarantees): 작업이 처리된 걸 확인할 수 있음
6. 확장성(Scalable): 다수의 프로세스들이 큐에 메시지를 보낼 수 있음

메시지 큐는 Command 기반의 메시지 브로커, 혹은 Event 기반의 이벤트 브로커 형태로 사용될 수 있으며 용도에 따라 기술 선택과 아키텍처 설계가 달라짐

# 3. 메세지 브로커와 이벤트 브로커
- 메세지 브로커는 서비스 간의 메세지 전달을 중개하며, 이벤트 브로커는 이벤트를 게시하고 구독하는 역할을 함
- 메세지 큐가 메세지 혹은 이벤트가 송신되고 수신되는 하나의 통신 통로라고 하면, **브로커**는 메세지 큐에 메세지 혹은 이벤트를 넣어주고 중개하는 역할을 하는 주체

## 메세지 브로커
- 메세지 브로커는 `메세지 지향 미들워어(Message-Oriented Middleware)`를 구현하는데 사용되는 시스템
- 메세지 브로커는 데이터를 보내고 처리하고 삭제하는 구조
- 어플리케이션간의 네트워크 데이터를 중계해주는 역할을 담당한다.
- 메세지 브로커는 이벤트 브로커의 기능을 하지 못함

## 이벤트 브로커
- 이벤트 브로커는 `이벤트 주도아키텍쳐(EDA- Event Driven Architecture)` 를 구현하는데 사용되는 시스템
- 이벤트 브로커는 이벤트라고 불리는 레코드를 보관하고 인덱스를 통해 개별 엑세스를 관리 할 수있음
- 또한 영구적으로 이벤트를 보존할수 있으며 이벤트 데이터를 브로커에 저장함으로 단일 진실 공급원으로 사용 가능하다.
- 이벤트 브로커 또한 기본적으로 메세지 브로커의 역할을 할 수 있음

## 차이점
- 레코드를 큐에 보관을 하느냐, 혹은 단순히 미들웨어 단에서 네트워크간 통신을 위해 데이터를 전달하고 삭제 하는 역할을 하는가에 따라 이벤트기반, 메세지기반 브로커로 분리 할 수 있음
- 메시지 브로커는 소비되면 삭제되지만, 이벤트 브로커는 영구 저장 가능
- 메시지 브로커는 명령을 전달 (주문 완료했으니 배송 처리 해줘)
- 이벤트 브로커는 상태 변화를 방송 (주문이 완료됐으니 알림, 추천, 통계 시스템이 이를 감지하고 각자 로직 수행)
- 결국 메세지기반에 중점을두고 처리하느냐 , 이벤트기반에 두고 데이터를 처리하느냐에 따라 다르게 분리됨
- 메세지큐는 Producer / Consumer 의 패턴을 사용하고, 이벤트큐는 Publisher / Subscriber 의 패턴을 사용
- 메시지 브로커는 1대1 처리, 이벤트 브로커는 1대 다수 처리로 주로 사용 (명령은 한명이 처리, 구독은 여러명이 처리)

|상황|선택|이유|
| --- | --- | --- |
|단일 작업 위임 (메일 전송, PDF 생성 등) |메시지 브로커|단순 Queue 처리로 충분|
|하나의 이벤트로 여러 시스템 반응해야 할 때	|이벤트 브로커	|Pub/Sub로 확장성 확보|
|재처리, 로그 보존이 중요한 경우	|이벤트 브로커|	Kafka 오프셋, 로그 기반|
|트랜잭션 흐름과 분리하고 싶을 때|	메시지 브로커| 트랜잭션 종속성 적음|

# 4. 메시지 브로커와 이벤트 브로커의 종류

## 1. RabbitMQ
- `RabbitMQ` 는 `AMQP` 프로토콜을 구현해 놓은 오픈 소스 메시지 브로커
- 메시지의 내구성을 보장하여 시스템 재시작 후에도 메시지가 유실되지 않음
- Broker 중심 아키텍처로, Exchange, Queue, Binding 개념을 통해 유연한 메시지 라우팅이 가능함.
- 관리 UI 존재
- 웹 기반 관리 UI를 제공하여 큐 상태, 메시지 트래픽 등을 실시간으로 확인할 수 있음.
- 다양한 언어와 운영체제에서 사용 가능하며, 기업에서도 널리 채택됨.
- 단일 노드 기준 약 20K msg/sec 처리 성능으로, 고속 처리보다는 안정성과 유연한 라우팅에 초점.

> ### AMQP
>
> `AMQP`는 메시지 지향 미들웨어(MOM)을 위한 개방형 표준 응용 계층 프로토콜
>![image](https://github.com/user-attachments/assets/de27c80b-6318-48b3-af7f-66e37ea9f307)
>
> `AMQP`는 일반적인 메시지 큐와 비슷하지만 `Exchange`라는 라우터가 존재하여 `Binding` 개념 존재

### 구성 요소
- Producer : 요청을 보내는 주체, 보내고자 하는 메세지를 Exchange에 Publish함
- Consumer : Producer로 부터 메세지를 받아 처리하는 주체
- Exchange : Produer가 발행한 메세지를 어떤 메세지 큐로 전송할지 결정하는 장소 (라우팅)
- Queue : Consumer가 소비하기 전까지 메세지가 보관되는 장소
- Binding : Exchange와 Queue와의 관계. 즉, 특정 Exchange가 특정 Queue에 메세지를 보내도록 정의

### 장점
- 안정성: 메시지 내구성, 확인 및 재전송 메커니즘을 통해 높은 신뢰성 보장
- 유연한 라우팅: 복잡한 메시지 라우팅 및 필터링을 지원하여 다양한 아키텍처에 적합
- 관리 UI 제공: 웹 기반의 관리 UI를 통해 큐 상태, 메시지 트래픽 등을 쉽게 모니터링할 수 있음

### 단점
- 성능 문제: 상대적으로 높은 메시지 전송 지연과 처리량 제한이 있을 수 있음
- 운영 복잡성: 큐를 다루는 설정이 복잡하고, 대규모 시스템에서 확장이 어려울 수 있음
- 메모리 사용량: 메시지 지속성을 사용할 때, 메모리 사용량이 많아질 수 있음

## ActiveMQ
![image](https://github.com/user-attachments/assets/78853408-3d3a-4522-a58f-131176da21c0)

- Java 에서 채택한 대표적인 MOM 시스템
- ActiveMQ 는 JMS 스펙을 좀 더 사용하기 편리하게 구현한 오픈소스 메시지 브로커
- RabbitMQ 와 더불어 현재 대표적인 메세지 브로커로 사용되고 있음
- Java MOM 표준 API 이며 소프트웨어 응용 프로그램 구성 요소가 소비하는 요청, 보고서 또는 이벤트로 메시지를 작성, 전송, 수신 및 읽을 수있는 메시징 표준
- JMS는 다른 시스템의 프로그램이나 다른 프로그래밍 언어로 작성된 프로그램이 메시지를 통해 서로 조정할 수 있도록 지원
- 메시지 보장: 메시지 내구성, 확인, 재전송 메커니즘 제공
- 다양한 프로토콜 지원: OpenWire, AMQP, MQTT 등 다양한 프로토콜을 지원하여 다양한 환경에서 사용 가능
- 웹 관리 UI: ActiveMQ 자체 관리 UI를 통해 큐와 메시지의 상태를 쉽게 모니터링

> ### JMS
> 
> JMS 는 메세지 큐 및 Publish - Subscribe 패턴과 같은 메세지 기반 통신을 추상화하고 표준화한 API입니다.

### 구성 요소
- Message Broker : 목적지에 안전하게 메세지를 건네주는 중개자 역할
- Destination : 목적지에 배달될 2가지 메시지 모델 Queue 와 Topic
- Queue : 메세지가 전달되는 통로 (경합이 있음)
- Topic : Queue 와 비슷한 역할 그러나, 여러 Consumer 에게 메세지를 건네줄 수 있음 (경합이 없음)

### 처리 모델
- Queue 모델의 경우 메세지를 받는 Consumer 가 다수일 때 연결된 순서로 메세지 제공
- Topic 모델의 경우 메세지를 받는 Consumer 가 다수일 때 메세지는 모두에게 제공

![image](https://github.com/user-attachments/assets/268661f6-c92b-471a-b54c-a94bd611c939)


### 장점
- JMS 표준 지원: Java 기반 애플리케이션에 최적화되어 있어 통합이 용이
- 유연한 메시징 모델: 큐, 토픽 등 다양한 메시징 모델을 지원하여 유연하게 설계 가능
- 확장성: 클러스터링 및 분산 배치 기능을 통해 확장성이 뛰어남

### 단점
- 성능 한계: RabbitMQ나 Kafka에 비해 처리 성능이 떨어질 수 있음
- 복잡한 설정: 다양한 프로토콜을 지원하기 때문에 설정이 복잡할 수 있음
- 메시지 처리 속도: 대량의 메시지 처리 시 속도가 느려질 수 있음

## Apache Kafka
- Kafka는 LinkedIn에서 개발된 고성능, 고내구성, 확장성이 뛰어난 이벤트 스트리밍 플랫폼
- Kafka는 이벤트를 로그 형태로 저장하고, 구독자(Consumer)가 오프셋(offset)을 기준으로 필요한 시점부터 데이터를 가져가는 구조
- 메시지를 메모리에 저장하는 기존 메시징 시스템과는 달리 파일에 저장, 유실 가능성이 낮음
- 기본 메시징 시스템에서는 브로커(Broker)가 컨슈머(consumer)에게 메시지를 push해 주는 방식
- Kafka의 메시지 전송 방식은 Pull 기반으로, Consumer가 스스로 처리할 수 있을 만큼만 메시지를 가져가도록 설계됨
- 고속 메시지 처리, 복제(replication), 로그 기반 재처리, 실시간 데이터 스트리밍에 적합하다.
- 카프카의 파일 시스템을 활용한 고성능 디자인: 하드디스크는 메모리보다 수백배 느리지만 하드디스크의 순차적 읽기에 대한 성능은 메모리보다 크게 떨어지지 않기 때문에 성능이 우수
- 고성능: 초당 수백만 건의 메시지를 처리할 수 있을 만큼 뛰어난 성능
- 분산 아키텍처: 분산 시스템에 적합하여 수평 확장이 용이
- 내구성: 메시지를 디스크에 기록하여 영속성을 보장
- 실시간 스트리밍 처리: 실시간 로그 처리 및 이벤트 기반 시스템에 강력함
- Partitioning: 데이터를 파티셔닝하여 고가용성과 확장성 제공

![image](https://github.com/user-attachments/assets/3261e122-eb81-4583-9fd7-e70466a3ca28)

### 주요 개념
- Topic: 메시지 스트림 단위, 여러 파티션(Partition)으로 나뉘어 저장됨
- Partition: Topic의 물리적 단위로, 분산 저장과 병렬 처리를 가능하게 함
- Producer: 메시지를 생성하여 특정 Topic에 기록함
- Consumer Group: 여러 Consumer가 하나의 그룹을 이루어 메시지를 병렬로 처리함 (한 메시지는 그룹 내 하나의 Consumer만 처리)
- Broker: Kafka 서버 인스턴스, 메시지를 수신하고 보존함
- Offset: Consumer가 현재 읽고 있는 메시지 위치 (재처리 시점 지정 가능)

### 장점
- 고성능: 초당 수백만 건 이상의 메시지를 처리 가능
- 내구성: 메시지를 디스크에 저장하고 복제하여 데이터 유실 방지
- 확장성: 클러스터 구조로 수평 확장 가능, 대규모 트래픽 처리에 적합
- 유연성: 실시간 분석, 이벤트 소싱, 로그 수집 등 다양한 용도에 활용 가능
- 재처리 지원: 메시지를 보존하므로 장애 복구나 분석 목적의 재처리가 가능

단점
- 운영 복잡성: 초기 구성과 클러스터 운영이 어렵고, Zookeeper 또는 KRaft 설정 필요
- Push 모델 부재: Consumer가 직접 Polling해야 하므로 실시간 반응성이 떨어질 수 있음
- 라우팅 유연성 부족: RabbitMQ와 같은 복잡한 라우팅 기능은 상대적으로 부족함

> Kafka는 단일 시스템이 아닌 이벤트 스트리밍 플랫폼으로서, 대규모 시스템 간 이벤트 기반 통신과 분석을 위한 중심 허브 역할을 수행

